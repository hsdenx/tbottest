[
  {
    "peripheralmaps": [
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0026000 - 0xA0027FFF",
        "size": "8KB",
        "peripheral": "GICV",
        "peripheralmap": "GIC virtual CPU interface (GICV)"
      },
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0024000 - 0xA0025FFF",
        "size": "8KB",
        "peripheral": "GICH",
        "peripheralmap": "GIC virtual interface control, common(GICH)"
      },
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0022000 - 0xA0023FFF",
        "size": "8KB",
        "peripheral": "GICC",
        "peripheralmap": "GIC CPU Interface (GICC)"
      },
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0021000 - 0xA0021FFF",
        "size": "4KB",
        "peripheral": "GICD",
        "peripheralmap": "GIC distributor (GICD)"
      },
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0000000 - 0xA0020FFF",
        "size": "132KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C00A400 - 0x5FFFFFFF",
        "size": "65495KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C00A000 - 0x5C00A3FF",
        "size": "1KB",
        "peripheral": "TAMP",
        "peripheralmap": "TAMP registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C009400 - 0x5C009FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C009000 - 0x5C0093FF",
        "size": "1KB",
        "peripheral": "I2C6",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C008000 - 0x5C008FFF",
        "size": "4KB",
        "peripheral": "STGENC",
        "peripheralmap": "STGEN registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C007400 - 0x5C007FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C007000 - 0x5C0073FF",
        "size": "1KB",
        "peripheral": "ETZPC",
        "peripheralmap": "ETZPC registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C006000 - 0x5C006FFF",
        "size": "4KB",
        "peripheral": "TZC",
        "peripheralmap": "TZC registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C005000 - 0x5C005FFF",
        "size": "4KB",
        "peripheral": "BSEC",
        "peripheralmap": "BSEC registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C004400 - 0x5C004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C004000 - 0x5C0043FF",
        "size": "1KB",
        "peripheral": "RTC",
        "peripheralmap": "RTC registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C003400 - 0x5C003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C003000 - 0x5C0033FF",
        "size": "1KB",
        "peripheral": "IWDG1",
        "peripheralmap": "IWDG registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C002400 - 0x5C002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C002000 - 0x5C0023FF",
        "size": "1KB",
        "peripheral": "I2C4",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C001400 - 0x5C001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C001000 - 0x5C0013FF",
        "size": "1KB",
        "peripheral": "SPI6",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C000400 - 0x5C000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C000000 - 0x5C0003FF",
        "size": "1KB",
        "peripheral": "USART1",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A007400 - 0x5BFFFFFF",
        "size": "32739KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB4",
        "range": "0x5A007000 - 0x5A0073FF",
        "size": "1KB",
        "peripheral": "DDRPERFM",
        "peripheralmap": "DDRPERFM registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A006000 - 0x5A006FFF",
        "size": "4KB",
        "peripheral": "USBPHYC",
        "peripheralmap": "USBPHYC registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A005000 - 0x5A005FFF",
        "size": "4KB",
        "peripheral": "STGENR",
        "peripheralmap": "STGEN registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A004000 - 0x5A004FFF",
        "size": "4KB",
        "peripheral": "DDRPHYC",
        "peripheralmap": "PUBL registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A003000 - 0x5A003FFF",
        "size": "4KB",
        "peripheral": "DDRCTRL",
        "peripheralmap": "DDRCTRL registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A002400 - 0x5A002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB4",
        "range": "0x5A002000 - 0x5A0023FF",
        "size": "1KB",
        "peripheral": "IWDG2",
        "peripheralmap": "IWDG registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A001400 - 0x5A001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB4",
        "range": "0x5A001000 - 0x5A0013FF",
        "size": "1KB",
        "peripheral": "LTDC",
        "peripheralmap": "LTDC registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A000800 - 0x5A000FFF",
        "size": "2KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB4",
        "range": "0x5A000000 - 0x5A0007FF",
        "size": "2KB",
        "peripheral": "DSI",
        "peripheralmap": "DSI Host registers"
      },
      {
        "bus": "AHB6",
        "range": "0x59040000 - 0x59FFFFFF",
        "size": "16128KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB6",
        "range": "0x59000000 - 0x5903FFFF",
        "size": "256KB",
        "peripheral": "GPU",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB6",
        "range": "0x5800E000 - 0x58FFFFFF",
        "size": "16328KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB6",
        "range": "0x5800D000 - 0x5800DFFF",
        "size": "4KB",
        "peripheral": "USBH_EHCI",
        "peripheralmap": "USBH registers"
      },
      {
        "bus": "AHB6",
        "range": "0x5800C000 - 0x5800CFFF",
        "size": "4KB",
        "peripheral": "USBH_OHCI",
        "peripheralmap": "USBH registers"
      },
      {
        "bus": "AHB6",
        "range": "0x5800A000 - 0x5800BFFF",
        "size": "8KB",
        "peripheral": "ETH1",
        "peripheralmap": "Ethernet registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58009000 - 0x58009FFF",
        "size": "4KB",
        "peripheral": "CRC1",
        "peripheralmap": "CRC registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58008000 - 0x58008FFF",
        "size": "4KB",
        "peripheral": "DLYBSD2",
        "peripheralmap": "DLYB registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58007000 - 0x58007FFF",
        "size": "4KB",
        "peripheral": "SDMMC2",
        "peripheralmap": "SDMMC registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58006000 - 0x58006FFF",
        "size": "4KB",
        "peripheral": "DLYBSD1",
        "peripheralmap": "DLYB registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58005000 - 0x58005FFF",
        "size": "4KB",
        "peripheral": "SDMMC1",
        "peripheralmap": "SDMMC registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58004000 - 0x58004FFF",
        "size": "4KB",
        "peripheral": "DLYBQS",
        "peripheralmap": "DLYB registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58003000 - 0x58003FFF",
        "size": "4KB",
        "peripheral": "QUADSPI",
        "peripheralmap": "QUADSPI registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58002000 - 0x58002FFF",
        "size": "4KB",
        "peripheral": "FMC",
        "peripheralmap": "NOR/PSRAM controller registersNAND flash controller registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58001000 - 0x58001FFF",
        "size": "4KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB6",
        "range": "0x58000000 - 0x58000FFF",
        "size": "4KB",
        "peripheral": "MDMA",
        "peripheralmap": "MDMA registers"
      },
      {
        "bus": "AXIM",
        "range": "0x57100000 - 0x57FFFFFF",
        "size": "15360KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AXIM",
        "range": "0x57000000 - 0x570FFFFF",
        "size": "1024KB",
        "peripheral": "AXIMC",
        "peripheralmap": "AXIMC registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54004400 - 0x56FFFFFF",
        "size": "49135KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB5",
        "range": "0x54004000 - 0x540043FF",
        "size": "1KB",
        "peripheral": "GPIOZ",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54003400 - 0x54003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB5",
        "range": "0x54003000 - 0x540033FF",
        "size": "1KB",
        "peripheral": "RNG1",
        "peripheralmap": "RNG registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54002400 - 0x54002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB5",
        "range": "0x54002000 - 0x540023FF",
        "size": "1KB",
        "peripheral": "HASH1",
        "peripheralmap": "HASH registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54001400 - 0x54001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB5",
        "range": "0x54001000 - 0x540013FF",
        "size": "1KB",
        "peripheral": "CRYP1(1)",
        "peripheralmap": "CRYP registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54000000 - 0x54000FFF",
        "size": "4KB",
        "peripheral": "BKPSRAM",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x5002A400 - 0x5007FFFF",
        "size": "343KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x5002A000 - 0x5002A3FF",
        "size": "1KB",
        "peripheral": "HDP",
        "peripheralmap": "HDP registers"
      },
      {
        "bus": "APB3",
        "range": "0x50028400 - 0x50029FFF",
        "size": "7KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50028000 - 0x500283FF",
        "size": "1KB",
        "peripheral": "DTS",
        "peripheralmap": "DTS registers"
      },
      {
        "bus": "APB3",
        "range": "0x50027400 - 0x50027FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50027000 - 0x500273FF",
        "size": "1KB",
        "peripheral": "SAI4",
        "peripheralmap": "SAI registers"
      },
      {
        "bus": "APB3",
        "range": "0x50025400 - 0x50026FFF",
        "size": "7KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50025000 - 0x500253FF",
        "size": "1KB",
        "peripheral": "VREFBUF",
        "peripheralmap": "VREFBUF registers"
      },
      {
        "bus": "APB3",
        "range": "0x50024400 - 0x50024FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50024000 - 0x500243FF",
        "size": "1KB",
        "peripheral": "LPTIM5",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB3",
        "range": "0x50023400 - 0x50023FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50023000 - 0x500233FF",
        "size": "1KB",
        "peripheral": "LPTIM4",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB3",
        "range": "0x50022400 - 0x50022FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50022000 - 0x500223FF",
        "size": "1KB",
        "peripheral": "LPTIM3",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB3",
        "range": "0x50021400 - 0x50021FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50021000 - 0x500213FF",
        "size": "1KB",
        "peripheral": "LPTIM2",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB3",
        "range": "0x50020400 - 0x50020FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50020000 - 0x500203FF",
        "size": "1KB",
        "peripheral": "SYSCFG",
        "peripheralmap": "SYSCFG registers"
      },
      {
        "bus": "AHB4",
        "range": "0x5000D400 - 0x5001FFFF",
        "size": "75KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x5000D000 - 0x5000D3FF",
        "size": "1KB",
        "peripheral": "EXTI",
        "peripheralmap": "EXTI registers"
      },
      {
        "bus": "AHB4",
        "range": "0x5000C400 - 0x5000CFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x5000C000 - 0x5000C3FF",
        "size": "1KB",
        "peripheral": "GPIOK",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x5000B400 - 0x5000BFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x5000B000 - 0x5000B3FF",
        "size": "1KB",
        "peripheral": "GPIOJ",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x5000A400 - 0x5000AFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x5000A000 - 0x5000A3FF",
        "size": "1KB",
        "peripheral": "GPIOI",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50009400 - 0x50009FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50009000 - 0x500093FF",
        "size": "1KB",
        "peripheral": "GPIOH",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50008400 - 0x50008FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50008000 - 0x500083FF",
        "size": "1KB",
        "peripheral": "GPIOG",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50007400 - 0x50007FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50007000 - 0x500073FF",
        "size": "1KB",
        "peripheral": "GPIOF",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50006400 - 0x50006FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50006000 - 0x500063FF",
        "size": "1KB",
        "peripheral": "GPIOE",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50005400 - 0x50005FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50005000 - 0x500053FF",
        "size": "1KB",
        "peripheral": "GPIOD",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50004400 - 0x50004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50004000 - 0x500043FF",
        "size": "1KB",
        "peripheral": "GPIOC",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50003400 - 0x50003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50003000 - 0x500033FF",
        "size": "1KB",
        "peripheral": "GPIOB",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50002400 - 0x50002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50002000 - 0x500023FF",
        "size": "1KB",
        "peripheral": "GPIOA",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50001400 - 0x50001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50001000 - 0x500013FF",
        "size": "1KB",
        "peripheral": "PWR",
        "peripheralmap": "PWR registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50000000 - 0x50000FFF",
        "size": "4KB",
        "peripheral": "RCC",
        "peripheralmap": "RCC registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C006400 - 0x4FFFFFFF",
        "size": "65511KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C006000 - 0x4C0063FF",
        "size": "1KB",
        "peripheral": "DCMI",
        "peripheralmap": "DCMI registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C005400 - 0x4C005FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C005000 - 0x4C0053FF",
        "size": "1KB",
        "peripheral": "CRYP2(1)",
        "peripheralmap": "CRYP registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C004400 - 0x4C004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C004000 - 0x4C0043FF",
        "size": "1KB",
        "peripheral": "CRC2",
        "peripheralmap": "CRC registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C003400 - 0x4C003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C003000 - 0x4C0033FF",
        "size": "1KB",
        "peripheral": "RNG2",
        "peripheralmap": "RNG registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C002400 - 0x4C002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C002000 - 0x4C0023FF",
        "size": "1KB",
        "peripheral": "HASH2",
        "peripheralmap": "HASH registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C001400 - 0x4C001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C001000 - 0x4C0013FF",
        "size": "1KB",
        "peripheral": "IPCC",
        "peripheralmap": "IPCC registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C000400 - 0x4C000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C000000 - 0x4C0003FF",
        "size": "1KB",
        "peripheral": "HSEM",
        "peripheralmap": "HSEM registers"
      },
      {
        "bus": "AHB2",
        "range": "0x49040000 - 0x4BFFFFFF",
        "size": "48896KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x49000000 - 0x4903FFFF",
        "size": "256KB",
        "peripheral": "OTG",
        "peripheralmap": "OTG registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48005400 - 0x48FFFFFF",
        "size": "16363KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48005000 - 0x480053FF",
        "size": "1KB",
        "peripheral": "DLYBSD3",
        "peripheralmap": "DLYB registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48004400 - 0x48004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48004000 - 0x480043FF",
        "size": "1KB",
        "peripheral": "SDMMC3",
        "peripheralmap": "SDMMC registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48003400 - 0x48003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48003000 - 0x480033FF",
        "size": "1KB",
        "peripheral": "ADC12",
        "peripheralmap": "ADC registers (for each ADC)"
      },
      {
        "bus": "AHB2",
        "range": "0x48002400 - 0x48002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48002000 - 0x480023FF",
        "size": "1KB",
        "peripheral": "DMAMUX1",
        "peripheralmap": "DMAMUX registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48001400 - 0x48001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48001000 - 0x480013FF",
        "size": "1KB",
        "peripheral": "DMA2",
        "peripheralmap": "DMA registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48000400 - 0x48000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48000000 - 0x480003FF",
        "size": "1KB",
        "peripheral": "DMA1",
        "peripheralmap": "DMA registers"
      },
      {
        "bus": "APB2",
        "range": "0x44013800 - 0x47FFFFFF",
        "size": "65458KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44011000 - 0x440137FF",
        "size": "10KB",
        "peripheral": "CANSRAM",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44010400 - 0x44010FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44010000 - 0x440103FF",
        "size": "1KB",
        "peripheral": "CCU",
        "peripheralmap": "CCU registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400F400 - 0x4400FFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400F000 - 0x4400F3FF",
        "size": "1KB",
        "peripheral": "FDCAN2",
        "peripheralmap": "FDCAN registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400E400 - 0x4400EFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400E000 - 0x4400E3FF",
        "size": "1KB",
        "peripheral": "FDCAN1",
        "peripheralmap": "FDCAN registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400D800 - 0x4400DFFF",
        "size": "2KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400D000 - 0x4400D7FF",
        "size": "2KB",
        "peripheral": "DFSDM1",
        "peripheralmap": "DFSDM channel y registers (y=0..7)DFSDM filter x module registers (x=0..5)"
      },
      {
        "bus": "APB2",
        "range": "0x4400C400 - 0x4400CFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400C000 - 0x4400C3FF",
        "size": "1KB",
        "peripheral": "SAI3",
        "peripheralmap": "SAI registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400B400 - 0x4400BFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400B000 - 0x4400B3FF",
        "size": "1KB",
        "peripheral": "SAI2",
        "peripheralmap": "SAI registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400A400 - 0x4400AFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400A000 - 0x4400A3FF",
        "size": "1KB",
        "peripheral": "SAI1",
        "peripheralmap": "SAI registers"
      },
      {
        "bus": "APB2",
        "range": "0x44009400 - 0x44009FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44009000 - 0x440093FF",
        "size": "1KB",
        "peripheral": "SPI5",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB2",
        "range": "0x44008400 - 0x44008FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44008000 - 0x440083FF",
        "size": "1KB",
        "peripheral": "TIM17",
        "peripheralmap": "TIM16/TIM17 registers"
      },
      {
        "bus": "APB2",
        "range": "0x44007400 - 0x44007FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44007000 - 0x440073FF",
        "size": "1KB",
        "peripheral": "TIM16",
        "peripheralmap": "TIM16/TIM17 registers"
      },
      {
        "bus": "APB2",
        "range": "0x44006400 - 0x44006FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44006000 - 0x440063FF",
        "size": "1KB",
        "peripheral": "TIM15",
        "peripheralmap": "TIM15 registers"
      },
      {
        "bus": "APB2",
        "range": "0x44005400 - 0x44005FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44005000 - 0x440053FF",
        "size": "1KB",
        "peripheral": "SPI4",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB2",
        "range": "0x44004400 - 0x44004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44004000 - 0x440043FF",
        "size": "1KB",
        "peripheral": "SPI1",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB2",
        "range": "0x44003400 - 0x44003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44003000 - 0x440033FF",
        "size": "1KB",
        "peripheral": "USART6",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB2",
        "range": "0x44001400 - 0x44002FFF",
        "size": "7KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44001000 - 0x440013FF",
        "size": "1KB",
        "peripheral": "TIM 8",
        "peripheralmap": "TIM1/TIM8 registers"
      },
      {
        "bus": "APB2",
        "range": "0x44000400 - 0x44000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44000000 - 0x440003FF",
        "size": "1KB",
        "peripheral": "TIM 1",
        "peripheralmap": "TIM1/TIM8 registers"
      },
      {
        "bus": "APB1",
        "range": "0x4001C400 - 0x43FFFFFF",
        "size": "65423KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4001C000 - 0x4001C3FF",
        "size": "1KB",
        "peripheral": "MDIOS",
        "peripheralmap": "MDIOS registers"
      },
      {
        "bus": "APB1",
        "range": "0x40019400 - 0x4001BFFF",
        "size": "11KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40019000 - 0x400193FF",
        "size": "1KB",
        "peripheral": "UART8",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x40018400 - 0x40018FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40018000 - 0x400183FF",
        "size": "1KB",
        "peripheral": "UART7",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x40017400 - 0x40017FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40017000 - 0x400173FF",
        "size": "1KB",
        "peripheral": "DAC1",
        "peripheralmap": "DAC registers"
      },
      {
        "bus": "APB1",
        "range": "0x40016400 - 0x40016FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40016000 - 0x400163FF",
        "size": "1KB",
        "peripheral": "CEC",
        "peripheralmap": "HDMI-CEC registers"
      },
      {
        "bus": "APB1",
        "range": "0x40015400 - 0x40015FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40015000 - 0x400153FF",
        "size": "1KB",
        "peripheral": "I2C5",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB1",
        "range": "0x40014400 - 0x40014FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40014000 - 0x400143FF",
        "size": "1KB",
        "peripheral": "I2C3",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB1",
        "range": "0x40013400 - 0x40013FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40013000 - 0x400133FF",
        "size": "1KB",
        "peripheral": "I2C2",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB1",
        "range": "0x40012400 - 0x40012FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40012000 - 0x400123FF",
        "size": "1KB",
        "peripheral": "I2C1",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB1",
        "range": "0x40011400 - 0x40011FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40011000 - 0x400113FF",
        "size": "1KB",
        "peripheral": "UART5",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x40010400 - 0x40010FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40010000 - 0x400103FF",
        "size": "1KB",
        "peripheral": "UART4",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000F400 - 0x4000FFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000F000 - 0x4000F3FF",
        "size": "1KB",
        "peripheral": "USART3",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000E400 - 0x4000EFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000E000 - 0x4000E3FF",
        "size": "1KB",
        "peripheral": "USART2",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000D400 - 0x4000DFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000D000 - 0x4000D3FF",
        "size": "1KB",
        "peripheral": "SPDIFRX",
        "peripheralmap": "SPDIFRX interface registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000C400 - 0x4000CFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000C000 - 0x4000C3FF",
        "size": "1KB",
        "peripheral": "SPI3",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000B400 - 0x4000BFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000B000 - 0x4000B3FF",
        "size": "1KB",
        "peripheral": "SPI2",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000A400 - 0x4000AFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000A000 - 0x4000A3FF",
        "size": "1KB",
        "peripheral": "WWDG1",
        "peripheralmap": "WWDG registers"
      },
      {
        "bus": "APB1",
        "range": "0x40009400 - 0x40009FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40009000 - 0x400093FF",
        "size": "1KB",
        "peripheral": "LPTIM1",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB1",
        "range": "0x40008400 - 0x40008FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40008000 - 0x400083FF",
        "size": "1KB",
        "peripheral": "TIM14",
        "peripheralmap": "TIM13/TIM14 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40007400 - 0x40007FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40007000 - 0x400073FF",
        "size": "1KB",
        "peripheral": "TIM13",
        "peripheralmap": "TIM13/TIM14 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40006400 - 0x40006FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40006000 - 0x400063FF",
        "size": "1KB",
        "peripheral": "TIM12",
        "peripheralmap": "TIM12 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40005400 - 0x40005FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40005000 - 0x400053FF",
        "size": "1KB",
        "peripheral": "TIM7",
        "peripheralmap": "TIM6/TIM7 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40004400 - 0x40004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40004000 - 0x400043FF",
        "size": "1KB",
        "peripheral": "TIM6",
        "peripheralmap": "TIM6/TIM7 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40003400 - 0x40003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40003000 - 0x400033FF",
        "size": "1KB",
        "peripheral": "TIM5",
        "peripheralmap": "TIM2/TIM3/TIM4/TIM5 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40002400 - 0x40002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40002000 - 0x400023FF",
        "size": "1KB",
        "peripheral": "TIM4",
        "peripheralmap": "TIM2/TIM3/TIM4/TIM5 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40001400 - 0x40001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40001000 - 0x400013FF",
        "size": "1KB",
        "peripheral": "TIM3",
        "peripheralmap": "TIM2/TIM3/TIM4/TIM5 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40000400 - 0x40000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40000000 - 0x400003FF",
        "size": "1KB",
        "peripheral": "TIM2",
        "peripheralmap": "TIM2/TIM3/TIM4/TIM5 registers"
      }
    ]
  },
  {
    "registermaps": [
      {
        "mapname": "I2C registers",
        "registers": [
          {
            "registername": "I2C_CR1",
            "offset": "0x00",
            "page": 2559,
            "chapter": "52.9.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23",
                "field": "PECEN",
                "description": "PEC enable\n0: PEC calculation disabled\n1: PEC calculation enabled\n"
              },
              {
                "range": "22",
                "field": "ALERTEN",
                "description": "SMBus alert enable\n0: The SMBALERT# signal on SMBA pin is not supported in host mode (SMBHEN = 1). In\ndevice mode (SMBHEN = 0), the SMBA pin is released and the alert response address\nheader is disabled (0001100x followed by NACK).\n1: The SMBALERT# signal on SMBA pin is supported in host mode (SMBHEN = 1). In\ndevice mode (SMBHEN = 0), the SMBA pin is driven low and the alert response address\nheader is enabled (0001100x followed by ACK).\nNote: When ALERTEN = 0, the SMBA pin can be used as a standard GPIO.\n"
              },
              {
                "range": "21",
                "field": "SMBDEN",
                "description": "SMBus device default address enable\n0: Device default address disabled. Address 0b1100001x is NACKed.\n1: Device default address enabled. Address 0b1100001x is ACKed.\n"
              },
              {
                "range": "20",
                "field": "SMBHEN",
                "description": "SMBus host address enable\n0: Host address disabled. Address 0b0001000x is NACKed.\n1: Host address enabled. Address 0b0001000x is ACKed.\n"
              },
              {
                "range": "19",
                "field": "GCEN",
                "description": "General call enable\n0: General call disabled. Address 0b00000000 is NACKed.\n1: General call enabled. Address 0b00000000 is ACKed.\n"
              },
              {
                "range": "18",
                "field": "WUPEN",
                "description": "Wake-up from Stop mode enable\n0: Wake-up from Stop mode disabled.\n1: Wake-up from Stop mode enabled.\nNote: WUPEN can be set only when DNF[3:0] = 0000.\nRM0436 Rev 7 2559/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              },
              {
                "range": "17",
                "field": "NOSTRETCH",
                "description": "Clock stretching disable\nThis bit is used to disable clock stretching in target mode. It must be kept cleared in\ncontroller mode.\n0: Clock stretching enabled\n1: Clock stretching disabled\nNote: This bit can be programmed only when the I2C peripheral is disabled (PE = 0).\n"
              },
              {
                "range": "16",
                "field": "SBC",
                "description": "Target byte control\nThis bit is used to enable hardware byte control in target mode.\n0: Target byte control disabled\n1: Target byte control enabled\n"
              },
              {
                "range": "15",
                "field": "RXDMAEN",
                "description": "DMA reception requests enable\n0: DMA mode disabled for reception\n1: DMA mode enabled for reception\n"
              },
              {
                "range": "14",
                "field": "TXDMAEN",
                "description": "DMA transmission requests enable\n0: DMA mode disabled for transmission\n1: DMA mode enabled for transmission\n"
              },
              {
                "range": "13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "ANFOFF",
                "description": "Analog noise filter OFF\n0: Analog noise filter enabled\n1: Analog noise filter disabled\nNote: This bit can be programmed only when the I2C peripheral is disabled (PE = 0).\n"
              },
              {
                "range": "11:8",
                "field": "DNF[3:0]",
                "description": "Digital noise filter\nThese bits are used to configure the digital noise filter on SDA and SCL input. The digital\nfilter, filters spikes with a length of up to DNF[3:0] * t\nI2CCLK\n0000: Digital filter disabled\n0001: Digital filter enabled and filtering capability up to one t\nI2CCLK\n...\n1111: digital filter enabled and filtering capability up to fifteen t\nI2CCLK\nNote: If the analog filter is enabled, the digital filter is added to it. This filter can be\nprogrammed only when the I2C peripheral is disabled (PE = 0).\n"
              },
              {
                "range": "7",
                "field": "ERRIE",
                "description": "Error interrupts enable\n0: Error detection interrupts disabled\n1: Error detection interrupts enabled\nNote: Any of these errors generates an interrupt:\n- arbitration loss (ARLO)\n- bus error detection (BERR)\n- overrun/underrun (OVR)\n- timeout detection (TIMEOUT)\n- PEC error detection (PECERR)\n- alert pin event detection (ALERT)\n"
              },
              {
                "range": "6",
                "field": "TCIE",
                "description": "Transfer complete interrupt enable\n0: Transfer complete interrupt disabled\n1: Transfer complete interrupt enabled\nNote: Any of these events generates an interrupt:\nTransfer complete (TC)\nTransfer complete reload (TCR)\n2560/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              },
              {
                "range": "5",
                "field": "STOPIE",
                "description": "STOP detection interrupt enable\n0: STOP detection (STOPF) interrupt disabled\n1: STOP detection (STOPF) interrupt enabled\n"
              },
              {
                "range": "4",
                "field": "NACKIE",
                "description": "Not acknowledge received interrupt enable\n0: Not acknowledge (NACKF) received interrupts disabled\n1: Not acknowledge (NACKF) received interrupts enabled\n"
              },
              {
                "range": "3",
                "field": "ADDRIE",
                "description": "Address match interrupt enable (target only)\n0: Address match (ADDR) interrupts disabled\n1: Address match (ADDR) interrupts enabled\n"
              },
              {
                "range": "2",
                "field": "RXIE",
                "description": "RX interrupt enable\n0: Receive (RXNE) interrupt disabled\n1: Receive (RXNE) interrupt enabled\n"
              },
              {
                "range": "1",
                "field": "TXIE",
                "description": "TX interrupt enable\n0: Transmit (TXIS) interrupt disabled\n1: Transmit (TXIS) interrupt enabled\n"
              },
              {
                "range": "0",
                "field": "PE",
                "description": "Peripheral enable\n0: Peripheral disabled\n1: Peripheral enabled\nNote: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and\nstatus bits are put back to their reset value. When cleared, PE must be kept low for at\nleast three APB clock cycles.\n"
              }
            ]
          },
          {
            "registername": "I2C_CR2",
            "offset": "0x04",
            "page": 2561,
            "chapter": "52.9.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26",
                "field": "PECBYTE",
                "description": "Packet error checking byte\nThis bit is set by software, and cleared by hardware when the PEC is transferred, or when a\nSTOP condition or an Address matched is received, also when PE = 0.\n0: No PEC transfer\n1: PEC transmission/reception is requested\nNote: Writing 0 to this bit has no effect.\nThis bit has no effect when RELOAD is set, and in target mode when SBC = 0.\nRM0436 Rev 7 2561/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              },
              {
                "range": "25",
                "field": "AUTOEND",
                "description": "Automatic end mode (controller mode)\nThis bit is set and cleared by software.\n0: software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.\n1: Automatic end mode: a STOP condition is automatically sent when NBYTES data are\ntransferred.\nNote: This bit has no effect in target mode or when the RELOAD bit is set.\n"
              },
              {
                "range": "24",
                "field": "RELOAD",
                "description": "NBYTES reload mode\nThis bit is set and cleared by software.\n0: The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).\n1: The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR\nflag is set when NBYTES data are transferred, stretching SCL low.\n"
              },
              {
                "range": "23:16",
                "field": "NBYTES[7:0]",
                "description": "Number of bytes\nThe number of bytes to be transmitted/received is programmed there. This field is donâ€™t care\nin target mode with SBC = 0.\nNote: Changing these bits when the START bit is set is not allowed.\n"
              },
              {
                "range": "15",
                "field": "NACK",
                "description": "NACK generation (target mode)\nThe bit is set by software, cleared by hardware when the NACK is sent, or when a STOP\ncondition or an Address matched is received, or when PE = 0.\n0: an ACK is sent after current received byte.\n1: a NACK is sent after current received byte.\nNote: Writing 0 to this bit has no effect.\nThis bit is used only in target mode: in controller receiver mode, NACK is automatically\ngenerated after last byte preceding STOP or RESTART condition, whatever the NACK\nbit value.\nWhen an overrun occurs in target receiver NOSTRETCH mode, a NACK is\nautomatically generated, whatever the NACK bit value.\nWhen hardware PEC checking is enabled (PECBYTE = 1), the PEC acknowledge value\ndoes not depend on the NACK value.\n"
              },
              {
                "range": "14",
                "field": "STOP",
                "description": "STOP condition generation\nThis bit only pertains to controller mode. It is set by software and cleared by hardware when\na STOP condition is detected or when PE = 0.\n0: No STOP generation\n1: STOP generation after current byte transfer\nNote: Writing 0 to this bit has no effect.\n"
              },
              {
                "range": "13",
                "field": "START",
                "description": "START condition generation\nThis bit is set by software. It is cleared by hardware after the START condition followed by\nthe address sequence is sent, by an arbitration loss, by a timeout error detection, or when\nPE = 0. It can also be cleared by software, by setting the ADDRCF bit of the I2C_ICR\nregister.\n0: No START generation\n1: RESTART/START generation:\nIf the I2C is already in controller mode with AUTOEND = 0, setting this bit generates a\nrepeated START condition when RELOAD = 0, after the end of the NBYTES transfer.\nOtherwise, setting this bit generates a START condition once the bus is free.\nNote: Writing 0 to this bit has no effect.\nThe START bit can be set even if the bus is BUSY or I2C is in target mode.\nThis bit has no effect when RELOAD is set.\n2562/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              },
              {
                "range": "12",
                "field": "HEAD10R",
                "description": "10-bit address header only read direction (controller receiver mode)\n0: The controller sends the complete 10-bit target address read sequence: START + 2 bytes\n10-bit address in write direction + RESTART + first seven bits of the 10-bit address in read\ndirection.\n1: The controller sends only the first seven bits of the 10-bit address, followed by read\ndirection.\nNote: Changing this bit when the START bit is set is not allowed.\n"
              },
              {
                "range": "11",
                "field": "ADD10",
                "description": "10-bit addressing mode (controller mode)\n0: The controller operates in 7-bit addressing mode\n1: The controller operates in 10-bit addressing mode\nNote: Changing this bit when the START bit is set is not allowed.\n"
              },
              {
                "range": "10",
                "field": "RD_WRN",
                "description": "Transfer direction (controller mode)\n0: Controller requests a write transfer\n1: Controller requests a read transfer\nNote: Changing this bit when the START bit is set is not allowed.\n"
              },
              {
                "range": "9:0",
                "field": "SADD[9:0]",
                "description": "Target address (controller mode)\nCondition: In 7-bit addressing mode (ADD10 = 0):\nSADD[7:1] must be written with the 7-bit target address to be sent. Bits SADD[9], SADD[8]\nand SADD[0] are don't care.\nCondition: In 10-bit addressing mode (ADD10 = 1):\nSADD[9:0] must be written with the 10-bit target address to be sent.\nNote: Changing these bits when the START bit is set is not allowed.\n"
              }
            ]
          },
          {
            "registername": "I2C_OAR1",
            "offset": "0x08",
            "page": 2563,
            "chapter": "52.9.3",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "OA1EN",
                "description": "Own address 1 enable\n0: Own address 1 disabled. The received target address OA1 is NACKed.\n1: Own address 1 enabled. The received target address OA1 is ACKed.\n"
              },
              {
                "range": "14:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2563/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              },
              {
                "range": "10",
                "field": "OA1MODE",
                "description": "Own address 1 10-bit mode\n0: Own address 1 is a 7-bit address.\n1: Own address 1 is a 10-bit address.\nNote: This bit can be written only when OA1EN = 0.\n"
              },
              {
                "range": "9:0",
                "field": "OA1[9:0]",
                "description": "Interface own target address\n7-bit addressing mode: OA1[7:1] contains the 7-bit own target address. Bits OA1[9], OA1[8]\nand OA1[0] are don't care.\n10-bit addressing mode: OA1[9:0] contains the 10-bit own target address.\nNote: These bits can be written only when OA1EN = 0.\n"
              }
            ]
          },
          {
            "registername": "I2C_OAR2",
            "offset": "0x0C",
            "page": 2564,
            "chapter": "52.9.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "OA2EN",
                "description": "Own address 2 enable\n0: Own address 2 disabled. The received target address OA2 is NACKed.\n1: Own address 2 enabled. The received target address OA2 is ACKed.\n"
              },
              {
                "range": "14:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:8",
                "field": "OA2MSK[2:0]",
                "description": "Own address 2 masks\n000: No mask\n001: OA2[1] is masked and donâ€™t care. Only OA2[7:2] are compared.\n010: OA2[2:1] are masked and donâ€™t care. Only OA2[7:3] are compared.\n011: OA2[3:1] are masked and donâ€™t care. Only OA2[7:4] are compared.\n100: OA2[4:1] are masked and donâ€™t care. Only OA2[7:5] are compared.\n101: OA2[5:1] are masked and donâ€™t care. Only OA2[7:6] are compared.\n110: OA2[6:1] are masked and donâ€™t care. Only OA2[7] is compared.\n111: OA2[7:1] are masked and donâ€™t care. No comparison is done, and all (except reserved)\n7-bit received addresses are acknowledged.\nNote: These bits can be written only when OA2EN = 0.\nAs soon as OA2MSK â‰  0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are\nnot acknowledged, even if the comparison matches.\n"
              },
              {
                "range": "7:1",
                "field": "OA2[7:1]",
                "description": "Interface address\n7-bit addressing mode: 7-bit address\nNote: These bits can be written only when OA2EN = 0.\n2564/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              },
              {
                "range": "0",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              }
            ]
          },
          {
            "registername": "I2C_TIMINGR",
            "offset": "0x10",
            "page": 2565,
            "chapter": "52.9.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:28",
                "field": "PRESC[3:0]",
                "description": "Timing prescaler\nThis field is used to prescale i2c_ker_ck to generate the clock period t used for data\nPRESC\nsetup and hold counters (refer to section I2C timings), and for SCL high and low level\ncounters (refer to section I2C controller initialization).\nt = (PRESC + 1) x t\nPRESC I2CCLK\n"
              },
              {
                "range": "27:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:20",
                "field": "SCLDEL[3:0]",
                "description": "Data setup time\nThis field is used to generate a delay t = (SCLDEL + 1) x t between SDA edge\nSCLDEL PRESC\nand SCL rising edge. In controller and in target modes with NOSTRETCH = 0, the SCL line is\nstretched low during t .\nSCLDEL\nNote: t is used to generate t timing.\nSCLDEL SU:DAT\n"
              },
              {
                "range": "19:16",
                "field": "SDADEL[3:0]",
                "description": "Data hold time\nThis field is used to generate the delay t between SCL falling edge and SDA edge. In\nSDADEL\ncontroller and in target modes with NOSTRETCH = 0, the SCL line is stretched low during\nt .\nSDADEL\nt = SDADEL x t\nSDADEL PRESC\nNote: SDADEL is used to generate t timing.\nHD:DAT\n"
              },
              {
                "range": "15:8",
                "field": "SCLH[7:0]",
                "description": "SCL high period (controller mode)\nThis field is used to generate the SCL high period in controller mode.\nt = (SCLH + 1) x t\nSCLH PRESC\nNote: SCLH is also used to generate t and t timing.\nSU:STO HD:STA\n"
              },
              {
                "range": "7:0",
                "field": "SCLL[7:0]",
                "description": "SCL low period (controller mode)\nThis field is used to generate the SCL low period in controller mode.\nt = (SCLL + 1) x t\nSCLL PRESC\nNote: SCLL is also used to generate t and t timings.\nBUF SU:STA\nNote: This register must be configured when the I2C peripheral is disabled (PE = 0).\nNote: The STM32CubeMX tool calculates and provides the I2C_TIMINGR content in the I2C\nConfiguration window.\nRM0436 Rev 7 2565/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              }
            ]
          },
          {
            "registername": "I2C_TIMEOUTR",
            "offset": "0x14",
            "page": 2566,
            "chapter": "52.9.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "TEXTEN",
                "description": "Extended clock timeout enable\n0: Extended clock timeout detection is disabled\n1: Extended clock timeout detection is enabled. When a cumulative SCL stretch for more\nthan t is done by the I2C interface, a timeout error is detected (TIMEOUT = 1).\nLOW:EXT\n"
              },
              {
                "range": "30:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27:16",
                "field": "TIMEOUTB[11:0]",
                "description": "Bus timeout B\nThis field is used to configure the cumulative clock extension timeout:\nâ€“ Controller mode: the controller cumulative clock low extend time (t ) is\nLOW:MEXT\ndetected\nâ€“ Target mode: the target cumulative clock low extend time (t ) is detected\nLOW:SEXT\nt = (TIMEOUTB + TIDLE = 01) x 2048 x t\nLOW:EXT I2CCLK\nNote: These bits can be written only when TEXTEN = 0.\n"
              },
              {
                "range": "15",
                "field": "TIMOUTEN",
                "description": "Clock timeout enable\n0: SCL timeout detection is disabled\n1: SCL timeout detection is enabled. When SCL is low for more than t (TIDLE = 0) or\nTIMEOUT\nhigh for more than t (TIDLE = 1), a timeout error is detected (TIMEOUT = 1).\nIDLE\n"
              },
              {
                "range": "14:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "TIDLE",
                "description": "Idle clock timeout detection\n0: TIMEOUTA is used to detect SCL low timeout\n1: TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)\nNote: This bit can be written only when TIMOUTEN = 0.\n"
              },
              {
                "range": "11:0",
                "field": "TIMEOUTA[11:0]",
                "description": "Bus timeout A\nThis field is used to configure:\nThe SCL low timeout condition t when TIDLE = 0\nTIMEOUT\nt = (TIMEOUTA + 1) x 2048 x t\nTIMEOUT I2CCLK\nThe bus idle condition (both SCL and SDA high) when TIDLE = 1\nt = (TIMEOUTA + 1) x 4 x t\nIDLE I2CCLK\nNote: These bits can be written only when TIMOUTEN = 0.\n2566/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              }
            ]
          },
          {
            "registername": "I2C_ISR",
            "offset": "0x18",
            "page": 2567,
            "chapter": "52.9.7",
            "resetvalue": "0x00000001",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:17",
                "field": "ADDCODE[6:0]",
                "description": "Address match code (target mode)\nThese bits are updated with the received address when an address match event occurs\n(ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed\nby the two MSBs of the address.\n"
              },
              {
                "range": "16",
                "field": "DIR",
                "description": "Transfer direction (target mode)\nThis flag is updated when an address match event occurs (ADDR = 1).\n0: Write transfer, target enters receiver mode.\n1: Read transfer, target enters transmitter mode.\n"
              },
              {
                "range": "15",
                "field": "BUSY",
                "description": "Bus busy\nThis flag indicates that a communication is in progress on the bus. It is set by hardware\nwhen a START condition is detected, and cleared by hardware when a STOP condition is\ndetected, or when PE = 0.\n"
              },
              {
                "range": "14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13",
                "field": "ALERT",
                "description": "SMBus alert\nThis flag is set by hardware when SMBHEN = 1 (SMBus host configuration), ALERTEN = 1\nand an SMBALERT# event (falling edge) is detected on SMBA pin. It is cleared by software\nby setting the ALERTCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "12",
                "field": "TIMEOUT",
                "description": "Timeout or t detection flag\nLOW\nThis flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared\nby software by setting the TIMEOUTCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "11",
                "field": "PECERR",
                "description": "PEC error in reception\nThis flag is set by hardware when the received PEC does not match with the PEC register\ncontent. A NACK is automatically sent after the wrong PEC reception. It is cleared by\nsoftware by setting the PECCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "10",
                "field": "OVR",
                "description": "Overrun/underrun (target mode)\nThis flag is set by hardware in target mode with NOSTRETCH = 1, when an\noverrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.\nNote: This bit is cleared by hardware when PE = 0.\nRM0436 Rev 7 2567/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              },
              {
                "range": "9",
                "field": "ARLO",
                "description": "Arbitration lost\nThis flag is set by hardware in case of arbitration loss. It is cleared by software by setting the\nARLOCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "8",
                "field": "BERR",
                "description": "Bus error\nThis flag is set by hardware when a misplaced START or STOP condition is detected\nwhereas the peripheral is involved in the transfer. The flag is not set during the address\nphase in target mode. It is cleared by software by setting the BERRCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "7",
                "field": "TCR",
                "description": "Transfer complete reload\nThis flag is set by hardware when RELOAD = 1 and NBYTES data have been transferred. It\nis cleared by software when NBYTES is written to a non-zero value.\nNote: This bit is cleared by hardware when PE = 0.\nThis flag is only for controller mode, or for target mode when the SBC bit is set.\n"
              },
              {
                "range": "6",
                "field": "TC",
                "description": "Transfer complete (controller mode)\nThis flag is set by hardware when RELOAD = 0, AUTOEND = 0 and NBYTES data have\nbeen transferred. It is cleared by software when START bit or STOP bit is set.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "5",
                "field": "STOPF",
                "description": "STOP detection flag\nThis flag is set by hardware when a STOP condition is detected on the bus and the\nperipheral is involved in this transfer:\nâ€“ as a controller, provided that the STOP condition is generated by the peripheral.\nâ€“ as a target, provided that the peripheral has been addressed previously during this\ntransfer.\nIt is cleared by software by setting the STOPCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "4",
                "field": "NACKF",
                "description": "Not acknowledge received flag\nThis flag is set by hardware when a NACK is received after a byte transmission. It is cleared\nby software by setting the NACKCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "3",
                "field": "ADDR",
                "description": "Address matched (target mode)\nThis bit is set by hardware as soon as the received target address matched with one of the\nenabled target addresses. It is cleared by software by setting ADDRCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "2",
                "field": "RXNE",
                "description": "Receive data register not empty (receivers)\nThis bit is set by hardware when the received data is copied into the I2C_RXDR register, and\nis ready to be read. It is cleared when I2C_RXDR is read.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "1",
                "field": "TXIS",
                "description": "Transmit interrupt status (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty and the data to be\ntransmitted must be written in the I2C_TXDR register. It is cleared when the next data to be\nsent is written in the I2C_TXDR register.\nThis bit can be written to 1 by software only when NOSTRETCH = 1, to generate a TXIS\nevent (interrupt if TXIE = 1 or DMA request if TXDMAEN = 1).\nNote: This bit is cleared by hardware when PE = 0.\n2568/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              },
              {
                "range": "0",
                "field": "TXE",
                "description": "Transmit data register empty (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next\ndata to be sent is written in the I2C_TXDR register.\nThis bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR.\nNote: This bit is set by hardware when PE = 0.\n"
              }
            ]
          },
          {
            "registername": "I2C_ICR",
            "offset": "0x1C",
            "page": 2569,
            "chapter": "52.9.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13",
                "field": "ALERTCF",
                "description": "Alert flag clear\nWriting 1 to this bit clears the ALERT flag in the I2C_ISR register.\n"
              },
              {
                "range": "12",
                "field": "TIMOUTCF",
                "description": "Timeout detection flag clear\nWriting 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.\n"
              },
              {
                "range": "11",
                "field": "PECCF",
                "description": "PEC error flag clear\nWriting 1 to this bit clears the PECERR flag in the I2C_ISR register.\n"
              },
              {
                "range": "10",
                "field": "OVRCF",
                "description": "Overrun/underrun flag clear\nWriting 1 to this bit clears the OVR flag in the I2C_ISR register.\n"
              },
              {
                "range": "9",
                "field": "ARLOCF",
                "description": "Arbitration lost flag clear\nWriting 1 to this bit clears the ARLO flag in the I2C_ISR register.\n"
              },
              {
                "range": "8",
                "field": "BERRCF",
                "description": "Bus error flag clear\nWriting 1 to this bit clears the BERRF flag in the I2C_ISR register.\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "STOPCF",
                "description": "STOP detection flag clear\nWriting 1 to this bit clears the STOPF flag in the I2C_ISR register.\n"
              },
              {
                "range": "4",
                "field": "NACKCF",
                "description": "Not acknowledge flag clear\nWriting 1 to this bit clears the NACKF flag in I2C_ISR register.\n"
              },
              {
                "range": "3",
                "field": "ADDRCF",
                "description": "Address matched flag clear\nWriting 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also\nclears the START bit in the I2C_CR2 register.\n"
              },
              {
                "range": "2:0",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2569/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              }
            ]
          },
          {
            "registername": "I2C_PECR",
            "offset": "0x20",
            "page": 2570,
            "chapter": "52.9.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:0",
                "field": "PEC[7:0]",
                "description": "Packet error checking register\nThis field contains the internal PEC when PECEN=1.\nThe PEC is cleared by hardware when PE = 0.\n"
              }
            ]
          },
          {
            "registername": "I2C_RXDR",
            "offset": "0x24",
            "page": 2570,
            "chapter": "52.9.10",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:0",
                "field": "RXDATA[7:0]",
                "description": "8-bit receive data\nData byte received from the IÂ²C-bus.\n2570/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              }
            ]
          },
          {
            "registername": "I2C_TXDR",
            "offset": "0x28",
            "page": 2571,
            "chapter": "52.9.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:0",
                "field": "TXDATA[7:0]",
                "description": "8-bit transmit data\nData byte to be transmitted to the IÂ²C-bus\nNote: These bits can be written only when TXE = 1.\n"
              }
            ]
          },
          {
            "registername": "I2C_HWCFGR",
            "offset": "0x3F0",
            "page": 2571,
            "chapter": "52.9.12",
            "resetvalue": "0x00000111",
            "bits": [
              {
                "range": "31:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "WKP[3:0]",
                "description": "\n0: Wake-up from Stop mode not implemented\n1: Wake-up from Stop mode implemented\n"
              },
              {
                "range": "7:4",
                "field": "ASYN[3:0]",
                "description": "\n0: Independent kernel clock not implemented\n1: Independent kernel clock implemented\n"
              },
              {
                "range": "3:0",
                "field": "SMBUS[3:0]",
                "description": "\n0: SMBus mode not implemented\n1: SMBus mode implemented\nRM0436 Rev 7 2571/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              }
            ]
          },
          {
            "registername": "I2C_VERR",
            "offset": "0x3F4",
            "page": 2572,
            "chapter": "52.9.13",
            "resetvalue": "0x00000013",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "Major revision\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "Minor revision\n"
              }
            ]
          },
          {
            "registername": "I2C_IPIDR",
            "offset": "0x3F8",
            "page": 2572,
            "chapter": "52.9.14",
            "resetvalue": "0x00130012",
            "bits": [
              {
                "range": "31:0",
                "field": "ID[31:0]",
                "description": "Identifier.\n"
              }
            ]
          },
          {
            "registername": "I2C_SIDR",
            "offset": "0x3FC",
            "page": 2572,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SID[31:0]",
                "description": "Size identifier.\n2572/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "SPI/I2S registers",
        "registers": [
          {
            "registername": "SPI_CR1",
            "offset": "0x00",
            "page": 2723,
            "chapter": "54.11.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "IOLOCK",
                "description": "locking the AF configuration of associated I/Os\nThis bit is set by software and cleared by hardware whenever SPE bit is changed from 1 to 0.\n0: AF configuration is not locked\n1: AF configuration is locked\nWhen this bit is set, the SPI_CFG2 register content cannot be modified. This bit can be set\nwhen SPI is disabled only else it is write protected. It is cleared and cannot be set when the\nMODF bit is set.\n"
              },
              {
                "range": "15",
                "field": "TCRCINI",
                "description": "CRC calculation initialization pattern control for transmitter\n0: All zero pattern is applied\n1: All ones pattern is applied\n"
              },
              {
                "range": "14",
                "field": "RCRCINI",
                "description": "CRC calculation initialization pattern control for receiver\n0: all zero pattern is applied\n1: all ones pattern is applied\n"
              },
              {
                "range": "13",
                "field": "CRC33_17",
                "description": "32-bit CRC polynomial configuration\n0: full size (33-bit or 17-bit) CRC polynomial is not used\n1: full size (33-bit or 17-bit) CRC polynomial is used\n"
              },
              {
                "range": "12",
                "field": "SSI",
                "description": "internal SS signal input level\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the\nperipheral SS input and the I/O value of the SS pin is ignored.\n"
              },
              {
                "range": "11",
                "field": "HDDIR",
                "description": "Rx/Tx direction at Half-duplex mode\nIn Half-Duplex configuration the HDDIR bit establishes the Rx/Tx direction of the data\ntransfer. This bit is ignored in Full-Duplex or any Simplex configuration.\n0: SPI is Receiver\n1: SPI is transmitter\nRM0436 Rev 7 2723/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "10",
                "field": "CSUSP",
                "description": "master suspend request\nThis bit reads as zero.\nIn master mode, when this bit is set by software, CSTART bit is reset at the end of the current\nframe and communication is suspended. The user has to check SUSP flag to check end of\nthe frame transaction.\nThe master mode communication must be suspended (using this bit or keeping TXDR\nempty) before disabling the SPI or going to low-power mode. This bit can be used in SPI or\nI2S mode.\nAfter software suspension, the SUSP flag has to be cleared and the SPI disabled and re-\nenabled before any next transaction starts.\n"
              },
              {
                "range": "9",
                "field": "CSTART",
                "description": "master transfer start\nThis bit is set by software to start an SPI or I2S/PCM communication. In SPI mode, it is\ncleared by hardware when End Of Transfer (EOT) flag is set or when a transaction suspend\nrequest is accepted. In I2S/PCM mode, it is also cleared by hardware as described in the\nsection stop sequence.\n0: master transfer is at idle\n1: master transfer is on-going or temporary suspended by automatic suspend\nIn SPI mode, the bit is taken into account at master mode only. If transmission is enabled,\ncommunication starts or continues only if any data is available in the transmission FIFO.\n"
              },
              {
                "range": "8",
                "field": "MASRX",
                "description": "master automatic SUSP in Receive mode\nThis bit is set and cleared by software to control continuous SPI transfer in master receiver\nmode and automatic management in order to avoid overrun condition.\n0: SPI flow/clock generation is continuous, regardless of overrun condition. (data are lost)\n1: SPI flow is suspended temporary on RxFIFO full condition, before reaching overrun\ncondition. The SUSP flag is set when SPI communication is suspended.\nWhen SPI communication is suspended by hardware automatically, it could happen that few\nbits of next frame are already clocked out due to internal synchronization delay.\nThat is why the automatic suspension is not quite reliable when size of data drops below 8\nbits. In this case, a safe suspension can be achieved by combination with delay inserted\nbetween data frames applied when MIDI parameter keeps a non zero value; sum of data size\nand the interleaved SPI cycles must always produce interval at length of 8 SPI clock periods\nat minimum. After software clearing of the SUSP bit, the communication resumes and\ncontinues by subsequent bits transaction without any next constraint. Prior the SUSP bit is\ncleared, the user must release the RxFIFO space as much as possible by reading out all the\ndata packets available at RxFIFO based on the RXP flag indication to prevent any\nsubsequent suspension.\n"
              },
              {
                "range": "7:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "SPE",
                "description": "serial peripheral enable\nThis bit is set by and cleared by software.\n0: serial peripheral disabled.\n1: serial peripheral enabled\nWhen SPE=1, the SPI data transfer is enabled, the configuration registers SPI_CFG1,\nSPI_CFG2, CRCPOLY and UDRDR and the IOLOCK bit in SPI_CR1 are write protected.\nThey can be changed only when SPE=0.\nWhen SPE=0 any SPI operation is stopped and disabled, all the not cleared requests with\nenabled interrupt stay pending and propagates the spi_plck clock request, the SS output is\ndeactivated at master, internal state machine is reseted, all the FIFOs content is flushed,\nCRC calculation initialized, receive data register is read zero.\nSPE is cleared and cannot be set when MODF error flag is active.\n2724/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              }
            ]
          },
          {
            "registername": "SPI_CR2",
            "offset": "0x04",
            "page": 2725,
            "chapter": "54.11.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "TSER[15:0]",
                "description": "number of data transfer extension to be reload into TSIZE just when a previous\nnumber of data stored at TSIZE is transacted\nThis register can be set by software when its content is cleared only. It is cleared by hardware\nonce TSIZE reload is done. The TSER value must be programmed in advance before\nCTSIZE counter reaches zero otherwise the reload is not taken into account and traffic\nterminates with normal EOT event.\n"
              },
              {
                "range": "15:0",
                "field": "TSIZE[15:0]",
                "description": "number of data at current transfer\nWhen these bits are changed by software, the SPI must be disabled. The field can be\nupdated by hardware optionally, too, to be reloaded by the TSER value if applicable.\nEndless transaction is initialized when CSTART is set while zero value is stored at TSIZE.\nTSIZE cannot be set to 0xFFFF value when CRC is enabled.\n"
              }
            ]
          },
          {
            "registername": "SPI_CFG1",
            "offset": "0x08",
            "page": 2725,
            "chapter": "54.11.3",
            "resetvalue": "0x00070007",
            "bits": [
              {
                "range": "31",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2725/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "30:28",
                "field": "MBR[2:0]",
                "description": "master baud rate\n000: SPI master clock/2\n001: SPI master clock/4\n010: SPI master clock/8\n011: SPI master clock/16\n100: SPI master clock/32\n101: SPI master clock/64\n110: SPI master clock/128\n111: SPI master clock/256\nNote: MBR setting is considered at slave working at TI mode, too (see Section54.5.1: TI\nmode).\n"
              },
              {
                "range": "27:23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22",
                "field": "CRCEN",
                "description": "hardware CRC computation enable\n0: CRC calculation disabled\n1: CRC calculation Enabled\n"
              },
              {
                "range": "21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20:16",
                "field": "CRCSIZE[4:0]",
                "description": "length of CRC frame to be transacted and compared\nMost significant bits are taken into account from polynomial calculation when CRC result is\ntransacted or compared. The length of the polynomial is not affected by this setting.\n00000: reserved\n00001: reserved\n00010: reserved\n00011: 4-bits\n00100: 5-bits\n00101: 6-bits\n00110: 7-bits\n00111: 8-bits\n.....\n11101: 30-bits\n11110: 31-bits\n11111: 32-bits\nThe value must be set equal or multiply of data size (DSIZE[4:0]). Its maximum size cannot\nexceed the DSIZE maximum at the instance.\nNote: If CRC calculation is disabled by CRCEN=0, the CRCSIZE field must be kept at its\ndefault setting.\nNote: The most significant bit at CRCSIZE bit field is reserved at the peripheral instances\nwhere the data size is limited to 16-bit.\n"
              },
              {
                "range": "15",
                "field": "TXDMAEN",
                "description": "Tx DMA stream enable\n0: Tx DMA disabled\n1: Tx DMA enabled\n"
              },
              {
                "range": "14",
                "field": "RXDMAEN",
                "description": "Rx DMA stream enable\n0: Rx-DMA disabled\n1: Rx-DMA enabled\n"
              },
              {
                "range": "13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n2726/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "12:11",
                "field": "UDRDET[1:0]",
                "description": "detection of underrun condition at slave transmitter\n00: underrun is detected at begin of data frame (no protection of 1-st bit)\n01: underrun is detected at end of last data frame\n10: underrun is detected by begin of active SS signal\n11: reserved\nFor more details see Figure624: Optional configurations of slave behavior at detection of\nunderrun condition.\n"
              },
              {
                "range": "10:9",
                "field": "UDRCFG[1:0]",
                "description": "behavior of slave transmitter at underrun condition\n00: slave sends a constant pattern defined by the user at SPI_UDRDR register\n01: slave repeats lastly received data frame from master\n10: slave repeats its lastly transmitted data frame\n11: reserved\nWhen slave is configured at transmit only mode (COMM[1:0]=01), slave repeats all zeros\npattern at UDRCFG[1:0]=01 setting.\nFor more details see Figure624: Optional configurations of slave behavior at detection of\nunderrun condition.\n"
              },
              {
                "range": "8:5",
                "field": "FTHLV[3:0]",
                "description": "FIFO threshold level\nDefines number of data frames at single data packet. The size of the packet must not exceed\n1/2 of FIFO space.\n0000: 1-data\n0001: 2-data\n0010: 3-data\n0011: 4-data\n0100: 5-data\n0101: 6-data\n0110: 7-data\n0111: 8-data\n1000: 9-data\n1001: 10-data\n1010: 11-data\n1011: 12-data\n1100: 13-data\n1101: 14-data\n1110: 15-data\n1111: 16-data\nSPI interface is more efficient if configured packet sizes are aligned with data register access\nparallelism:\nâ€“ If SPI data register is accessed as a 16-bit register and DSIZEâ‰¤8 bits, better to select\nFTHLV=2, 4, 6 ..,\nâ€“ If SPI data register is accessed as a 32-bit register and DSIZE>8bit, better to select\nFTHLV=2, 4, 6 .., while if DSIZEâ‰¤8 bits, better to select FTHLV=4, 8, 12 ..\nRM0436 Rev 7 2727/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "4:0",
                "field": "DSIZE[4:0]",
                "description": "number of bits in at single SPI data frame\n00000: not used\n00001: not used\n00010: not used\n00011: 4-bits\n00100: 5-bits\n00101: 6-bits\n00110: 7-bits\n00111: 8-bits\n.....\n11101: 30-bits\n11110: 31-bits\n11111: 32-bits\nNote: The most significant bit at DSIZE bit field is reserved at the peripheral instances where\ndata size is limited to 16-bit.\n"
              }
            ]
          },
          {
            "registername": "SPI_CFG2",
            "offset": "0x0C",
            "page": 2728,
            "chapter": "54.11.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "AFCNTR",
                "description": "alternate function GPIOs control\nThis bit is taken into account when SPE=0 only\n0: the peripheral takes no control of GPIOs while it is disabled\n1: the peripheral keeps always control of all associated GPIOs\nWhen SPI master has to be disabled temporary for a specific configuration reason (e.g. CRC\nreset, CPHA or HDDIR change) setting this bit prevents any glitches on the associated\noutputs configured at alternate function mode by keeping them forced at state corresponding\nthe current SPI configuration. This bit must be never used at slave mode as any slave\ntransmitter must not force its MISO output once the SPI is disabled.\nNote: This bit can be also used in PCM and I2S modes.\n"
              },
              {
                "range": "30",
                "field": "SSOM",
                "description": "SS output management in master mode\nThis bit is taken into account in master mode when SSOE is enabled. It allows to configure SS\noutput between two consecutive data transfers.\n0: SS is kept at active level till data transfer is completed, it becomes inactive with EOT flag\n1: SPI data frames are interleaved with SS non active pulses when MIDI[3:0]>1\n2728/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "29",
                "field": "SSOE",
                "description": "SS output enable\nThis bit is taken into account at master mode only\n0: SS output is disabled and the SPI can work in multimaster configuration\n1: SS output is enabled. The SPI cannot work in a multimaster environment. It forces the SS\npin at inactive level after the transfer is completed or SPI is disabled with respect to SSOM,\nMIDI, MSSI, SSIOP bits setting\n"
              },
              {
                "range": "28",
                "field": "SSIOP",
                "description": "SS input/output polarity\n0: low level is active for SS signal\n1: high level is active for SS signal\n"
              },
              {
                "range": "27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26",
                "field": "SSM",
                "description": "software management of SS signal input\n0: SS input value is determined by the SS PAD\n1: SS input value is determined by the SSI bit\nWhen master uses hardware SS output (SSM=0 and SSOE=1), the SS signal input is forced\nto non active state internally to prevent master mode fault error.\n"
              },
              {
                "range": "25",
                "field": "CPOL",
                "description": "clock polarity\n0: SCK signal is at 0 when idle\n1: SCK signal is at 1 when idle\n"
              },
              {
                "range": "24",
                "field": "CPHA",
                "description": "clock phase\n0: the first clock transition is the first data capture edge\n1: the second clock transition is the first data capture edge\n"
              },
              {
                "range": "23",
                "field": "LSBFRST",
                "description": "data frame format\n0: MSB transmitted first\n1: LSB transmitted first\nNote: This bit can be also used in PCM and I2S modes.\n"
              },
              {
                "range": "22",
                "field": "MASTER",
                "description": "SPI master\n0: SPI Slave\n1: SPI Master\n"
              },
              {
                "range": "21:19",
                "field": "SP[2:0]",
                "description": "Serial protocol\n000: SPI Motorola\n001: SPI TI\nothers: Reserved, must not be used\n"
              },
              {
                "range": "18:17",
                "field": "COMM[1:0]",
                "description": "SPI communication mode\n00: full-duplex\n01: simplex transmitter\n10: simplex receiver\n11: half-duplex\n"
              },
              {
                "range": "16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "IOSWP",
                "description": "swap functionality of MISO and MOSI pins\n0: no swap\n1: MOSI and MISO are swapped\nWhen this bit is set, the function of MISO and MOSI pins alternate functions are inverted.\nOriginal MISO pin becomes MOSI and original MOSI pin becomes MISO.\nNote: This bit can be also used in PCM and I2S modes.\n"
              },
              {
                "range": "14:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2729/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "7:4",
                "field": "MIDI[3:0]",
                "description": "master Inter-Data Idleness\nSpecifies minimum time delay (expressed in SPI clock cycles periods) inserted between two\nconsecutive data frames in master mode.\n0000: no delay\n0001: 1 clock cycle period delay\n...\n1111: 15 clock cycle periods delay\nNote: This feature is not supported in TI mode.\n"
              },
              {
                "range": "3:0",
                "field": "MSSI[3:0]",
                "description": "master SS idleness\nSpecifies an extra delay, expressed in number of SPI clock cycle periods, inserted\nadditionally between active edge of SS and first data of a session start in master mode when\nSSOE is enabled.\n0000: no extra delay\n0001: 1 clock cycle period delay added\n...\n1111: 15 clock cycle periods delay added\nNote: This feature is not supported in TI mode.\n"
              }
            ]
          },
          {
            "registername": "SPI_IER",
            "offset": "0x10",
            "page": 2730,
            "chapter": "54.11.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10",
                "field": "TSERFIE",
                "description": "additional number of transactions reload interrupt enable\n0: TSERF interrupt disabled\n1: TSERF interrupt enabled\n"
              },
              {
                "range": "9",
                "field": "MODFIE",
                "description": "mode fault interrupt enable\n0: MODF interrupt disabled\n1: MODF interrupt enabled\n"
              },
              {
                "range": "8",
                "field": "TIFREIE",
                "description": "TIFRE interrupt enable\n0: TIFRE interrupt disabled\n1: TIFRE interrupt enabled\n"
              },
              {
                "range": "7",
                "field": "CRCEIE",
                "description": "CRC error interrupt enable\n0: CRC interrupt disabled\n1: CRC interrupt enabled\n"
              },
              {
                "range": "6",
                "field": "OVRIE",
                "description": "OVR interrupt enable\n0: OVR interrupt disabled\n1: OVR interrupt enabled\n2730/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "5",
                "field": "UDRIE",
                "description": "UDR interrupt enable\n0: UDR interrupt disabled\n1: UDR interrupt enabled\n"
              },
              {
                "range": "4",
                "field": "TXTFIE",
                "description": "TXTFIE interrupt enable\n0: TXTF interrupt disabled\n1: TXTF interrupt enabled\n"
              },
              {
                "range": "3",
                "field": "EOTIE",
                "description": "EOT, SUSP and TXC interrupt enable\n0: EOT/SUSP/TXC interrupt disabled\n1: EOT/SUSP/TXC interrupt enabled\n"
              },
              {
                "range": "2",
                "field": "DXPIE",
                "description": "DXP interrupt enabled\nDXPIE is set by software and cleared by TXTF flag set event.\n0: DXP interrupt disabled\n1: DXP interrupt enabled\n"
              },
              {
                "range": "1",
                "field": "TXPIE",
                "description": "TXP interrupt enable\nTXPIE is set by software and cleared by TXTF flag set event.\n0: TXP interrupt disabled\n1: TXP interrupt enabled\n"
              },
              {
                "range": "0",
                "field": "RXPIE",
                "description": "RXP Interrupt Enable\n0: RXP interrupt disabled\n1: RXP interrupt enabled\n"
              }
            ]
          },
          {
            "registername": "SPI_SR",
            "offset": "0x14",
            "page": 2731,
            "chapter": "54.11.6",
            "resetvalue": "0x00001002",
            "bits": [
              {
                "range": "31:16",
                "field": "CTSIZE[15:0]",
                "description": "number of data frames remaining in current TSIZE session\nThe value is not quite reliable when traffic is ongoing on bus and at LP mode too.\n"
              },
              {
                "range": "15",
                "field": "RXWNE",
                "description": "RxFIFO word not empty\n0: less than four bytes of RxFIFO space is occupied by data\n1: at least four bytes of RxFIFO space is occupied by data\nNote: This bit value does not depend on DSIZE setting and keeps together with RXPLVL[1:0]\ninformation about RxFIFO occupancy by residual data.\nRM0436 Rev 7 2731/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "14:13",
                "field": "RXPLVL[1:0]",
                "description": "RxFIFO packing level\nWhen RXWNE=0 and data size is set up to 16-bit, the value gives number of remaining data\nframes persisting at RxFIFO.\n00: no next frame is available at RxFIFO\n01: 1 frame is available\n10: 2 frames are available*\n11: 3 frames are available*\n(*) optional count when the data size is set up to 8-bit.\nWhen the frame size is greater than 16-bit, these bits read as 00. In consequence, the single\ndata frame received at the FIFO cannot be detected neither by RWNE nor by RXPLVL bits if\ndata size is set from 17 to 24 bits. The user then must apply other methods like TSIZE>0 or\nFTHLV=0.\n"
              },
              {
                "range": "12",
                "field": "TXC",
                "description": "TxFIFO transmission complete\nThe flag behavior depends on TSIZE setting.\nWhen TSIZE=0 the TXC is changed by hardware exclusively and it raises each time the\nTxFIFO becomes empty and there is no activity on the bus.\nIf TSIZE <>0 there is no specific reason to monitor TXC as it just copies the EOT flag value\nincluding its software clearing. The TXC generates an interrupt when EOTIE is set.\n0: Current data transaction is still ongoing, data is available in TxFIFO or last frame\ntransmission is on going.\n1: Last TxFIFO frame transmission completed\n"
              },
              {
                "range": "11",
                "field": "SUSP",
                "description": "suspension status\nIn Master mode, SUSP is set by hardware when a CSUSP request is done, either as soon as\nthe current frame is completed after CSUSP request is done or at master automatic suspend\nreceive mode (MASRX bit is set at SPI_CR1 register) on RxFIFO full condition.\nSUSP generates an interrupt when EOTIE is set.\nThis bit has to be cleared prior SPI is disabled by write 1 to SUSPC bit at SPI_IFCR\n0: SPI not suspended (master mode active or other mode).\n1: Master mode is suspended (current frame completed)\n"
              },
              {
                "range": "10",
                "field": "TSERF",
                "description": "additional number of SPI data to be transacted was reload\nThis bit is cleared by write 1 to TSERFC bit at SPI_IFCR or by writing the TSER[15:0]\n(SPI_CR2) register\n0: no acceptation\n1: additional number of data accepted, current transaction continues\n"
              },
              {
                "range": "9",
                "field": "MODF",
                "description": "mode fault\n0: no mode fault\n1: mode fault detected\nThis bit is cleared by write 1 to MODFC bit at SPI_IFCR. When MODF is set, the SPE and\nIOLOCK bits at the SPI_CR1 register are reset and their setting is blocked.\n"
              },
              {
                "range": "8",
                "field": "TIFRE",
                "description": "TI frame format error\n0: no TI Frame Error\n1: TI Frame Error detected\nThis bit is cleared by write 1 to TIFREC bit at SPI_IFCR\n"
              },
              {
                "range": "7",
                "field": "CRCE",
                "description": "CRC error\n0: no CRC error\n1: CRC error detected\nThis bit is cleared by write 1 to CRCEC bit at SPI_IFCR\n2732/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "6",
                "field": "OVR",
                "description": "overrun\n0: no overrun\n1: overrun detected\nThis bit is cleared by write 1 to OVRC bit at SPI_IFCR\n"
              },
              {
                "range": "5",
                "field": "UDR",
                "description": "underrun\n0: no underrun\n1: underrun detected\nThis bit is cleared by write 1 to UDRC bit at SPI_IFCR\nNote: In SPI mode, the UDR flag applies to Slave mode only. In I2S/PCM mode, (when\navailable) this flag applies to Master and Slave mode.\n"
              },
              {
                "range": "4",
                "field": "TXTF",
                "description": "transmission transfer filled\n0: upload of TxFIFO is on-going or not started\n1: TxFIFO upload is finished\nTXTF is set by hardware as soon as all of the data packets in a transfer have been submitted\nfor transmission by application software or DMA, that is when TSIZE number of data have\nbeen pushed into the TxFIFO.\nThis bit is cleared by software write 1 to TXTFC bit at SPI_IFCR\nTXTF flag triggers an interrupt if TXTFIE bit is set.\nTXTF setting clears the TXIE and DXPIE masks so to off-load application software from\ncalculating when to disable TXP and DXP interrupts.\n"
              },
              {
                "range": "3",
                "field": "EOT",
                "description": "end of transfer\nEOT is set by hardware as soon as a full transfer is complete, that is when TSIZE number of\ndata have been transmitted and/or received on the SPI. EOT is cleared by software write 1 to\nEOTC bit at SPI_IFCR.\nEOT flag triggers an interrupt if EOTIE bit is set.\nIf DXP flag is used until TXTF flag is set and DXPIE is cleared, EOT can be used to\ndownload the last packets contained into RxFIFO in one-shot.\n0: transfer is on-going or not started\n1: transfer complete\nIn master, EOT event terminates the data transaction and handles SS output optionally. When\nCRC is applied, the EOT event is extended over the CRC frame transaction.\n"
              },
              {
                "range": "2",
                "field": "DXP",
                "description": "duplex packet\n0: TxFIFO is Full and/or RxFIFO is Empty\n1: Both TxFIFO has space for write and RxFIFO contains for read a single packet at least\nThe DXP flag is set whenever both TXP and RXP flags are set regardless the SPI mode.\n"
              },
              {
                "range": "1",
                "field": "TXP",
                "description": "Tx-packet space available\n0: there is not enough space to locate next data packet at TxFIFO\n1: TxFIFO has enough free location to host 1 data packet\nTXP flag is changed by hardware. It monitors overall space currently available at TxFIFO if\nSPI is enabled. It has to be checked once a complete data packet is stored at TxFIFO.\n"
              },
              {
                "range": "0",
                "field": "RXP",
                "description": "Rx-packet available\n0: RxFIFO is empty or a not complete data packet is received\n1: RxFIFO contains at least 1 data packet\nRXP flag is changed by hardware. It monitors number of overall data currently available at\nRxFIFO if SPI is enabled. It has to be checked once a data packet is completely read out\nfrom RxFIFO.\nRM0436 Rev 7 2733/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              }
            ]
          },
          {
            "registername": "SPI_IFCR",
            "offset": "0x18",
            "page": 2734,
            "chapter": "54.11.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11",
                "field": "SUSPC",
                "description": "SUSPend flag clear\nWriting a 1 into this bit clears SUSP flag in the SPI_SR register\n"
              },
              {
                "range": "10",
                "field": "TSERFC",
                "description": "TSERFC flag clear\nWriting a 1 into this bit clears TSERF flag in the SPI_SR register\nNote: TSERF is also reset by writing the TSER[15:0] (SPI_CR2) register\n"
              },
              {
                "range": "9",
                "field": "MODFC",
                "description": "mode fault flag clear\nWriting a 1 into this bit clears MODF flag in the SPI_SR register\n"
              },
              {
                "range": "8",
                "field": "TIFREC",
                "description": "TI frame format error flag clear\nWriting a 1 into this bit clears TIFRE flag in the SPI_SR register\n"
              },
              {
                "range": "7",
                "field": "CRCEC",
                "description": "CRC error flag clear\nWriting a 1 into this bit clears CRCE flag in the SPI_SR register\n"
              },
              {
                "range": "6",
                "field": "OVRC",
                "description": "overrun flag clear\nWriting a 1 into this bit clears OVR flag in the SPI_SR register\n"
              },
              {
                "range": "5",
                "field": "UDRC",
                "description": "underrun flag clear\nWriting a 1 into this bit clears UDR flag in the SPI_SR register\n"
              },
              {
                "range": "4",
                "field": "TXTFC",
                "description": "transmission Transfer Filled flag clear\nWriting a 1 into this bit clears TXTF flag in the SPI_SR register\n"
              },
              {
                "range": "3",
                "field": "EOTC",
                "description": "end of transfer flag clear\nWriting a 1 into this bit clears EOT flag in the SPI_SR register\n"
              },
              {
                "range": "2:0",
                "field": "Reserved",
                "description": "must be kept at reset value.\n2734/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              }
            ]
          },
          {
            "registername": "SPI_TXDR",
            "offset": "0x20",
            "page": 2735,
            "chapter": "54.11.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "TXDR[31:0]",
                "description": "transmit data register\nThe register serves as an interface with TxFIFO. A write to it accesses TxFIFO.\nNote: data is always right-aligned. Unused bits are ignored when writing to the register, and\nread as zero when the register is read.\nNote: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is written\nby single access.\nhalfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be\nwritten by single access.\nword-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data\ncan be written by single access.\nWrite access of this register less than the configured data size is forbidden.\n"
              }
            ]
          },
          {
            "registername": "SPI_RXDR",
            "offset": "0x30",
            "page": 2735,
            "chapter": "54.11.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "RXDR[31:0]",
                "description": "receive data register\nThe register serves as an interface with RxFIFO. When it is read, RxFIFO is accessed.\nNote: Data is always right-aligned. Unused bits are read as zero when the register is read.\nWriting to the register is ignored.\nNote: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is read\nby single access.\nhalfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be read\nby single access\nword-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data\ncan be read by single access.\nRead access of this register less than the configured data size is forbidden.\nRM0436 Rev 7 2735/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              }
            ]
          },
          {
            "registername": "SPI_CRCPOLY",
            "offset": "0x40",
            "page": 2736,
            "chapter": "54.11.10",
            "resetvalue": "0x00000107",
            "bits": [
              {
                "range": "31:0",
                "field": "CRCPOLY[31:0]",
                "description": "CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe default 9-bit polynomial setting 0x107 corresponds to default 8-bit setting of DSIZE. It is\ncompatible with setting 0x07 used at some other ST products with fixed length of the\npolynomial string where the most significant bit of the string is always kept hidden.\nThe length of the polynomial is given by the most significant bit of the value stored at this\nregister. It has to be set greater than DSIZE. CRC33_17 bit has to be set additionally with\nCRCPOLY register when DSIZE is configured to maximum 32-bit or 16-bit size and CRC is\nenabled (to keep polynomial length greater than data size).\nBits 31-16 are reserved at the peripheral instances with data size limited to 16-bit. There is\nno constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are\nalways read zero while any write to them is ignored.\n"
              }
            ]
          },
          {
            "registername": "SPI_TXCRC",
            "offset": "0x44",
            "page": 2736,
            "chapter": "54.11.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "TXCRC[31:0]",
                "description": "CRC register for transmitter\nWhen CRC calculation is enabled, the TXCRC[31:0] bits contain the computed CRC value\nof the subsequently transmitted bytes. CRC calculation is initialized when the CRCEN bit of\nSPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is\ncalculated serially using the polynomial programmed in the SPI_CRCPOLY register.\nThe number of bits considered at calculation depends on SPI_CRCPOLY register and\nCRCSIZE bits settings at SPI_CFG1 register.\nNote: A read to this register when the communication is ongoing could return an incorrect\nvalue.\nNot used for the I2S mode.\nBits 31-16 are reserved at the peripheral instances with data size limited to 16-bit.\nThere is no constrain when 32-bit access is applied at these addresses. Reserved bits\n31-16 are always read zero while any write to them is ignored.\nNote: The configuration of CRCSIZE bit field is not taken into account when the content of\nthis register is read by software. No masking is applied for unused bits at this case.\n"
              }
            ]
          },
          {
            "registername": "SPI_RXCRC",
            "offset": "0x48",
            "page": 2737,
            "chapter": "54.11.12",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "RXCRC[31:0]",
                "description": "CRC register for receiver\nWhen CRC calculation is enabled, the RXCRC[31:0] bits contain the computed CRC value\nof the subsequently received bytes. CRC calculation is initialized when the CRCEN bit of\nSPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is\ncalculated serially using the polynomial programmed in the SPI_CRCPOLY register.\nThe number of bits considered at calculation depends on SPI_CRCPOLY register and\nCRCSIZE bits settings at SPI_CFG1 register.\nNote: A read to this register when the communication is ongoing could return an incorrect\nvalue.\nNot used for the I2S mode.\nBits 31-16 are reserved at the peripheral instances with data size limited to 16-bit.\nThere is no constrain when 32-bit access is applied at these addresses. Reserved bits\n31-16 are always read zero while any write to them is ignored.\nNote: The configuration of CRCSIZE bit field is not taken into account when the content of\nthis register is read by software. No masking is applied for unused bits at this case.\nRM0436 Rev 7 2737/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              }
            ]
          },
          {
            "registername": "SPI_UDRDR",
            "offset": "0x4C",
            "page": 2738,
            "chapter": "54.11.13",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "UDRDR[31:0]",
                "description": "data at slave underrun condition\nThe register is taken into account at slave mode and at underrun condition only. The\nnumber of bits considered depends on DSIZE bit settings at SPI_CFG1 register. Underrun\ncondition handling depends on setting if UDRDET and UDRCFG bits at SPI_CFG1 register.\nBits 31-16 are reserved at the peripheral instances with data size limited to 16-bit. There is\nno constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are\nalways read zero while any write to them is ignored.\n"
              }
            ]
          },
          {
            "registername": "SPI_I2SCFGR",
            "offset": "0x50",
            "page": 2738,
            "chapter": "54.11.14",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25",
                "field": "MCKOE",
                "description": "master clock output enable\n0: Master clock output is disabled\n1: Master clock output is enabled\n"
              },
              {
                "range": "24",
                "field": "ODD",
                "description": "odd factor for the prescaler\n0: Real divider value is = I2SDIV *2\n1: Real divider value is = (I2SDIV * 2) + 1\nRefer to Section54.9.9: Clock generator for details\n2738/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "23:16",
                "field": "I2SDIV[7:0]",
                "description": "I2S linear prescaler\nI2SDIV can take any values except the value 1, when ODD is also equal to 1.\nRefer to Section54.9.9: Clock generator for details\n"
              },
              {
                "range": "15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14",
                "field": "DATFMT",
                "description": "data format\n0: the data inside the SPI_RXDR or SPI_TXDR are right aligned\n1: the data inside the SPI_RXDR or SPI_TXDR are left aligned.\n"
              },
              {
                "range": "13",
                "field": "WSINV",
                "description": "Word select inversion\nThis bit is used to invert the default polarity of WS signal.\n0: In I2S Philips standard, the left channel transfer starts one CK cycle after the WS falling edge,\nand the right channel one CK cycle after the WS rising edge.\nIn MSB or LSB justified mode, the left channel is transferred when WS is HIGH, and the right\nchannel when WS is LOW.\nIn PCM mode, the data transfer starts one CK cycle after the rising edge of WS.\n1: In I2S Philips standard, the left channel transfer starts one CK cycle after the WS rising edge,\nand the right channel one CK cycle after the WS falling edge.\nIn MSB or LSB justified mode, the left channel is transfered when WS is LOW, and right channel\nwhen WS is HIGH.\nIn PCM mode, the data transfer starts one CK cycle after the rising edge of WS.\n"
              },
              {
                "range": "12",
                "field": "FIXCH",
                "description": "fixed channel length in slave\n0: the channel length in slave mode is different from 16 or 32 bits (CHLEN not taken into account)\n1: the channel length in slave mode is supposed to be 16 or 32 bits (according to CHLEN)\n"
              },
              {
                "range": "11",
                "field": "CKPOL",
                "description": "serial audio clock polarity\n0: the signals generated by the SPI/I2S (i.e. SDO and WS) are changed on the falling edge of CK\nand the signals received by the SPI/I2S (i.e. SDI and WS) are read of the rising edge of CK.\n1: the signals generated by the SPI/I2S (i.e. SDO and WS) are changed on the rising edge of CK\nand the signals received by the SPI/I2S (i.e. SDI and WS) are read of the falling edge of CK.\n"
              },
              {
                "range": "10",
                "field": "CHLEN",
                "description": "channel length (number of bits per audio channel)\n0: 16-bit wide\n1: 32-bit wide\nThe selected channel length must always be higher or equal to the data length (DATLEN).\n"
              },
              {
                "range": "9:8",
                "field": "DATLEN[1:0]",
                "description": "data length to be transferred\n00: 16-bit data length\n01: 24-bit data length\n10: 32-bit data length\n11: not allowed\nThe selected data length must never be higher than the channel length (CHLEN).\nNote: Data width of 24 and 32 bits are not always supported, (DATLEN = 01 or 10), refer to\nSection54.3: SPI implementation to check the supported data size.\n"
              },
              {
                "range": "7",
                "field": "PCMSYNC",
                "description": "PCM frame synchronization\n0: short frame synchronization\n1: long frame synchronization\n"
              },
              {
                "range": "6",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2739/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "5:4",
                "field": "I2SSTD[1:0]",
                "description": "I2S standard selection\n00: I2S Philips standard.\n01: MSB justified standard (left justified)\n10: LSB justified standard (right justified)\n11: PCM standard\nFor more details on I2S standards, refer to Section54.9.5: Supported audio protocols\n"
              },
              {
                "range": "3:1",
                "field": "I2SCFG[2:0]",
                "description": "I2S configuration mode\n000: slave - transmit\n001: slave - receive\n010: master - transmit\n011: master - receive\n100: slave - full duplex\n101: master - full duplex\nothers, not used\n"
              },
              {
                "range": "0",
                "field": "I2SMOD",
                "description": "I2S mode selection\n0: SPI mode is selected\n1: I2S/PCM mode is selected\n"
              }
            ]
          },
          {
            "registername": "SPI_I2S_HWCFGR",
            "offset": "0x03F0",
            "page": 2740,
            "chapter": "54.11.15",
            "resetvalue": "0x000xxxxx",
            "bits": [
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:16",
                "field": "DSCFG[3:0]",
                "description": "SPI data size configuration\n0000: data size is configurable from 4-bits to 16-bits\n0001: data size is configurable from 4-bits to 32-bits\nAll the other combinations are reserved.\n"
              },
              {
                "range": "15:12",
                "field": "I2SCFG[3:0]",
                "description": "I2S configuration\n0000: I2S support is not implemented\n0001: I2S support is implemented\nAll the other combinations are reserved.\n2740/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "11:8",
                "field": "CRCCFG[3:0]",
                "description": "CRC configuration for SPI\n0000: CRC support is not implemented\n0001: CRC support is implemented\nAll the other combinations are reserved.\n"
              },
              {
                "range": "7:4",
                "field": "RXFCFG[3:0]",
                "description": "RxFIFO size\n0002: the FIFO size is 4 bytes\n0003: the FIFO size is 8 bytes\n0004: the FIFO size is 16 bytes\n0005: the FIFO size is 32 bytes\nAll the other combinations are reserved.\n"
              },
              {
                "range": "3:0",
                "field": "TXFCFG[3:0]",
                "description": "TxFIFO size\n0002: the FIFO size is 4 bytes\n0003: the FIFO size is 8 bytes\n0004: the FIFO size is 16 bytes\n0005: the FIFO size is 32 bytes\nAll the other combinations are reserved.\n"
              }
            ]
          },
          {
            "registername": "SPI_VERR",
            "offset": "0x03F4",
            "page": 2741,
            "chapter": "54.11.16",
            "resetvalue": "0x00000011",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "major revision of the IP.\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "minor revision of the IP.\n"
              }
            ]
          },
          {
            "registername": "SPI_IPIDR",
            "offset": "0x03F8",
            "page": 2741,
            "chapter": "54.11.17",
            "resetvalue": "0x00130022",
            "bits": [
              {
                "range": "31:0",
                "field": "ID[31:0]",
                "description": "IP identification\nMCD identification code which identifies the IP.\nRM0436 Rev 7 2741/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              }
            ]
          },
          {
            "registername": "SPI_SIDR",
            "offset": "0x03FC",
            "page": 2742,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SID[31:0]",
                "description": "size identification\nBits[31:8]: fixed code 0xA3C5DD0\nBits[7:0]: range of address decoding boundary\n0x01: 1 Kbyte\n0x02: 2 Kbytes\n0x04: 4 Kbytes\n0x08: 8 Kbytes\nAll the other combination are reserved.\n2742/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "USART registers",
        "registers": [
          {
            "registername": "USART_CR1",
            "offset": "0x00",
            "page": 2626,
            "chapter": "53.8.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "RXFFIE",
                "description": "RXFIFO full interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when RXFF=1 in the USART_ISR register\n"
              },
              {
                "range": "30",
                "field": "TXFEIE",
                "description": "TXFIFO empty interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when TXFE=1 in the USART_ISR register\n"
              },
              {
                "range": "29",
                "field": "FIFOEN",
                "description": "FIFO mode enable\nThis bit is set and cleared by software.\n0: FIFO mode is disabled.\n1: FIFO mode is enabled.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode\nand in smartcard modes only. It must not be enabled in IrDA and LIN modes.\n2626/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "28",
                "field": "M1",
                "description": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or\ncleared by software.\nM[1:0] = â€˜00â€™: 1 start bit, 8 Data bits, n Stop bit\nM[1:0] = â€˜01â€™: 1 start bit, 9 Data bits, n Stop bit\nM[1:0] = â€˜10â€™: 1 start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In 7-bits data length mode, the smartcard mode, LIN master mode and auto baud rate\n(0x7F and 0x55 frames detection) are not supported.\n"
              },
              {
                "range": "27",
                "field": "EOBIE",
                "description": "End-of-block interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the EOBF flag is set in the USART_ISR register\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "26",
                "field": "RTOIE",
                "description": "Receiver timeout interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the RTOF bit is set in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and\nmust be kept at reset value. Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "25:21",
                "field": "DEAT[4:0]",
                "description": "Driver enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and\nthe beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time,\ndepending on the oversampling rate).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "20:16",
                "field": "DEDT[4:0]",
                "description": "Driver enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted\nmessage, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample\ntime units (1/8 or 1/16 bit time, depending on the oversampling rate).\nIf the USART_TDR register is written during the DEDT time, the new data is transmitted only\nwhen the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "15",
                "field": "OVER8",
                "description": "Oversampling mode\n0: Oversampling by 16\n1: Oversampling by 8\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In LIN, IrDA and smartcard modes, this bit must be kept cleared.\n"
              },
              {
                "range": "14",
                "field": "CMIE",
                "description": "Character match interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the CMF bit is set in the USART_ISR register.\nRM0436 Rev 7 2627/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "13",
                "field": "MME",
                "description": "Mute mode enable\nThis bit enables the USART mute mode function. When set, the USART can switch between\nactive and mute mode, as defined by the WAKE bit. It is set and cleared by software.\n0: Receiver in active mode permanently\n1: Receiver can switch between mute mode and active mode.\n"
              },
              {
                "range": "12",
                "field": "M0",
                "description": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or\ncleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "11",
                "field": "WAKE",
                "description": "Receiver wake-up method\nThis bit determines the USART wake-up method from mute mode. It is set or cleared by\nsoftware.\n0: Idle line\n1: Address mark\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "10",
                "field": "PCE",
                "description": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity\ncontrol is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit\nif M=0) and the parity is checked on the received data. This bit is set and cleared by\nsoftware. Once it is set, PCE is active after the current byte (in reception and in\ntransmission).\n0: Parity control disabled\n1: Parity control enabled\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "9",
                "field": "PS",
                "description": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE\nbit set). It is set and cleared by software. The parity is selected after the current byte.\n0: Even parity\n1: Odd parity\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "8",
                "field": "PEIE",
                "description": "PE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever PE=1 in the USART_ISR register\n"
              },
              {
                "range": "7",
                "field": "TXFNFIE",
                "description": "TXFIFO not-full interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TXFNF =1 in the USART_ISR register\n"
              },
              {
                "range": "6",
                "field": "TCIE",
                "description": "Transmission complete interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TC=1 in the USART_ISR register\n"
              },
              {
                "range": "5",
                "field": "RXFNEIE",
                "description": "RXFIFO not empty interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever ORE=1 or RXFNE=1 in the USART_ISR register\n2628/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "4",
                "field": "IDLEIE",
                "description": "IDLE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever IDLE=1 in the USART_ISR register\n"
              },
              {
                "range": "3",
                "field": "TE",
                "description": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\n0: Transmitter is disabled\n1: Transmitter is enabled\nNote: During transmission, a low pulse on the TE bit (â€˜0â€™ followed by â€˜1â€™) sends a preamble\n(idle line) after the current word, except in smartcard mode. In order to generate an idle\ncharacter, the TE must not be immediately written to â€˜1â€™. To ensure the required duration,\nthe software can poll the TEACK bit in the USART_ISR register.\nIn smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission\nstarts.\n"
              },
              {
                "range": "2",
                "field": "RE",
                "description": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software.\n0: Receiver is disabled\n1: Receiver is enabled and begins searching for a start bit\n"
              },
              {
                "range": "1",
                "field": "UESM",
                "description": "USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\n0: USART not able to wake up the MCU from low-power mode.\n1: USART able to wake up the MCU from low-power mode.\nNote: It is recommended to set the UESM bit just before entering low-power mode and clear it\nwhen exit from low-power mode.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "0",
                "field": "UE",
                "description": "USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all\ncurrent operations are discarded. The USART configuration is kept, but all the USART_ISR\nstatus flags are reset. This bit is set and cleared by software.\n0: USART prescaler and outputs disabled, low-power mode\n1: USART enabled\nNote: To enter low-power mode without generating errors on the line, the TE bit must be\npreviously reset and the software must wait for the TC bit in the USART_ISR to be set\nbefore resetting the UE bit.\nThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled\nbefore resetting the UE bit.\nIn smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1,\nregardless of the UE bit value.\n"
              }
            ]
          },
          {
            "registername": "USART_CR1-alternate",
            "offset": "0x00",
            "page": 2629,
            "chapter": "53.8.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29",
                "field": "FIFOEN",
                "description": "FIFO mode enable\nThis bit is set and cleared by software.\n0: FIFO mode is disabled.\n1: FIFO mode is enabled.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode\nand in smartcard modes only. It must not be enabled in IrDA and LIN modes.\n"
              },
              {
                "range": "28",
                "field": "M1",
                "description": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or\ncleared by software.\nM[1:0] = â€˜00â€™: 1 start bit, 8 Data bits, n Stop bit\nM[1:0] = â€˜01â€™: 1 start bit, 9 Data bits, n Stop bit\nM[1:0] = â€˜10â€™: 1 start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In 7-bits data length mode, the smartcard mode, LIN master mode and auto baud rate\n(0x7F and 0x55 frames detection) are not supported.\n"
              },
              {
                "range": "27",
                "field": "EOBIE",
                "description": "End of Bbock interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the EOBF flag is set in the USART_ISR register\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "26",
                "field": "RTOIE",
                "description": "Receiver timeout interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the RTOF bit is set in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and\nmust be kept at reset value. Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "25:21",
                "field": "DEAT[4:0]",
                "description": "Driver enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and\nthe beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time,\ndepending on the oversampling rate).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n2630/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "20:16",
                "field": "DEDT[4:0]",
                "description": "Driver enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted\nmessage, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample\ntime units (1/8 or 1/16 bit time, depending on the oversampling rate).\nIf the USART_TDR register is written during the DEDT time, the new data is transmitted only\nwhen the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "15",
                "field": "OVER8",
                "description": "Oversampling mode\n0: Oversampling by 16\n1: Oversampling by 8\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In LIN, IrDA and smartcard modes, this bit must be kept cleared.\n"
              },
              {
                "range": "14",
                "field": "CMIE",
                "description": "Character match interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the CMF bit is set in the USART_ISR register.\n"
              },
              {
                "range": "13",
                "field": "MME",
                "description": "Mute mode enable\nThis bit enables the USART mute mode function. When set, the USART can switch between\nactive and mute mode, as defined by the WAKE bit. It is set and cleared by software.\n0: Receiver in active mode permanently\n1: Receiver can switch between mute mode and active mode.\n"
              },
              {
                "range": "12",
                "field": "M0",
                "description": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or\ncleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "11",
                "field": "WAKE",
                "description": "Receiver wake-up method\nThis bit determines the USART wake-up method from mute mode. It is set or cleared by\nsoftware.\n0: Idle line\n1: Address mark\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "10",
                "field": "PCE",
                "description": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity\ncontrol is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit\nif M=0) and the parity is checked on the received data. This bit is set and cleared by\nsoftware. Once it is set, PCE is active after the current byte (in reception and in\ntransmission).\n0: Parity control disabled\n1: Parity control enabled\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "9",
                "field": "PS",
                "description": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE\nbit set). It is set and cleared by software. The parity is selected after the current byte.\n0: Even parity\n1: Odd parity\nThis bitfield can only be written when the USART is disabled (UE=0).\nRM0436 Rev 7 2631/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "8",
                "field": "PEIE",
                "description": "PE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever PE=1 in the USART_ISR register\n"
              },
              {
                "range": "7",
                "field": "TXEIE",
                "description": "Transmit data register empty\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TXE =1 in the USART_ISR register\n"
              },
              {
                "range": "6",
                "field": "TCIE",
                "description": "Transmission complete interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TC=1 in the USART_ISR register\n"
              },
              {
                "range": "5",
                "field": "RXNEIE",
                "description": "Receive data register not empty\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever ORE=1 or RXNE=1 in the USART_ISR register\n"
              },
              {
                "range": "4",
                "field": "IDLEIE",
                "description": "IDLE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever IDLE=1 in the USART_ISR register\n"
              },
              {
                "range": "3",
                "field": "TE",
                "description": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\n0: Transmitter is disabled\n1: Transmitter is enabled\nNote: During transmission, a low pulse on the TE bit (â€˜0â€™ followed by â€˜1â€™) sends a preamble\n(idle line) after the current word, except in smartcard mode. In order to generate an idle\ncharacter, the TE must not be immediately written to â€˜1â€™. To ensure the required duration,\nthe software can poll the TEACK bit in the USART_ISR register.\nIn smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission\nstarts.\n"
              },
              {
                "range": "2",
                "field": "RE",
                "description": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software.\n0: Receiver is disabled\n1: Receiver is enabled and begins searching for a start bit\n"
              },
              {
                "range": "1",
                "field": "UESM",
                "description": "USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\n0: USART not able to wake up the MCU from low-power mode.\n1: USART able to wake up the MCU from low-power mode.\nNote: It is recommended to set the UESM bit just before entering low-power mode and clear it\nwhen exit from low-power mode.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n2632/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "0",
                "field": "UE",
                "description": "USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all\ncurrent operations are discarded. The USART configuration is kept, but all the USART_ISR\nstatus flags are reset. This bit is set and cleared by software.\n0: USART prescaler and outputs disabled, low-power mode\n1: USART enabled\nNote: To enter low-power mode without generating errors on the line, the TE bit must be\npreviously reset and the software must wait for the TC bit in the USART_ISR to be set\nbefore resetting the UE bit.\nThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled\nbefore resetting the UE bit.\nIn smartcard mode, (SCEN = 1), the CK pin is always available when CLKEN = 1,\nregardless of the UE bit value.\n"
              }
            ]
          },
          {
            "registername": "USART_CR2",
            "offset": "0x04",
            "page": 2633,
            "chapter": "53.8.3",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:24",
                "field": "ADD[7:0]",
                "description": "Address of the USART node\nThese bits give the address of the USART node in mute mode or a character code to be recognized\nin low-power or Run mode:\nâ€“ In mute mode: they are used in multiprocessor communication to wake up from mute mode\nwith 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter\nshould be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.\nâ€“ In low-power mode: they are used for wake up from low-power mode on character match.\nWhen WUS[1:0] is programmed to 0b00 (WUF active on address match), the wake-up\nfrom low-power mode is performed when the received character corresponds to the\ncharacter programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit),\nand WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by\ntransmitter should be equal to 1.\nâ€“ In Run mode with mute mode inactive (for example, end-of-block detection in ModBus\nprotocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF\nflag is set on match. An interrupt is generated if the CMIE bit is set.\nThese bits can only be written when the reception is disabled (RE=0) or when the USART is\ndisabled (UE=0).\nRM0436 Rev 7 2633/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "23",
                "field": "RTOEN",
                "description": "Receiver timeout enable\nThis bit is set and cleared by software.\n0: Receiver timeout feature disabled.\n1: Receiver timeout feature enabled.\nWhen this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle\n(no reception) for the duration programmed in the RTOR (receiver timeout register).\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "22:21",
                "field": "ABRMOD[1:0]",
                "description": "Auto baud rate mode\nThese bits are set and cleared by software.\n00: Measurement of the start bit is used to detect the baud rate.\n01: Falling edge to falling edge measurement (the received frame must start with a single bit = 1\nand Frame = Start10xxxxxx)\n10: 0x7F frame detection.\n11: 0x55 frame detection\nThis bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0).\nNote: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example\n0xAA for MSBFIRST)\nIf the USART does not support the auto baud rate feature, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "20",
                "field": "ABREN",
                "description": "Auto baud rate enable\nThis bit is set and cleared by software.\n0: Auto baud rate detection is disabled.\n1: Auto baud rate detection is enabled.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "19",
                "field": "MSBFIRST",
                "description": "Most significant bit first\nThis bit is set and cleared by software.\n0: data is transmitted/received with data bit 0 first, following the start bit.\n1: data is transmitted/received with the MSB (bit 7/8) first, following the start bit.\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "18",
                "field": "DATAINV",
                "description": "Binary data inversion\nThis bit is set and cleared by software.\n0: Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L)\n1: Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H).\nThe parity bit is also inverted.\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "17",
                "field": "TXINV",
                "description": "TX pin active level inversion\nThis bit is set and cleared by software.\n0: TX pin signal works using the standard logic levels (V =1/idle, Gnd=0/mark)\nDD\n1: TX pin signal values are inverted (V =0/mark, Gnd=1/idle).\nDD\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "16",
                "field": "RXINV",
                "description": "RX pin active level inversion\nThis bit is set and cleared by software.\n0: RX pin signal works using the standard logic levels (V =1/idle, Gnd=0/mark)\nDD\n1: RX pin signal values are inverted (V =0/mark, Gnd=1/idle).\nDD\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the USART is disabled (UE=0).\n2634/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "15",
                "field": "SWAP",
                "description": "Swap TX/RX pins\nThis bit is set and cleared by software.\n0: TX/RX pins are used as defined in standard pinout\n1: The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired\nconnection to another UART.\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "14",
                "field": "LINEN",
                "description": "LIN mode enable\nThis bit is set and cleared by software.\n0: LIN mode disabled\n1: LIN mode enabled\nThe LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the\nSBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "13:12",
                "field": "STOP[1:0]",
                "description": "Stop bits\nThese bits are used for programming the stop bits.\n00: 1 stop bit\n01: 0.5 stop bit.\n10: 2 stop bits\n11: 1.5 stop bits\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "11",
                "field": "CLKEN",
                "description": "Clock enable\nThis bit enables the user to enable the CK pin.\n0: CK pin disabled\n1: CK pin enabled\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If neither synchronous mode nor smartcard mode is supported, this bit is reserved and must\nbe kept at reset value. Refer to Section53.4: USART implementation on page2577.\nIn smartcard mode, in order to provide correctly the CK clock to the smartcard, the steps below\nmust be respected:\nUE = 0\nSCEN = 1\nGTPR configuration\nCLKEN= 1\nUE = 1\n"
              },
              {
                "range": "10",
                "field": "CPOL",
                "description": "Clock polarity\nThis bit enables the user to select the polarity of the clock output on the CK pin in synchronous\nmode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship\n0: Steady low value on CK pin outside transmission window\n1: Steady high value on CK pin outside transmission window\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If synchronous mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\nRM0436 Rev 7 2635/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "9",
                "field": "CPHA",
                "description": "Clock phase\nThis bit is used to select the phase of the clock output on the CK pin in synchronous mode. It works\nin conjunction with the CPOL bit to produce the desired clock/data relationship (see Figure589 and\nFigure590)\n0: The first clock transition is the first data capture edge\n1: The second clock transition is the first data capture edge\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If synchronous mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "8",
                "field": "LBCL",
                "description": "Last bit clock pulse\nThis bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB)\nhas to be output on the CK pin in synchronous mode.\n0: The clock pulse of the last data bit is not output to the CK pin\n1: The clock pulse of the last data bit is output to the CK pin\nCaution: The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit\nformat selected by the M bit in the USART_CR1 register.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If synchronous mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "LBDIE",
                "description": "LIN break detection interrupt enable\nBreak interrupt mask (break detection using break delimiter).\n0: Interrupt is inhibited\n1: An interrupt is generated whenever LBDF=1 in the USART_ISR register\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to\nSection53.4: USART implementation on page2577.\n"
              },
              {
                "range": "5",
                "field": "LBDL",
                "description": "LIN break detection length\nThis bit is for selection between 11 bit or 10 bit break detection.\n0: 10-bit break detection\n1: 11-bit break detection\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to\nSection53.4: USART implementation on page2577.\n"
              },
              {
                "range": "4",
                "field": "ADDM7",
                "description": "7-bit address detection/4-bit address detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\n0: 4-bit address detection\n1: 7-bit address detection (in 8-bit data mode)\nThis bit can only be written when the USART is disabled (UE=0)\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address\n(ADD[5:0] and ADD[7:0]) respectively.\n"
              },
              {
                "range": "3",
                "field": "DIS_NSS",
                "description": "NSS pin enable\nWhen the DIS_NSS bit is set, the NSS pin input is ignored.\n0: SPI slave selection depends on NSS input pin.\n1: SPI slave is always selected and NSS input pin is ignored.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "2:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n2636/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "0",
                "field": "SLVEN",
                "description": "Synchronous slave mode enable\nWhen the SLVEN bit is set, the synchronous slave mode is enabled.\n0: Slave mode disabled.\n1: Slave mode enabled.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\nNote: The CPOL, CPHA and LBCL bits should not be written while the transmitter is enabled.\n"
              }
            ]
          },
          {
            "registername": "USART_CR3",
            "offset": "0x08",
            "page": 2637,
            "chapter": "53.8.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:29",
                "field": "TXFTCFG[2:0]",
                "description": "TXFIFO threshold configuration\n000:TXFIFO reaches 1/8 of its depth\n001:TXFIFO reaches 1/4 of its depth\n010:TXFIFO reaches 1/2 of its depth\n011:TXFIFO reaches 3/4 of its depth\n100:TXFIFO reaches 7/8 of its depth\n101:TXFIFO becomes empty\nRemaining combinations: Reserved\n"
              },
              {
                "range": "28",
                "field": "RXFTIE",
                "description": "RXFIFO threshold interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when Receive FIFO reaches the threshold programmed in\nRXFTCFG.\n"
              },
              {
                "range": "27:25",
                "field": "RXFTCFG[2:0]",
                "description": "Receive FIFO threshold configuration\n000:Receive FIFO reaches 1/8 of its depth\n001:Receive FIFO reaches 1/4 of its depth\n010:Receive FIFO reaches 1/2 of its depth\n011:Receive FIFO reaches 3/4 of its depth\n100:Receive FIFO reaches 7/8 of its depth\n101:Receive FIFO becomes full\nRemaining combinations: Reserved\n"
              },
              {
                "range": "24",
                "field": "TCBGTIE",
                "description": "Transmission complete before guard time, interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TCBGT=1 in the USART_ISR register\nNote: If the USART does not support the smartcard mode, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\nRM0436 Rev 7 2637/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "23",
                "field": "TXFTIE",
                "description": "TXFIFO threshold interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when TXFIFO reaches the threshold programmed in\nTXFTCFG.\n"
              },
              {
                "range": "22",
                "field": "WUFIE",
                "description": "Wake-up from low-power mode interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever WUF=1 in the USART_ISR register\nNote: WUFIE must be set before entering in low-power mode.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "21:20",
                "field": "WUS[1:0]",
                "description": "Wake-up from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (wake-up from low-power mode\nflag).\n00: WUF active on address match (as defined by ADD[7:0] and ADDM7)\n01: Reserved.\n10: WUF active on start bit detection\n11: WUF active on RXNE/RXFNE.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "19:17",
                "field": "SCARCNT[2:0]",
                "description": "Smartcard auto-retry count\nThis bitfield specifies the number of retries for transmission and reception in smartcard\nmode.\nIn transmission mode, it specifies the number of automatic retransmission retries, before\ngenerating a transmission error (FE bit set).\nIn reception mode, it specifies the number or erroneous reception trials, before generating a\nreception error (RXNE/RXFNE and PE bits set).\nThis bitfield must be programmed only when the USART is disabled (UE=0).\nWhen the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to\nstop retransmission.\n0x0: retransmission disabled - No automatic retransmission in transmit mode.\n0x1 to 0x7: number of automatic retransmission attempts (before signaling error)\nNote: If smartcard mode is not supported, this bit is reserved and must be kept at reset\nvalue. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "DEP",
                "description": "Driver enable polarity selection\n0: DE signal is active high.\n1: DE signal is active low.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n2638/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "14",
                "field": "DEM",
                "description": "Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\n0: DE function is disabled.\n1: DE function is enabled. The DE signal is output on the RTS pin.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "13",
                "field": "DDRE",
                "description": "DMA Disable on reception error\n0: DMA is not disabled in case of reception error. The corresponding error flag is set but\nRXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not\nasserted, so the erroneous data is not transferred (no DMA request), but next correct\nreceived data is transferred (used for smartcard mode).\n1: DMA is disabled following a reception error. The corresponding error flag is set, as well\nas RXNE. The DMA request is masked until the error flag is cleared. This means that the\nsoftware must first disable the DMA request (DMAR = 0) or clear RXNE/RXFNE is case\nFIFO mode is enabled) before clearing the error flag.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error.\n"
              },
              {
                "range": "12",
                "field": "OVRDIS",
                "description": "Overrun disable\nThis bit is used to disable the receive overrun detection.\n0: Overrun Error Flag, ORE, is set when received data is not read before receiving new\ndata.\n1: Overrun functionality is disabled. If new data is received while the RXNE flag is still set\nthe ORE flag is not set and the new received data overwrites the previous content of the\nUSART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is\nwritten directly in USART_RDR register. Even when FIFO management is enabled, the\nRXNE flag is to be used.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: This control bit enables checking the communication flow w/o reading the data\n"
              },
              {
                "range": "11",
                "field": "ONEBIT",
                "description": "One sample bit method enable\nThis bit enables the user to select the sample method. When the one sample bit method is\nselected the noise detection flag (NE) is disabled.\n0: Three sample bit method\n1: One sample bit method\nThis bit can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "10",
                "field": "CTSIE",
                "description": "CTS interrupt enable\n0: Interrupt is inhibited\n1: An interrupt is generated whenever CTSIF=1 in the USART_ISR register\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "9",
                "field": "CTSE",
                "description": "CTS enable\n0: CTS hardware flow control disabled\n1: CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0).\nIf the CTS input is asserted while data is being transmitted, then the transmission is\ncompleted before stopping. If data is written into the data register while CTS is asserted, the\ntransmission is postponed until CTS is deasserted.\nThis bit can only be written when the USART is disabled (UE=0)\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\nRM0436 Rev 7 2639/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "8",
                "field": "RTSE",
                "description": "RTS enable\n0: RTS hardware flow control disabled\n1: RTS output enabled, data is only requested when there is space in the receive buffer. The\ntransmission of data is expected to cease after the current character has been transmitted.\nThe RTS output is deasserted (pulled to 0) when data can be received.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "DMAT",
                "description": "DMA enable transmitter\nThis bit is set/reset by software\n1: DMA mode is enabled for transmission\n0: DMA mode is disabled for transmission\n"
              },
              {
                "range": "6",
                "field": "DMAR",
                "description": "DMA enable receiver\nThis bit is set/reset by software\n1: DMA mode is enabled for reception\n0: DMA mode is disabled for reception\n"
              },
              {
                "range": "5",
                "field": "SCEN",
                "description": "Smartcard mode enable\nThis bit is used for enabling smartcard mode.\n0: Smartcard mode disabled\n1: Smartcard mode enabled\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "4",
                "field": "NACK",
                "description": "Smartcard NACK enable\n0: NACK transmission in case of parity error is disabled\n1: NACK transmission during parity error is enabled\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "3",
                "field": "HDSEL",
                "description": "Half-duplex selection\nSelection of single-wire half-duplex mode\n0: Half duplex mode is not selected\n1: Half duplex mode is selected\nThis bit can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "2",
                "field": "IRLP",
                "description": "IrDA low-power\nThis bit is used for selecting between normal and low-power IrDA modes\n0: Normal mode\n1: Low-power mode\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "1",
                "field": "IREN",
                "description": "IrDA mode enable\nThis bit is set and cleared by software.\n0: IrDA disabled\n1: IrDA enabled\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n2640/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "0",
                "field": "EIE",
                "description": "Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing\nerror, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1 or\nUDR = 1 in the USART_ISR register).\n0: Interrupt inhibited\n1: interrupt generated when FE=1 or ORE=1 or NE=1 or UDR = 1 (in SPI slave mode) in\nthe USART_ISR register.\n"
              }
            ]
          },
          {
            "registername": "USART_BRR",
            "offset": "0x0C",
            "page": 2641,
            "chapter": "53.8.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "BRR[15:0]",
                "description": "USART baud rate\nBRR[15:4]\nBRR[15:4] = USARTDIV[15:4]\nBRR[3:0]\nWhen OVER8 = 0, BRR[3:0] = USARTDIV[3:0].\nWhen OVER8 = 1:\nBRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.\nBRR[3] must be kept cleared.\n"
              }
            ]
          },
          {
            "registername": "USART_GTPR",
            "offset": "0x10",
            "page": 2641,
            "chapter": "53.8.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2641/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "15:8",
                "field": "GT[7:0]",
                "description": "Guard time value\nThis bitfield is used to program the Guard time value in terms of number of baud clock\nperiods.\nThis is used in smartcard mode. The Transmission Complete flag is set after this guard time\nvalue.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If smartcard mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7:0",
                "field": "PSC[7:0]",
                "description": "Prescaler value\nIn IrDA low-power and normal IrDA mode:\nPSC[7:0] = IrDA normal and low-power baud rate\nPSC[7:0] is used to program the prescaler for dividing the USART source clock to achieve\nthe low-power frequency: the source clock is divided by the value given in the register (8\nsignificant bits):\nIn smartcard mode:\nPSC[4:0]=Prescaler value\nPSC[4:0] is used to program the prescaler for dividing the USART source clock to provide\nthe smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to\ngive the division factor of the source clock frequency:\n00000: Reserved - do not program this value\n00001: Divides the source clock by 1 (IrDA mode) / by 2 (smartcard mode)\n00010: Divides the source clock by 2 (IrDA mode) / by 4 (smartcard mode)\n00011: Divides the source clock by 3 (IrDA mode) / by 6 (smartcard mode)\n...\n11111: Divides the source clock by 31 (IrDA mode) / by 62 (smartcard mode)\n00100000: Divides the source clock by 32 (IrDA mode)\n...\n11111111: Divides the source clock by 255 (IrDA mode)\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: Bits [7:5] must be kept cleared if smartcard mode is used.\nThis bitfield is reserved and forced by hardware to â€˜0â€™ when the smartcard and IrDA\nmodes are not supported. Refer to Section53.4: USART implementation on page2577.\n"
              }
            ]
          },
          {
            "registername": "USART_RTOR",
            "offset": "0x14",
            "page": 2642,
            "chapter": "53.8.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:24",
                "field": "BLEN[7:0]",
                "description": "Block length\nThis bitfield gives the Block length in smartcard T=1 Reception. Its value equals the number\nof information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.\nExamples:\nBLEN = 0: 0 information characters + LEC\nBLEN = 1: 0 information characters + CRC\nBLEN = 255: 254 information characters + CRC (total 256 characters))\nIn smartcard mode, the Block length counter is reset when TXE=0 (TXFE = 0 in case FIFO\nmode is enabled).\nThis bitfield can be used also in other modes. In this case, the Block length counter is reset\nwhen RE=0 (receiver disabled) and/or when the EOBCF bit is written to 1.\nNote: This value can be programmed after the start of the block reception (using the data\nfrom the LEN character in the Prologue Field). It must be programmed only once per\nreceived block.\n"
              },
              {
                "range": "23:0",
                "field": "RTO[23:0]",
                "description": "Receiver timeout value\nThis bitfield gives the Receiver timeout value in terms of number of bits during which there is\nno activity on the RX line.\nIn standard mode, the RTOF flag is set if, after the last received character, no new start bit is\ndetected for more than the RTO value.\nIn smartcard mode, this value is used to implement the CWT and BWT. See smartcard\nchapter for more details. In the standard, the CWT/BWT measurement is done starting from\nthe start bit of the last received character.\nNote: This value must only be programmed once per received character.\nNote: RTOR can be written on-the-fly. If the new value is lower than or equal to the counter, the\nRTOF flag is set.\nThis register is reserved and forced by hardware to â€œ0x00000000â€ when the Receiver\ntimeout feature is not supported. Refer to Section53.4: USART implementation on page2577.\n"
              }
            ]
          },
          {
            "registername": "USART_RQR",
            "offset": "0x18",
            "page": 2643,
            "chapter": "53.8.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2643/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "4",
                "field": "TXFRQ",
                "description": "Transmit data flush request\nWhen FIFO mode is disabled, writing â€˜1â€™ to this bit sets the TXE flag. This enables to discard\nthe transmit data. This bit must be used only in smartcard mode, when data have not been\nsent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the\nUSART does not support smartcard mode, this bit is reserved and must be kept at reset\nvalue.\nWhen FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag\n(Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is\nsupported in both UART and smartcard modes.\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in\norder to ensure that no data are written in the data register.\n"
              },
              {
                "range": "3",
                "field": "RXFRQ",
                "description": "Receive data flush request\nWriting 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.\nThis enables to discard the received data without reading them, and avoid an overrun\ncondition.\n"
              },
              {
                "range": "2",
                "field": "MMRQ",
                "description": "Mute mode request\nWriting 1 to this bit puts the USART in mute mode and resets the RWU flag.\n"
              },
              {
                "range": "1",
                "field": "SBKRQ",
                "description": "Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as\nthe transmit machine is available.\nNote: When the application needs to send the break character following all previously\ninserted data, including the ones not yet transmitted, the software should wait for the\nTXE flag assertion before setting the SBKRQ bit.\n"
              },
              {
                "range": "0",
                "field": "ABRRQ",
                "description": "Auto baud rate request\nWriting 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an\nautomatic baud rate measurement on the next received data frame.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must\nbe kept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              }
            ]
          },
          {
            "registername": "USART_ISR",
            "offset": "0x1C",
            "page": 2644,
            "chapter": "53.8.9",
            "resetvalue": "0x0x8000c0",
            "bits": [
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27",
                "field": "TXFT",
                "description": "TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in\nTXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An\ninterrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register.\n0: TXFIFO does not reach the programmed threshold.\n1: TXFIFO reached the programmed threshold.\n"
              },
              {
                "range": "26",
                "field": "RXFT",
                "description": "RXFIFO threshold flag\nThis bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3\nregister is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and\none data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit\n27) in the USART_CR3 register.\n0: Receive FIFO does not reach the programmed threshold.\n1: Receive FIFO reached the programmed threshold.\nNote: When the RXFTCFG threshold is configured to â€˜101â€™, RXFT flag is set if 16 data are\navailable i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the\n17th received data does not cause an overrun error. The overrun error occurs after\nreceiving the 18th data.\n"
              },
              {
                "range": "25",
                "field": "TCBGT",
                "description": "Transmission complete before guard time flag\nThis bit is set when the last data written in the USART_TDR has been transmitted correctly\nout of the shift register.\nIt is set by hardware in smartcard mode, if the transmission of a frame containing data is\ncomplete and if the smartcard did not send back any NACK. An interrupt is generated if\nTCBGTIE=1 in the USART_CR3 register.\nThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or\nby a write to the USART_TDR register.\n0: Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is\nreceived from the card)\n1: Transmission is complete successfully (before Guard time completion and there is no\nNACK from the smart card).\nNote: If the USART does not support the smartcard mode, this bit is reserved and kept at\nreset value. If the USART supports the smartcard mode and the smartcard mode is\nenabled, the TCBGT reset value is â€˜1â€™. Refer to Section53.4: USART implementation\non page2577.\n"
              },
              {
                "range": "24",
                "field": "RXFF",
                "description": "RXFIFO full\nThis bit is set by hardware when the number of received data corresponds to\nRXFIFOsize+1 (RXFIFO full + 1 data in the USART_RDR register.\nAn interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register.\n0: RXFIFO not full.\n1: RXFIFO Full.\n"
              },
              {
                "range": "23",
                "field": "TXFE",
                "description": "TXFIFO empty\nThis bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one\ndata, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4)\nin the USART_RQR register.\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register.\n0: TXFIFO not empty.\n1: TXFIFO empty.\nRM0436 Rev 7 2645/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "22",
                "field": "REACK",
                "description": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by\nthe USART.\nIt can be used to verify that the USART is ready for reception before entering low-power\nmode.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "21",
                "field": "TEACK",
                "description": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by\nthe USART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by\nTE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period.\n"
              },
              {
                "range": "20",
                "field": "WUF",
                "description": "Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the\nWUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE=1 in the USART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "19",
                "field": "RWU",
                "description": "Receiver wake-up from mute mode\nThis bit indicates if the USART is in mute mode. It is cleared/set by hardware when a wake-\nup/mute sequence is recognized. The mute mode control sequence (address or IDLE) is\nselected by the WAKE bit in the USART_CR1 register.\nWhen wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to\nthe MMRQ bit in the USART_RQR register.\n0: Receiver in active mode\n1: Receiver in mute mode\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "18",
                "field": "SBKF",
                "description": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing\n1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during\nthe stop bit of break transmission.\n0: Break character transmitted\n1: Break character requested by setting SBKRQ bit in USART_RQR register\n"
              },
              {
                "range": "17",
                "field": "CMF",
                "description": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is\ncleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE=1in the USART_CR1 register.\n0: No Character match detected\n1: Character Match detected\n"
              },
              {
                "range": "16",
                "field": "BUSY",
                "description": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the\nRX line (successful start bit detected). It is reset at the end of the reception (successful or\nnot).\n0: USART is idle (no reception)\n1: Reception on going\n2646/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "15",
                "field": "ABRF",
                "description": "Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXFNE is also set,\ngenerating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was\ncompleted without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case)\nIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to\nthe ABRRQ in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept\nat reset value.\n"
              },
              {
                "range": "14",
                "field": "ABRE",
                "description": "Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or\ncharacter comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept\nat reset value.\n"
              },
              {
                "range": "13",
                "field": "UDR",
                "description": "SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission\nappears while the software has not yet loaded any value into USART_TDR. This flag is\nreset by setting UDRCF bit in the USART_ICR register.\n0: No underrun error\n1: underrun error\nNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "12",
                "field": "EOBF",
                "description": "End of block flag\nThis bit is set by hardware when a complete block has been received (for example T=1\nsmartcard mode). The detection is done when the number of received bytes (from the start\nof the block, including the prologue) is equal or greater than BLEN + 4.\nAn interrupt is generated if the EOBIE=1 in the USART_CR1 register.\nIt is cleared by software, writing 1 to the EOBCF in the USART_ICR register.\n0: End of Block not reached\n1: End of Block (number of characters) reached\nNote: If smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to\nSection53.4: USART implementation on page2577.\n"
              },
              {
                "range": "11",
                "field": "RTOF",
                "description": "Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has\nlapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in\nthe USART_ICR register.\nAn interrupt is generated if RTOIE=1 in the USART_CR2 register.\nIn smartcard mode, the timeout corresponds to the CWT or BWT timings.\n0: Timeout value not reached\n1: Timeout value reached without any data reception\nNote: If a time equal to the value programmed in RTOR register separates 2 characters,\nRTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8,\ndepending on the oversampling method), RTOF flag is set.\nThe counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has\nalready elapsed when RE is set, then RTOF is set.\nIf the USART does not support the Receiver timeout feature, this bit is reserved and\nkept at reset value.\nRM0436 Rev 7 2647/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "10",
                "field": "CTS",
                "description": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\n0: CTS line set\n1: CTS line reset\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at\nreset value.\n"
              },
              {
                "range": "9",
                "field": "CTSIF",
                "description": "CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by\nsoftware, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE=1 in the USART_CR3 register.\n0: No change occurred on the CTS status line\n1: A change occurred on the CTS status line\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at\nreset value.\n"
              },
              {
                "range": "8",
                "field": "LBDF",
                "description": "LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by\nwriting 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\n0: LIN Break not detected\n1: LIN break detected\nNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "TXFNF",
                "description": "TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the\nUSART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO.\nThis flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared\nindicating that data can not be written into the USART_TDR.\nAn interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.\n0: Transmit FIFO is full\n1: Transmit FIFO is not full\nNote: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending\nthe flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to\nwriting in TXFIFO (TXFNF and TXFE are set at the same time).\nThis bit is used during single buffer transmission.\n"
              },
              {
                "range": "6",
                "field": "TC",
                "description": "Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of\nthe shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and\nwhen TXFE is set.\nAn interrupt is generated if TCIE=1 in the USART_CR1 register.\nTC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a\nwrite to the USART_TDR register.\n0: Transmission is not complete\n1: Transmission is complete\nNote: If TE bit is reset and no transmission is on going, the TC bit is immediately set.\n2648/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "5",
                "field": "RXFNE",
                "description": "RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be\nread from the USART_RDR register. Every read operation from the USART_RDR frees a\nlocation in the RXFIFO.\nRXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by\nwriting 1 to the RXFRQ in the USART_RQR register.\nAn interrupt is generated if RXFNEIE=1 in the USART_CR1 register.\n0: Data is not received\n1: Received data is ready to be read.\n"
              },
              {
                "range": "4",
                "field": "IDLE",
                "description": "Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if\nIDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in\nthe USART_ICR register.\n0: No Idle line is detected\n1: Idle line is detected\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line\noccurs).\nIf mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0),\nwhatever the mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.\n"
              },
              {
                "range": "3",
                "field": "ORE",
                "description": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a\nsoftware, writing 1 to the ORECF, in the USART_ICR register.\nAn interrupt is generated if RXFNEIE=1 in the USART_CR1 register, or EIE = 1 in the\nUSART_CR3 register.\n0: No overrun error\n1: Overrun error is detected\nNote: When this bit is set, the USART_RDR register content is not lost but the shift register is\noverwritten. An interrupt is generated if the ORE flag is set during multi buffer\ncommunication if the EIE bit is set.\nThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in\nthe USART_CR3 register.\n"
              },
              {
                "range": "2",
                "field": "NE",
                "description": "Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by\nsoftware, writing 1 to the NECF bit in the USART_ICR register.\n0: No noise is detected\n1: Noise is detected\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit\nwhich itself generates an interrupt. An interrupt is generated when the NE flag is set\nduring multi buffer communication if the EIE bit is set.\nWhen the line is noise-free, the NE flag can be disabled by programming the ONEBIT\nbit to 1 to increase the USART tolerance to deviations (Refer to Section53.5.8:\nTolerance of the USART receiver to clock deviation on page2594).\nThis error is associated with the character in the USART_RDR.\nRM0436 Rev 7 2649/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "1",
                "field": "FE",
                "description": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character\nis detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in smartcard mode, this bit is set when the maximum number of\ntransmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE=1 in the USART_CR3 register.\n0: No Framing error is detected\n1: Framing error or break character is detected\nNote: This error is associated with the character in the USART_RDR.\n"
              },
              {
                "range": "0",
                "field": "PE",
                "description": "Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by\nsoftware, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\n0: No parity error\n1: Parity error\nNote: This error is associated with the character in the USART_RDR.\n"
              }
            ]
          },
          {
            "registername": "USART_ISR-alternate",
            "offset": "0x1C",
            "page": 2650,
            "chapter": "53.8.10",
            "resetvalue": "0x000000c0",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25",
                "field": "TCBGT",
                "description": "Transmission complete before guard time flag\nThis bit is set when the last data written in the USART_TDR has been transmitted correctly\nout of the shift register.\nIt is set by hardware in smartcard mode, if the transmission of a frame containing data is\ncomplete and if the smartcard did not send back any NACK. An interrupt is generated if\nTCBGTIE=1 in the USART_CR3 register.\nThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or\nby a write to the USART_TDR register.\n0: Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is\nreceived from the card)\n1: Transmission is complete successfully (before Guard time completion and there is no\nNACK from the smart card).\nNote: If the USART does not support the smartcard mode, this bit is reserved and kept at\nreset value. If the USART supports the smartcard mode and the smartcard mode is\nenabled, the TCBGT reset value is â€˜1â€™. Refer to Section53.4: USART implementation\non page2577.\n"
              },
              {
                "range": "24:23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22",
                "field": "REACK",
                "description": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by\nthe USART.\nIt can be used to verify that the USART is ready for reception before entering low-power\nmode.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "21",
                "field": "TEACK",
                "description": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by\nthe USART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by\nTE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period.\n"
              },
              {
                "range": "20",
                "field": "WUF",
                "description": "Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the\nWUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE=1 in the USART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "19",
                "field": "RWU",
                "description": "Receiver wake-up from mute mode\nThis bit indicates if the USART is in mute mode. It is cleared/set by hardware when a wake-\nup/mute sequence is recognized. The mute mode control sequence (address or IDLE) is\nselected by the WAKE bit in the USART_CR1 register.\nWhen wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to\nthe MMRQ bit in the USART_RQR register.\n0: Receiver in active mode\n1: Receiver in mute mode\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\nRM0436 Rev 7 2651/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "18",
                "field": "SBKF",
                "description": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing\n1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during\nthe stop bit of break transmission.\n0: Break character transmitted\n1: Break character requested by setting SBKRQ bit in USART_RQR register\n"
              },
              {
                "range": "17",
                "field": "CMF",
                "description": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is\ncleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE=1in the USART_CR1 register.\n0: No Character match detected\n1: Character Match detected\n"
              },
              {
                "range": "16",
                "field": "BUSY",
                "description": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the\nRX line (successful start bit detected). It is reset at the end of the reception (successful or\nnot).\n0: USART is idle (no reception)\n1: Reception on going\n"
              },
              {
                "range": "15",
                "field": "ABRF",
                "description": "Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXNE is also set,\ngenerating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed\nwithout success (ABRE=1) (ABRE, RXNE and FE are also set in this case)\nIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to\nthe ABRRQ in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept\nat reset value.\n"
              },
              {
                "range": "14",
                "field": "ABRE",
                "description": "Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or\ncharacter comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept\nat reset value.\n"
              },
              {
                "range": "13",
                "field": "UDR",
                "description": "SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission\nappears while the software has not yet loaded any value into USART_TDR. This flag is\nreset by setting UDRCF bit in the USART_ICR register.\n0: No underrun error\n1: underrun error\nNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "12",
                "field": "EOBF",
                "description": "End of block flag\nThis bit is set by hardware when a complete block has been received (for example T=1\nsmartcard mode). The detection is done when the number of received bytes (from the start\nof the block, including the prologue) is equal or greater than BLEN + 4.\nAn interrupt is generated if the EOBIE=1 in the USART_CR1 register.\nIt is cleared by software, writing 1 to the EOBCF in the USART_ICR register.\n0: End of Block not reached\n1: End of Block (number of characters) reached\nNote: If smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to\nSection53.4: USART implementation on page2577.\n2652/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "11",
                "field": "RTOF",
                "description": "Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has\nlapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in\nthe USART_ICR register.\nAn interrupt is generated if RTOIE=1 in the USART_CR2 register.\nIn smartcard mode, the timeout corresponds to the CWT or BWT timings.\n0: Timeout value not reached\n1: Timeout value reached without any data reception\nNote: If a time equal to the value programmed in RTOR register separates 2 characters,\nRTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8,\ndepending on the oversampling method), RTOF flag is set.\nThe counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has\nalready elapsed when RE is set, then RTOF is set.\nIf the USART does not support the Receiver timeout feature, this bit is reserved and\nkept at reset value.\n"
              },
              {
                "range": "10",
                "field": "CTS",
                "description": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\n0: CTS line set\n1: CTS line reset\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at\nreset value.\n"
              },
              {
                "range": "9",
                "field": "CTSIF",
                "description": "CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by\nsoftware, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE=1 in the USART_CR3 register.\n0: No change occurred on the CTS status line\n1: A change occurred on the CTS status line\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at\nreset value.\n"
              },
              {
                "range": "8",
                "field": "LBDF",
                "description": "LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by\nwriting 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\n0: LIN Break not detected\n1: LIN break detected\nNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "TXE",
                "description": "Transmit data register empty\nTXE is set by hardware when the content of the USART_TDR register has been transferred\ninto the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can\nalso be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the\ndata (only in smartcard T=0 mode, in case of transmission failure).\nAn interrupt is generated if the TXEIE bit =1 in the USART_CR1 register.\n0: Data register full\n1: Data register not full\nRM0436 Rev 7 2653/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "6",
                "field": "TC",
                "description": "Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of\nthe shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and\nwhen TXE is set.\nAn interrupt is generated if TCIE=1 in the USART_CR1 register.\nTC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a\nwrite to the USART_TDR register.\n0: Transmission is not complete\n1: Transmission is complete\nNote: If TE bit is reset and no transmission is on going, the TC bit is set immediately.\n"
              },
              {
                "range": "5",
                "field": "RXNE",
                "description": "Read data register not empty\nRXNE bit is set by hardware when the content of the USART_RDR shift register has been\ntransferred to the USART_RDR register. It is cleared by reading from the USART_RDR\nregister. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR\nregister.\nAn interrupt is generated if RXNEIE=1 in the USART_CR1 register.\n0: Data is not received\n1: Received data is ready to be read.\n"
              },
              {
                "range": "4",
                "field": "IDLE",
                "description": "Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if\nIDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in\nthe USART_ICR register.\n0: No Idle line is detected\n1: Idle line is detected\nNote: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line\noccurs).\nIf mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0),\nwhatever the mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.\n"
              },
              {
                "range": "3",
                "field": "ORE",
                "description": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXNE=1. It is cleared by a\nsoftware, writing 1 to the ORECF, in the USART_ICR register.\nAn interrupt is generated if RXNEIE=1 or EIE = 1 in the LPUART_CR1 register, or EIE = 1\nin the USART_CR3 register.\n0: No overrun error\n1: Overrun error is detected\nNote: When this bit is set, the USART_RDR register content is not lost but the shift register is\noverwritten. An interrupt is generated if the ORE flag is set during multi buffer\ncommunication if the EIE bit is set.\nThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in\nthe USART_CR3 register.\n2654/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "2",
                "field": "NE",
                "description": "Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by\nsoftware, writing 1 to the NECF bit in the USART_ICR register.\n0: No noise is detected\n1: Noise is detected\nNote: This bit does not generate an interrupt as it appears at the same time as the RXNE bit\nwhich itself generates an interrupt. An interrupt is generated when the NE flag is set\nduring multi buffer communication if the EIE bit is set.\nWhen the line is noise-free, the NE flag can be disabled by programming the ONEBIT\nbit to 1 to increase the USART tolerance to deviations (Refer to Section53.5.8:\nTolerance of the USART receiver to clock deviation on page2594).\n"
              },
              {
                "range": "1",
                "field": "FE",
                "description": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character\nis detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in smartcard mode, this bit is set when the maximum number of\ntransmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE=1 in the USART_CR3 register.\n0: No Framing error is detected\n1: Framing error or break character is detected\n"
              },
              {
                "range": "0",
                "field": "PE",
                "description": "Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by\nsoftware, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\n0: No parity error\n1: Parity error\n"
              }
            ]
          },
          {
            "registername": "USART_ICR",
            "offset": "0x20",
            "page": 2655,
            "chapter": "53.8.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20",
                "field": "WUCF",
                "description": "Wake-up from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the USART_ISR register.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "19:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17",
                "field": "CMCF",
                "description": "Character match clear flag\nWriting 1 to this bit clears the CMF flag in the USART_ISR register.\nRM0436 Rev 7 2655/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "16:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13",
                "field": "UDRCF",
                "description": "SPI slave underrun clear flag\nWriting 1 to this bit clears the UDRF flag in the USART_ISR register.\nNote: If the USART does not support SPI slave mode, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577\n"
              },
              {
                "range": "12",
                "field": "EOBCF",
                "description": "End of block clear flag\nWriting 1 to this bit clears the EOBF flag in the USART_ISR register.\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "11",
                "field": "RTOCF",
                "description": "Receiver timeout clear flag\nWriting 1 to this bit clears the RTOF flag in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9",
                "field": "CTSCF",
                "description": "CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the USART_ISR register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "8",
                "field": "LBDCF",
                "description": "LIN break detection clear flag\nWriting 1 to this bit clears the LBDF flag in the USART_ISR register.\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer\nto Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "TCBGTCF",
                "description": "Transmission complete before Guard time clear flag\nWriting 1 to this bit clears the TCBGT flag in the USART_ISR register.\n"
              },
              {
                "range": "6",
                "field": "TCCF",
                "description": "Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the USART_ISR register.\n"
              },
              {
                "range": "5",
                "field": "TXFECF",
                "description": "TXFIFO empty clear flag\nWriting 1 to this bit clears the TXFE flag in the USART_ISR register.\n"
              },
              {
                "range": "4",
                "field": "IDLECF",
                "description": "Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the USART_ISR register.\n"
              },
              {
                "range": "3",
                "field": "ORECF",
                "description": "Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the USART_ISR register.\n"
              },
              {
                "range": "2",
                "field": "NECF",
                "description": "Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the USART_ISR register.\n"
              },
              {
                "range": "1",
                "field": "FECF",
                "description": "Framing error clear flag\nWriting 1 to this bit clears the FE flag in the USART_ISR register.\n"
              },
              {
                "range": "0",
                "field": "PECF",
                "description": "Parity error clear flag\nWriting 1 to this bit clears the PE flag in the USART_ISR register.\n2656/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              }
            ]
          },
          {
            "registername": "USART_RDR",
            "offset": "0x24",
            "page": 2657,
            "chapter": "53.8.12",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8:0",
                "field": "RDR[8:0]",
                "description": "Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the\ninternal bus (see Figure583).\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity\nbit.\n"
              }
            ]
          },
          {
            "registername": "USART_TDR",
            "offset": "0x28",
            "page": 2657,
            "chapter": "53.8.13",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8:0",
                "field": "TDR[8:0]",
                "description": "Transmit data value\nContains the data character to be transmitted.\nThe USART_TDR register provides the parallel interface between the internal bus and the\noutput shift register (see Figure583).\nWhen transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register),\nthe value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect\nbecause it is replaced by the parity.\nNote: This register must be written only when TXE/TXFNF=1.\nRM0436 Rev 7 2657/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              }
            ]
          },
          {
            "registername": "USART_PRESC",
            "offset": "0x2C",
            "page": 2658,
            "chapter": "53.8.14",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "PRESCALER[3:0]",
                "description": "Clock prescaler\nThe USART input clock can be divided by a prescaler factor:\n0000: input clock not divided\n0001: input clock divided by 2\n0010: input clock divided by 4\n0011: input clock divided by 6\n0100: input clock divided by 8\n0101: input clock divided by 10\n0110: input clock divided by 12\n0111: input clock divided by 16\n1000: input clock divided by 32\n1001: input clock divided by 64\n1010: input clock divided by 128\n1011: input clock divided by 256\nRemaining combinations: Reserved\nNote: When PRESCALER is programmed with a value different of the allowed ones,\nprogrammed prescaler value is 1011 i.e. input clock divided by 256.\nIf the prescaler is not supported, this bitfield is reserved and must be kept at reset\nvalue. Refer to Section53.4: USART implementation on page2577.\n"
              }
            ]
          },
          {
            "registername": "USART_HWCFGR2",
            "offset": "0x3EC",
            "page": 2658,
            "chapter": "53.8.15",
            "resetvalue": "0x00000014",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "CFG2[3:0]",
                "description": "USART hardware configuration 2\nCFG2[3:0] = SPI_SLAVE\n"
              },
              {
                "range": "3:0",
                "field": "CFG1[3:0]",
                "description": "USART hardware configuration 1\nCFG1[3:0] = LOG_FIFO_DEPTH_RX\nRXFIFO size = 2LOG_FIFO_DEPTH_RX\n"
              }
            ]
          },
          {
            "registername": "USART_HWCFGR1",
            "offset": "0x3F0",
            "page": 2659,
            "chapter": "53.8.16",
            "resetvalue": "0x4011x11x",
            "bits": [
              {
                "range": "31:28",
                "field": "CFG8[3:0]",
                "description": "USART hardware configuration 8\nCFG8[3:0] = LOG_FIFO_DEPTH_TX\nTXFIFO size = 2LOG_FIFO_DEPTH_TX\n"
              },
              {
                "range": "27:24",
                "field": "CFG7[3:0]",
                "description": "USART hardware configuration 7\nCFG7[3:0] = BAUDGEN_TYPE\n"
              },
              {
                "range": "23:20",
                "field": "CFG6[3:0]",
                "description": "USART hardware configuration 6\nCFG6[3:0] = DUAL_clock\n"
              },
              {
                "range": "19:16",
                "field": "CFG5[3:0]",
                "description": "USART hardware configuration 5\nCFG5[3:0] = ABR_RTO_SCT1\n"
              },
              {
                "range": "15:12",
                "field": "CFG4[3:0]",
                "description": "USART hardware configuration 4\nCFG4[3:0] = SMARTCARD_SEL\n"
              },
              {
                "range": "11:8",
                "field": "CFG3[3:0]",
                "description": "USART hardware configuration 3\nCFG3[3:0] = IRDA_SEL\n"
              },
              {
                "range": "7:4",
                "field": "CFG2[3:0]",
                "description": "USART hardware configuration 2\nCFG2[3:0] = LIN_MASTER\n"
              },
              {
                "range": "3:0",
                "field": "CFG1[3:0]",
                "description": "USART hardware configuration 1\nCFG1[3:0] = SCLK_EXTRACT\nRM0436 Rev 7 2659/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              }
            ]
          },
          {
            "registername": "USART_VERR",
            "offset": "0x3F4",
            "page": 2660,
            "chapter": "53.8.17",
            "resetvalue": "0x00000023",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "Major revision\nThese bits return the USART major revision.\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "Minor revision\nThese bits return the USART minor revision.\n"
              }
            ]
          },
          {
            "registername": "USART_IPIDR",
            "offset": "0x3F8",
            "page": 2660,
            "chapter": "53.8.18",
            "resetvalue": "0x00130003",
            "bits": [
              {
                "range": "31:0",
                "field": "ID[31:0]",
                "description": "Peripheral identifier\nThese bits return the USART identifier ID[31:0]:\nID[31:0] = 0x00130003\n"
              }
            ]
          },
          {
            "registername": "USART_SIDR",
            "offset": "0x3FC",
            "page": 2660,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SID[31:0]",
                "description": "Size identification\nThese bits return the size of the memory region allocated to USART registers.\nThe size of this memory region is of 1Kbytes.\nSID[31:0] = 0xA3C5DD01\nRM0436 Rev 7 2661/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "GPIO registers",
        "registers": [
          {
            "registername": "GPIOx_MODER",
            "offset": "0x00",
            "page": 1078,
            "chapter": "13.4.1",
            "resetvalue": "0xffffffff",
            "bits": [
              {
                "range": "31:0",
                "field": "MODER[15:0][1:0]",
                "description": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\n00: Input mode\n01: General purpose output mode\n10: Alternate function mode\n11: Analog mode\n"
              }
            ]
          },
          {
            "registername": "GPIOx_OTYPER",
            "offset": "0x04",
            "page": 1078,
            "chapter": "13.4.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "OT[15:0]",
                "description": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\n0: Output push-pull (reset state)\n1: Output open-drain\n1078/4054 RM0436 Rev 7\nRM0436 General-purpose I/Os (GPIO)\n"
              }
            ]
          },
          {
            "registername": "GPIOx_OSPEEDR",
            "offset": "0x08",
            "page": 1079,
            "chapter": "13.4.3",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "OSPEEDR[15:0][1:0]",
                "description": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\n00: Low speed\n01: Medium speed\n10: High speed\n11: Very high speed\nNote: Refer to the product datasheets for the values of OSPEEDRy bits versus V range\nDD\nand external load.\n"
              }
            ]
          },
          {
            "registername": "GPIOx_PUPDR",
            "offset": "0x0C",
            "page": 1079,
            "chapter": "13.4.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "PUPDR[15:0][1:0]",
                "description": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\n00: No pull-up, pull-down\n01: Pull-up\n10: Pull-down\n11: Reserved\n"
              }
            ]
          },
          {
            "registername": "GPIOx_IDR",
            "offset": "0x10",
            "page": 1079,
            "chapter": "13.4.5",
            "resetvalue": "0x0000xxxx",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "IDR[15:0]",
                "description": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\n"
              }
            ]
          },
          {
            "registername": "GPIOx_ODR",
            "offset": "0x14",
            "page": 1080,
            "chapter": "13.4.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "ODR[15:0]",
                "description": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the ODR bits can be individually set and/or reset by writing to\nthe GPIOx_BSRR register (x = A..F).\n"
              }
            ]
          },
          {
            "registername": "GPIOx_BSRR",
            "offset": "0x18",
            "page": 1080,
            "chapter": "13.4.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "BR[15:0]",
                "description": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\n0: No action on the corresponding ODRx bit\n1: Resets the corresponding ODRx bit\nNote: If both BSx and BRx are set, BSx has priority.\n"
              },
              {
                "range": "15:0",
                "field": "BS[15:0]",
                "description": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\n0: No action on the corresponding ODRx bit\n1: Sets the corresponding ODRx bit\n"
              }
            ]
          },
          {
            "registername": "GPIOx_LCKR",
            "offset": "0x1C",
            "page": 1081,
            "chapter": "13.4.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "LCKK",
                "description": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\n0: Port configuration lock key not active\n1: Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU\nreset or peripheral reset.\nLOCK key write sequence:\nWR LCKR[16] = â€˜1â€™ + LCKR[15:0]\nWR LCKR[16] = â€˜0â€™ + LCKR[15:0]\nWR LCKR[16] = â€˜1â€™ + LCKR[15:0]\nRD LCKR\nRD LCKR[16] = â€˜1â€™ (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nAny error in the lock sequence aborts the lock.\nAfter the first lock sequence on any bit of the port, any read access on the LCKK bit\nreturns â€˜1â€™ until the next MCU reset or peripheral reset.\n"
              },
              {
                "range": "15:0",
                "field": "LCK[15:0]",
                "description": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is â€˜0.\n0: Port configuration not locked\n1: Port configuration locked\n"
              }
            ]
          },
          {
            "registername": "GPIOx_AFRL",
            "offset": "0x20",
            "page": 1082,
            "chapter": "13.4.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "AFR[7:0][3:0]",
                "description": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\n0000: AF0\n0001: AF1\n0010: AF2\n0011: AF3\n0100: AF4\n0101: AF5\n0110: AF6\n0111: AF7\n1000: AF8\n1001: AF9\n1010: AF10\n1011: AF11\n1100: AF12\n1101: AF13\n1110: AF14\n1111: AF15\n"
              }
            ]
          },
          {
            "registername": "GPIOx_AFRH",
            "offset": "0x24",
            "page": 1083,
            "chapter": "13.4.10",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "AFR[15:8][3:0]",
                "description": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\n0000: AF0\n0001: AF1\n0010: AF2\n0011: AF3\n0100: AF4\n0101: AF5\n0110: AF6\n0111: AF7\n1000: AF8\n1001: AF9\n1010: AF10\n1011: AF11\n1100: AF12\n1101: AF13\n1110: AF14\n1111: AF15\n"
              }
            ]
          },
          {
            "registername": "GPIOx_BRR",
            "offset": "0x28",
            "page": 1084,
            "chapter": "13.4.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "BR[15:0]",
                "description": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\n0: No action on the corresponding ODx bit\n1: Reset the corresponding ODx bit\n"
              }
            ]
          },
          {
            "registername": "GPIOZ_SECCFGR",
            "offset": "0x30",
            "page": 1084,
            "chapter": "13.4.12",
            "resetvalue": "0x000000ff",
            "bits": [
              {
                "range": "7:0",
                "field": "SEC[7:0]",
                "description": "I/O pin of Port Z secure bit enable y (y= 0..7)\nThese bits control the security I/O port pin.\n0: The I/O pin is non-secure\n1: The I/O pin is secure. Refer to Table83: GPIO secured bits for all corresponding secured\nbits.\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR10",
            "offset": "0x3C8",
            "page": 1085,
            "chapter": "13.4.13",
            "resetvalue": "0x00001240",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:20",
                "field": "OR_CFG[3:0]",
                "description": "Option register configuration\n0: Non-active\n1: Active\n"
              },
              {
                "range": "19:16",
                "field": "SEC_CFG[3:0]",
                "description": "Security mechanism activation\n0: Non-active\n1: Active\n"
              },
              {
                "range": "15:12",
                "field": "LOCK_CFG[3:0]",
                "description": "Lock mechanism activation\n0: Non-active\n1: Active\nRM0436 Rev 7 1085/4054\n1093\nGeneral-purpose I/Os (GPIO) RM0436\n"
              },
              {
                "range": "11:8",
                "field": "SPEED_CFG[3:0]",
                "description": "Number of speed lines for each I/O\n1: One line\n2: Two lines\n"
              },
              {
                "range": "7:4",
                "field": "AF_SIZE[3:0]",
                "description": "Number of AF available for each I/O\nAccepted value: 1 to 4\n1: One AF/IO\n2: Four AF/IO\n3: Eight AF/IO\n4: 16 AF/IO\n"
              },
              {
                "range": "3:0",
                "field": "AHB_IOP[3:0]",
                "description": "Bus interface configuration\n0: AHB\n1: IOP\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR9",
            "offset": "0x3CC",
            "page": 1086,
            "chapter": "13.4.14",
            "resetvalue": "0x0000ffff",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "EN_IO[15:0]",
                "description": "Presence granularity, each bit indicate the presence of the IO\n0: IO not present\n1: IO present\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR8",
            "offset": "0x3D0",
            "page": 1086,
            "chapter": "13.4.15",
            "resetvalue": "0xffffffff",
            "bits": [
              {
                "range": "31:28",
                "field": "AF_PRIO15[3:0]",
                "description": "Indicate the priority AF for I/O15 (0 to F)\n"
              },
              {
                "range": "27:24",
                "field": "AF_PRIO14[3:0]",
                "description": "Indicate the priority AF for I/O14 (0 to F)\n"
              },
              {
                "range": "23:20",
                "field": "AF_PRIO13[3:0]",
                "description": "Indicate the priority AF for I/O13 (0 to F)\n"
              },
              {
                "range": "19:16",
                "field": "AF_PRIO12[3:0]",
                "description": "Indicate the priority AF for I/O12 (0 to F)\n"
              },
              {
                "range": "15:12",
                "field": "AF_PRIO11[3:0]",
                "description": "Indicate the priority AF for I/O11 (0 to F)\n"
              },
              {
                "range": "11:8",
                "field": "AF_PRIO10[3:0]",
                "description": "Indicate the priority AF for I/O10 (0 to F)\n"
              },
              {
                "range": "7:4",
                "field": "AF_PRIO9[3:0]",
                "description": "Indicate the priority AF for I/O9 (0 to F)\n"
              },
              {
                "range": "3:0",
                "field": "AF_PRIO8[3:0]",
                "description": "Indicate the priority AF for I/O8 (0 to F)\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR7",
            "offset": "0x3D4",
            "page": 1087,
            "chapter": "13.4.16",
            "resetvalue": "0xffffffff",
            "bits": [
              {
                "range": "31:28",
                "field": "AF_PRIO7[3:0]",
                "description": "Indicate the priority AF for I/O7 (0 to F)\n"
              },
              {
                "range": "27:24",
                "field": "AF_PRIO6[3:0]",
                "description": "Indicate the priority AF for I/O6 (0 to F)\n"
              },
              {
                "range": "23:20",
                "field": "AF_PRIO5[3:0]",
                "description": "Indicate the priority AF for I/O5 (0 to F)\n"
              },
              {
                "range": "19:16",
                "field": "AF_PRIO4[3:0]",
                "description": "Indicate the priority AF for I/O4 (0 to F)\n"
              },
              {
                "range": "15:12",
                "field": "AF_PRIO3[3:0]",
                "description": "Indicate the priority AF for I/O3 (0 to F)\n"
              },
              {
                "range": "11:8",
                "field": "AF_PRIO2[3:0]",
                "description": "Indicate the priority AF for I/O2 (0 to F)\n"
              },
              {
                "range": "7:4",
                "field": "AF_PRIO1[3:0]",
                "description": "Indicate the priority AF for I/O1 (0 to F)\n"
              },
              {
                "range": "3:0",
                "field": "AF_PRIO0[3:0]",
                "description": "Indicate the priority AF for I/O0 (0 to F)\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR6",
            "offset": "0x3D8",
            "page": 1087,
            "chapter": "13.4.17",
            "resetvalue": "0xffffffff",
            "bits": [
              {
                "range": "31:0",
                "field": "MODER_RES[31:0]",
                "description": "MODER register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR5",
            "offset": "0x3DC",
            "page": 1088,
            "chapter": "13.4.18",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "PUPDR_RES[31:0]",
                "description": "Pull-up / pull-down register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR4",
            "offset": "0x3E0",
            "page": 1088,
            "chapter": "13.4.19",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "OSPEED_RES[31:0]",
                "description": "OSPEED register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR3",
            "offset": "0x3E4",
            "page": 1088,
            "chapter": "13.4.20",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "OTYPER_RES[31:0]",
                "description": "Output type register reset value\n"
              },
              {
                "range": "15:0",
                "field": "ODR_RES[31:0]",
                "description": "Output data register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR2",
            "offset": "0x3E8",
            "page": 1089,
            "chapter": "13.4.21",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "AFRL_RES[31:0]",
                "description": "AF register low reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR1",
            "offset": "0x3EC",
            "page": 1089,
            "chapter": "13.4.22",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "AFRH_RES[31:0]",
                "description": "AF register high reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR0",
            "offset": "0x3F0",
            "page": 1089,
            "chapter": "13.4.23",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "OR_RES[15:0]",
                "description": "Option register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_VERR",
            "offset": "0x3F4",
            "page": 1090,
            "chapter": "13.4.24",
            "resetvalue": "0x00000040",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "Major revision\nThese bits return the GPIO major revision.\nMajor revision is 4.\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "Minor revision\nThese bits return the GPIO minor revision.\nMinor revision is 0.\n"
              }
            ]
          },
          {
            "registername": "GPIOx_IPIDR",
            "offset": "0x3F8",
            "page": 1090,
            "chapter": "13.4.25",
            "resetvalue": "0x000f0003",
            "bits": [
              {
                "range": "31:0",
                "field": "IPIDR[31:0]",
                "description": "GPIO identifier\nThese bits return the GPIO identifier value.\n1090/4054 RM0436 Rev 7\nRM0436 General-purpose I/Os (GPIO)\n"
              }
            ]
          },
          {
            "registername": "GPIOx_SIDR",
            "offset": "0x3FC",
            "page": 1091,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SIDR[31:0]",
                "description": "Size identifier register\nThese bits return the size of the memory region allocated to GPIO registers.\nRM0436 Rev 7 1091/4054\n1093\nGeneral-purpose I/Os (GPIO) RM0436\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "DTS registers",
        "registers": [
          {
            "registername": "DTS_CFGR1",
            "offset": "0x00",
            "page": 1631,
            "chapter": "30.6.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "30:24",
                "field": "HSREF_CLK_DIV[6:0]",
                "description": "High speed clock division ratio\nThese bits are set and cleared by software. They can be used to define the division ratio for\nthe main clock in order to obtain the internal frequency lower than 1MHz required for the\ncalibration. They are applicable only for calibration when PCLK is selected as reference\nclock (REFCLK_SEL=0).\n0000000: No divider\n0000001: No divider\n0000010: 1/2 division ratio\n...\n1111111: 1/127 division ratio\n"
              },
              {
                "range": "23:22",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "21",
                "field": "Q_MEAS_OPT",
                "description": "Quick measurement option bit\nThis bit is set and cleared by software. It is used to increase the measurement speed by\nsuppressing the calibration step. It is effective only when the LSE clock is used as reference\nclock (REFCLK_SEL=1).\n0: Measurement with calibration\n1: Measurement without calibration\n"
              },
              {
                "range": "20",
                "field": "REFCLK_SEL",
                "description": "Reference clock selection bit\nThis bit is set and cleared by software. It indicates whether the reference clock is the high\nspeed clock (PCLK) or the low speed clock (LSE).\n0: High speed reference clock (PCLK)\n1: Low speed reference clock (LSE)\n"
              },
              {
                "range": "19:16",
                "field": "TS1_SMP_TIME[3:0]",
                "description": "Sampling time for temperature sensor 1\nThese bits allow increasing the sampling time to improve measurement precision.\nWhen the PCLK clock is selected as reference clock (REFCLK_SEL=0), the measurement\nis performed at TS1_SMP_TIME period of CLK_PTAT.\nWhen the LSE is selected as reference clock (REFCLK_SEL=1), the measurement is\nperformed at TS1_SMP_TIME period of LSE.\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "TS1_INTRIG_SEL[3:0]",
                "description": "Input trigger selection bit for temperature sensor 1\nThese bits are set and cleared by software. They select which input triggers a temperature\nmeasurement. Refer to Section30.3.10: Trigger input.\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "TS1_START",
                "description": "Start frequency measurement on temperature sensor 1\nThis bit is set and cleared by software.\n0: No software trigger.\n1: Software trigger for a frequency measurement. (only if TS1 is ready).\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "TS1_EN",
                "description": "Temperature sensor 1 enable bit\nThis bit is set and cleared by software.\n0: Temperature sensor 1 disabled\n1: Temperature sensor 1 enabled\nNote: Once enabled, the temperature sensor is active after a specific delay time. The\nTS1_RDY flag is set when the sensor is ready.\n1632/4054 RM0436 Rev 7\nRM0436 Digital temperature sensor (DTS)\n"
              }
            ]
          },
          {
            "registername": "DTS_T0VALR1",
            "offset": "0x08",
            "page": 1633,
            "chapter": "30.6.2",
            "resetvalue": "0x000xxxxx",
            "bits": [
              {
                "range": "31:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17:16",
                "field": "TS1_T0[1:0]",
                "description": "Engineering value of the T0 temperature for temperature sensor 1.\n00: 30Â°C\n01: 130Â°C\nOthers: Reserved, must not be used.\n"
              },
              {
                "range": "15:0",
                "field": "TS1_FMT0[15:0]",
                "description": "Engineering value of the frequency measured at T0 for\ntemperature sensor 1\nThis value is expressed in 0.1kHz.\n"
              }
            ]
          },
          {
            "registername": "DTS_RAMPVALR",
            "offset": "0x10",
            "page": 1633,
            "chapter": "30.6.3",
            "resetvalue": "0xxxxxxxxx",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "TS1_RAMP_COEFF[15:0]",
                "description": "Engineering value of the ramp coefficient for the temperature\nsensor 1.\nThis value is expressed in Hz/Â°C.\nRM0436 Rev 7 1633/4054\n1639\nDigital temperature sensor (DTS) RM0436\n"
              }
            ]
          },
          {
            "registername": "DTS_ITR1",
            "offset": "0x14",
            "page": 1634,
            "chapter": "30.6.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "TS1_HITTHD[15:0]",
                "description": "High interrupt threshold for temperature sensor 1\nThese bits are set and cleared by software. They indicate the highest value than can be\nreached before raising an interrupt signal.\n"
              },
              {
                "range": "15:0",
                "field": "TS1_LITTHD[15:0]",
                "description": "Low interrupt threshold for temperature sensor 1\nThese bits are set and cleared by software. They indicate the lowest value than can be\nreached before raising an interrupt signal.\n"
              }
            ]
          },
          {
            "registername": "DTS_DR",
            "offset": "0x1C",
            "page": 1634,
            "chapter": "30.6.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "TS1_MFREQ[15:0]",
                "description": "Value of the counter output value for temperature sensor 1\n1634/4054 RM0436 Rev 7\nRM0436 Digital temperature sensor (DTS)\n"
              }
            ]
          },
          {
            "registername": "DTS_SR",
            "offset": "0x20",
            "page": 1635,
            "chapter": "30.6.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "TS1_RDY",
                "description": "Temperature sensor 1 ready flag\nThis bit is set and reset by hardware.\nIt indicates that a measurement is ongoing.\n0: Temperature sensor 1 busy\n1: Temperature sensor 1 ready\n"
              },
              {
                "range": "14:7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "TS1_AITHF",
                "description": "Asynchronous interrupt flag for high threshold on temperature sensor 1\nThis bit is set by hardware when the high threshold is reached.\nIt is cleared by software by writing 1 to the TS1_CAITHF bit in the DTS_ICIFR register.\n0: High threshold not reached on temperature sensor 1\n1: High threshold reached on temperature sensor 1\nNote: This bit is active only when the TS1_AITHFEN bit is set\n"
              },
              {
                "range": "5",
                "field": "TS1_AITLF",
                "description": "Asynchronous interrupt flag for low threshold on temperature sensor 1\nThis bit is set by hardware when the low threshold is reached.\nIt is cleared by software by writing 1 to the TS1_CAITLF bit in the DTS_ICIFR register.\n0: Low threshold not reached on temperature sensor 1\n1: Low threshold reached on temperature sensor 1\nNote: This bit is active only when the TS1_AITLFEN bit is set\n"
              },
              {
                "range": "4",
                "field": "TS1_AITEF",
                "description": "Asynchronous interrupt flag for end of measure on temperature sensor 1\nThis bit is set by hardware when a temperature measure is done.\nIt is cleared by software by writing 1 to the TS1_CAITEF bit in the DTS_ICIFR register.\n0: End of measure not detected on temperature sensor 1\n1: End of measure detected on temperature sensor 1\nNote: This bit is active only when the TS1_AITEFEN bit is set\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 1635/4054\n1639\nDigital temperature sensor (DTS) RM0436\n"
              },
              {
                "range": "2",
                "field": "TS1_ITHF",
                "description": "Interrupt flag for high threshold on temperature sensor 1, synchronized on PCLK\nThis bit is set by hardware when the high threshold is set and reached.\nIt is cleared by software by writing 1 to the TS1_CITHF bit in the DTS_ICIFR register.\n0: High threshold not reached on temperature sensor 1\n1: High threshold reached on temperature sensor 1\nNote: This bit is active only when the TS1_ITHFEN bit is set\n"
              },
              {
                "range": "1",
                "field": "TS1_ITLF",
                "description": "Interrupt flag for low threshold on temperature sensor 1, synchronized on PCLK.\nThis bit is set by hardware when the low threshold is set and reached.\nIt is cleared by software by writing 1 to the TS1_CITLF bit in the DTS_ICIFR register.\n0: Low threshold not reached on temperature sensor 1\n1: Low threshold reached on temperature sensor 1\nNote: This bit is active only when the TS1_ITLFEN bit is set\n"
              },
              {
                "range": "0",
                "field": "TS1_ITEF",
                "description": "Interrupt flag for end of measurement on temperature sensor 1, synchronized on\nPCLK.\nThis bit is set by hardware when a temperature measure is done.\nIt is cleared by software by writing 1 to the TS2_CITEF bit in the DTS_ICIFR register.\n0: No end of measurement detected on temperature sensor 1\n1: End of measure detected on temperature sensor 1\nNote: This bit is active only when the TS1_ITEFEN bit is set\n"
              }
            ]
          },
          {
            "registername": "DTS_ITENR",
            "offset": "0x24",
            "page": 1636,
            "chapter": "30.6.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "TS1_AITHEN",
                "description": "Asynchronous interrupt enable flag on high threshold for temperature sensor\n1.\nThis bit are set and cleared by software.\nIt enables the asynchronous interrupt when the temperature is above the high threshold\n(only when REFCLK_SEL= 1â€™â€™)\n0: Asynchronous interrupt on high threshold disabled for temperature sensor 1\n1: Asynchronous interrupt on high threshold enabled for temperature sensor 1\n"
              },
              {
                "range": "5",
                "field": "TS1_AITLEN",
                "description": "Asynchronous interrupt enable flag for low threshold on temperature sensor 1.\nThis bit are set and cleared by software.\nIt enables the asynchronous interrupt when the temperature is below the low threshold (only\nwhen REFCLK_SEL= 1)\n0: Asynchronous interrupt on low threshold disabled for temperature sensor 1\n1: Asynchronous interrupt on low threshold enabled for temperature sensor 1\n1636/4054 RM0436 Rev 7\nRM0436 Digital temperature sensor (DTS)\n"
              },
              {
                "range": "4",
                "field": "TS1_AITEEN",
                "description": "Asynchronous interrupt enable flag for end of measurement on temperature\nsensor 1\nThis bit are set and cleared by software.\nIt enables the asynchronous interrupt for end of measurement (only when\nREFCLK_SEL=1).\n0: Asynchronous interrupt for end of measurement disabled on temperature sensor 1\n1: Asynchronous interrupt for end of measurement enabled on temperature sensor 1\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "TS1_ITHEN",
                "description": "Interrupt enable flag for high threshold on temperature sensor 1, synchronized\non PCLK.\nThis bit are set and cleared by software.\nIt enables the interrupt when the measure reaches or is above the high threshold.\n0: Synchronous interrupt for high threshold disabled on temperature sensor 1\n1: Synchronous interrupt for high threshold enabled on temperature sensor 1\n"
              },
              {
                "range": "1",
                "field": "TS1_ITLEN",
                "description": "Interrupt enable flag for low threshold on temperature sensor 1, synchronized on\nPCLK.\nThis bit are set and cleared by software.\nIt enables the synchronous interrupt when the measure reaches or is below the low\nthreshold.\n0: Synchronous interrupt for low threshold disabled on temperature sensor 1\n1: Synchronous interrupt for low threshold enabled on temperature sensor 1\n"
              },
              {
                "range": "0",
                "field": "TS1_ITEEN",
                "description": "Interrupt enable flag for end of measurement on temperature sensor 1,\nsynchronized on PCLK.\nThis bit are set and cleared by software.\nIt enables the synchronous interrupt for end of measurement.\n0: Synchronous interrupt for end of measurement disabled on temperature sensor 1\n1: Synchronous interrupt for end of measurement enabled on temperature sensor 1\n"
              }
            ]
          },
          {
            "registername": "DTS_ICIFR",
            "offset": "0x28",
            "page": 1637,
            "chapter": "30.6.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "TS1_CAITHF",
                "description": "Asynchronous interrupt clear flag for high threshold on temperature sensor 1\nWriting 1 to this bit clears the TS1_AITHF flag in the DTS_SR register.\n"
              },
              {
                "range": "5",
                "field": "TS1_CAITLF",
                "description": "Asynchronous interrupt clear flag for low threshold on temperature sensor 1\nWriting 1 to this bit clears the TS1_AITLF flag in the DTS_SR register.\nRM0436 Rev 7 1637/4054\n1639\nDigital temperature sensor (DTS) RM0436\n"
              },
              {
                "range": "4",
                "field": "TS1_CAITEF",
                "description": "Write once bit. Clear the asynchronous IT flag for End Of Measure for thermal\nsensor 1.\nWriting 1 clears the TS1_AITEF flag of the DTS_SR register.\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "TS1_CITHF",
                "description": "Interrupt clear flag for high threshold on temperature sensor 1\nWriting this bit to 1 clears the TS1_ITHF flag in the DTS_SR register.\n"
              },
              {
                "range": "1",
                "field": "TS1_CITLF",
                "description": "Interrupt clear flag for low threshold on temperature sensor 1\nWriting 1 to this bit clears the TS1_ITLF flag in the DTS_SR register.\n"
              },
              {
                "range": "0",
                "field": "TS1_CITEF",
                "description": "Interrupt clear flag for end of measurement on temperature sensor 1\nWriting 1 to this bit clears the TS1_ITEF flag in the DTS_SR register.\n"
              }
            ]
          },
          {
            "registername": "DTS_OR",
            "offset": "0x2C",
            "page": 1638,
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "TS_OP[31:0]",
                "description": "general purpose option bits\n1638/4054 RM0436 Rev 7\nRM0436 Digital temperature sensor (DTS)\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "SYSCFG registers",
        "registers": [
          {
            "registername": "SYSCFG_BOOTR",
            "offset": "0x000",
            "page": 1097,
            "chapter": "14.3.1",
            "resetvalue": "0x0000000x",
            "bits": [
              {
                "range": "31:7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "BOOT2_PD",
                "description": "BOOT2 pin pull-down disable. This is used to save power in case the BOOT2 pin\nis connected to VDD.\n0: (enabled) pull-down enabled. The BOOT2 pin can be left open and will take a value of 0 if\nopen.\n1: (disabled) pull-down disabled. The BOOT2 pin must not be left open.\n"
              },
              {
                "range": "5",
                "field": "BOOT1_PD",
                "description": "BOOT1 pin pull-down disable. This is used to save power in case the BOOT1 pin\nis connected to VDD\n0: (enabled) pull-down enabled. The BOOT1 pin can be left open and will take a value of 0 if\nopen.\n1: (disabled) pull-down disabled. The BOOT1 pin must not be left open.\n"
              },
              {
                "range": "4",
                "field": "BOOT0_PD",
                "description": "BOOT0 pin pull-down disable. This is used to save power in case the BOOT0 pin\nis connected to VDD\n0: (enabled) pull-down enabled. The BOOT0 pin can be left open and will take a value of 0 if\nopen.\n1: (disabled) pull-down disabled. The BOOT0 pin must not be left open.\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "BOOT2",
                "description": "BOOT2 pin value\n0: (low) BOOT2 pin connected to VSS (or left open if BOOT2_PD=0)\n1: (high) BOOT2 pin connected to VDD\n"
              },
              {
                "range": "1",
                "field": "BOOT1",
                "description": "BOOT1 pin value\n0: (low) BOOT1 pin connected to VSS (or left open if BOOT1_PD=0)\n1: (high) BOOT1 pin connected to VDD\n"
              },
              {
                "range": "0",
                "field": "BOOT0",
                "description": "BOOT0 pin value\n0: (low) BOOT0 pin connected to VSS (or left open if BOOT0_PD=0)\n1: (high) BOOT0 pin connected to VDD\nRM0436 Rev 7 1097/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n14.3.2 SYSCFG peripheral mode configuration set register\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_PMCSETR",
            "offset": "0x004",
            "page": 1098,
            "chapter": "14.3.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25",
                "field": "ANA1_SEL",
                "description": "controls analog connection between the ANA1 and PA1 pin.\nSet by software.\n0: Writing '0' has no effect, reading '0' means no connection. For best ADC performance the\nANA1 input must be used for package having ANA1 pin present.\n1: Writing '1' set this bit, reading '1' means ANA1 internally connected to PA1. Must only be\nused on package not having ANA1 pin.\n"
              },
              {
                "range": "24",
                "field": "ANA0_SEL",
                "description": "controls analog connection between ANA0 and PA0 pin.\nSet by software.\n0: Writing '0' has no effect, reading '0' means no connection. For best ADC performance\nANA0 input must be used for package having ANA0 pin present.\n1: Writing '1' set this bit, reading '1' means ANA0 internally connected to PA0. Must only be\nused on package not having ANA0 pin.\n"
              },
              {
                "range": "23:21",
                "field": "ETH_SEL[2:0]",
                "description": "Ethernet PHY interface selection.\nSet by software. Writing bit as '0' has no effect, set individual bits by writing â€˜1â€™, reading means\n000: GMII or MII\n001: RGMII\n010: Reserved\n011: Reserved\n100: RMII\n101: Reserved\n110: Reserved\n111: Reserved\nNote: Configuration must be done while the ETH is under reset and before enabling the ETH\nclocks\n"
              },
              {
                "range": "20",
                "field": "ETH_SELMII",
                "description": "controls MII or GMII when ETH_SEL[2:0] = 0b000.\nSet by software.\n0: (GMII) Writing '0' has no effect, reading '0' means MII/GMII clock mux controlled by ETH\nGMAC (GMII PHY use case)\n1: (MII) Writing '1' set this bit, reading '1' means MII/GMII clock mux forced in MII mode (MII\nPHY use case)\n"
              },
              {
                "range": "19:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n1098/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              },
              {
                "range": "17",
                "field": "ETH_REF_CLK_SEL",
                "description": "Ethernet 50MHz RMII clock selection.\nSet by software.\n0: Writing '0' has no effect, reading '0' means External clock is used. Need selection of\nAFMux. Could be used with all PHY\n1: Writing '1' set this bit, reading '1' means Internal clock ETH_CLK1 from RCC is used\nregardless AFMux. Could be used only with RMII PHY.\n"
              },
              {
                "range": "16",
                "field": "ETH_CLK_SEL",
                "description": "Gigabit Ethernet 125MHz clock selection. Only useful for GMII or RGMII PHY\nSet by software.\n0: Writing '0' has no effect, reading '0' means External clock is used. Need selection of AFMux\n1: Writing '1' set this bit, reading '1' means Internal clock ETH_CLK1 from RCC is used\nregardless AFMux\n"
              },
              {
                "range": "15:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9",
                "field": "ANASWVDD",
                "description": "GPIO analog switches control voltage selection\nSet by software.\n0: Writing '0' has no effect, reading '0' means IOs analog switches supplied by VDDA\n(EN_BOOSTER=0) or Booster output (EN_BOOSTER=1)\n1: Writing '1' set this bit, reading '1' means IOs analog switches supplied by VDD (regardless\nEN_BOOSTER bit, which should be cleared to avoid unwanted power consumption). Useful\nto avoid using Booster (add current consumption) when VDDA < 2.7V, but VDD > 2.7V. When\nboth VDD < 2.7V and VDDA < 2.7V, the Booster is still needed to get full AC performances\nfrom IOs analog switches.\n"
              },
              {
                "range": "8",
                "field": "EN_BOOSTER",
                "description": "Pad Booster enable.\nSet by software.\nused to reduce the Total Harmonic Distortion of the IOs analog switches when VDDA and VDD\nsupplies are below 2.7V. Activating the booster allows to guaranty the AC performance on IOs\nanalog switches. When activated the performance of the analog switch is the same on the full\nvoltage range. This bit is only useful when ANASWVDD=0\n0: Writing '0' has no effect, reading '0' means Booster is disabled\n1: Writing '1' set this bit, reading '1' means Booster is enabled. Note that this will add a current\nconsumption on VDD\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "I2C6_FMP",
                "description": "Fast Mode Plus (FM+) enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C6 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C6 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "4",
                "field": "I2C5_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C5 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C5 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\nRM0436 Rev 7 1099/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              },
              {
                "range": "3",
                "field": "I2C4_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C4 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C4 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1MHz.\n"
              },
              {
                "range": "2",
                "field": "I2C3_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C3 usage is possible up to 400kHz\n1: Writing '1' set this bit, reading '1' means the I2C3 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "1",
                "field": "I2C2_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C2 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C2 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "0",
                "field": "I2C1_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C1 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C1 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n14.3.3 SYSCFG peripheral mode configuration clear register\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_PMCCLRR",
            "offset": "0x044",
            "page": 1100,
            "chapter": "14.3.3",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25",
                "field": "ANA1_SEL",
                "description": "controls analog connection between the ANA1 and PA1 pin.\nCleared by software.\n0: Writing '0' has no effect, reading '0' means no connection. For best ADC performance the\nANA1 input must be used for package having ANA1 pin present.\n1: Writing '1' clear this bit, reading '1' means ANA1 internally connected to PA1. Must only be\nused on package not having ANA1 pin.\n"
              },
              {
                "range": "24",
                "field": "ANA0_SEL",
                "description": "controls analog connection between ANA0 and PA0 pin.\nCleared by software.\n0: Writing '0' has no effect, reading '0' means no connection. For best ADC performance\nANA0 input must be used for package having ANA0 pin present.\n1: Writing '1' clear this bit, reading '1' means ANA0 internally connected to PA0. Must only be\nused on package not having ANA0 pin.\n"
              },
              {
                "range": "23:21",
                "field": "ETH_SEL[2:0]",
                "description": "Ethernet PHY interface selection.\nCleared by software. Writing bit as '0' has no effect, clear individual bits by writing â€˜1â€™, reading\nmeans\n000: GMII or MII\n001: RGMII\n010: Reserved\n011: Reserved\n100: RMII\n101: Reserved\n110: Reserved\n111: Reserved\nNote: Configuration must be done while the ETH is under reset and before enabling the ETH\nclocks\n"
              },
              {
                "range": "20",
                "field": "ETH_SELMII",
                "description": "controls MII or GMII when ETH_SEL[2:0] = 0b000.\nCleared by software.\n0: (GMII) Writing '0' has no effect, reading '0' means MII/GMII clock mux controlled by ETH\nGMAC (GMII PHY use case)\n1: (MII) Writing '1' clear this bit, reading '1' means MII/GMII clock mux forced in MII mode (MII\nPHY use case)\n"
              },
              {
                "range": "19:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17",
                "field": "ETH_REF_CLK_SEL",
                "description": "Ethernet 50MHz RMII clock selection.\nCleared by software.\n0: Writing '0' has no effect, reading '0' means External clock is used. Need selection of\nAFMux. Could be used with all PHY\n1: Writing '1' clear this bit, reading '1' means Internal clock ETH_CLK1 from RCC is used\nregardless AFMux. Could be used only with RMII PHY.\n"
              },
              {
                "range": "16",
                "field": "ETH_CLK_SEL",
                "description": "Gigabit Ethernet 125MHz clock selection. Only useful for GMII or RGMII PHY\nCleared by software.\n0: Writing '0' has no effect, reading '0' means External clock is used. Need selection of AFMux\n1: Writing '1' clear this bit, reading '1' means Internal clock ETH_CLK1 from RCC is used\nregardless AFMux\n"
              },
              {
                "range": "15:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 1101/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              },
              {
                "range": "9",
                "field": "ANASWVDD",
                "description": "GPIO analog switches control voltage selection\nCleared by software.\n0: Writing '0' has no effect, reading '0' means IOs analog switches supplied by VDDA\n(EN_BOOSTER=0) or Booster output (EN_BOOSTER=1)\n1: Writing '1' clear this bit, reading '1' means IOs analog switches supplied by VDD (regardless\nEN_BOOSTER bit, which should be cleared to avoid unwanted power consumption). Useful\nto avoid using Booster (add current consumption) when VDDA < 2.7V, but VDD > 2.7V.\n"
              },
              {
                "range": "8",
                "field": "EN_BOOSTER",
                "description": "Pad Booster enable.\nCleared by software.\nused to reduce the Total Harmonic Distortion of the IOs analog switches when VDDA and VDD\nsupplies are below 2.7V. Activating the booster allows to guaranty the AC performance on IOs\nanalog switches. When activated the performance of the analog switch is the same on the full\nvoltage range. This bit is only useful when ANASWVDD=0\n0: Writing '0' has no effect, reading '0' means Booster is disabled\n1: Writing '1' clear this bit, reading '1' means Booster is enabled. Note that this will add a\ncurrent consumption on VDD.\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "I2C6_FMP",
                "description": "Fast Mode Plus (FM+) enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C6 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C6 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "4",
                "field": "I2C5_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C5 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C5 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "3",
                "field": "I2C4_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C4 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C4 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1MHz.\n1102/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              },
              {
                "range": "2",
                "field": "I2C3_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C3 usage is possible up to 400kHz\n1: Writing '1' clear this bit, reading '1' means the I2C3 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "1",
                "field": "I2C2_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C2 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C2 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "0",
                "field": "I2C1_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C1 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C1 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_IOCTRLSETR",
            "offset": "0x018",
            "page": 1103,
            "chapter": "14.3.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "HSLVEN_SPI",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a SPIy_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "3",
                "field": "HSLVEN_SDMMC",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a SDMMCy_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\nRM0436 Rev 7 1103/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              },
              {
                "range": "2",
                "field": "HSLVEN_ETH",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a ETH_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "1",
                "field": "HSLVEN_QUADSPI",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a QUADSPI_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "0",
                "field": "HSLVEN_TRACE",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a TRACEx signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n1. This bit is not taken into account if the OTP bit (product_below_2V5) is 0 (default)\n2. Enabling High Speed mode while VDD > 2.7V can damage the IC. See pad characteristics for details.\nDanger: Enabling High Speed mode while VDD > 2.7V can damage the\nIC.\nSee pad characteristics for details\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_IOCTRLCLRR",
            "offset": "0x058",
            "page": 1104,
            "chapter": "14.3.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "HSLVEN_SPI",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a SPIy_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "3",
                "field": "HSLVEN_SDMMC",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a SDMMCy_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "2",
                "field": "HSLVEN_ETH",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a ETH_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "1",
                "field": "HSLVEN_QUADSPI",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a QUADSPI_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "0",
                "field": "HSLVEN_TRACE",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a TRACEx signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n1. This bit is not taken into account if the OTP bit (product_below_2V5) is 0 (default)\n2. Enabling High Speed mode while VDD > 2.7V can damage the IC. See pad characteristics for details.\nDanger: Enabling High Speed mode while VDD > 2.7V can damage the\nIC.\nSee pad characteristics for details\nRM0436 Rev 7 1105/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_ICNR",
            "offset": "0x01C",
            "page": 1106,
            "chapter": "14.3.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10",
                "field": "AXI_M10",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "9",
                "field": "AXI_M9",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "8",
                "field": "AXI_M8",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "7",
                "field": "AXI_M7",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "6",
                "field": "AXI_M6",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "5",
                "field": "AXI_M5",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3",
                "field": "AXI_M3",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n1106/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              },
              {
                "range": "2",
                "field": "AXI_M2",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "1",
                "field": "AXI_M1",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "0",
                "field": "AXI_M0",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\nRM0436 Rev 7 1107/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_CMPCR",
            "offset": "0x020",
            "page": 1108,
            "chapter": "14.3.7",
            "resetvalue": "0xxx870000",
            "bits": [
              {
                "range": "31:28",
                "field": "APSRC[3:0]",
                "description": "PMOS I/O Compensation value provided by compensation cell.\nValue sent to IOs compensation when SW_CTRL = 0 and READY = 1\n"
              },
              {
                "range": "27:24",
                "field": "ANSRC[3:0]",
                "description": "NMOS I/O Compensation value provided by compensation cell.\nValue sent to IOs when SW_CTRL = 0 and READY = 1\n"
              },
              {
                "range": "23:20",
                "field": "RAPSRC[3:0]",
                "description": "PMOS I/O Compensation value sent to IOs when SW_CTRL = 1\n0000: reserved\n0001: maximum compensation of fast conditions\n....\n1000: compensation for typical conditions\n....\n1110: maximum compensation of slow conditions\n1111: reserved\nNote: If compensation is needed, it is recommended to use automatic compensation\n"
              },
              {
                "range": "19:16",
                "field": "RANSRC[3:0]",
                "description": "NMOS I/O Compensation value sent to IOs when SW_CTRL = 1\n0000: reserved\n0001: maximum compensation of slow conditions\n....\n0111: compensation for typical conditions\n....\n1110: maximum compensation of fast conditions\n1111: reserved\nNote: If compensation is needed, it is recommended to use automatic compensation\n"
              },
              {
                "range": "15:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8",
                "field": "READY",
                "description": "Compensation cell ready flag\n0: I/O compensation cell not ready.\n1: I/O compensation cell ready, the values of APSRC[3:0] and ANSRC[3:0] are valid\n"
              },
              {
                "range": "7:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "SW_CTRL",
                "description": "Compensation Software Control\n0: IO compensation values come from compensation values in ANSRC[3:0] and APSRC[3:0]\n1: IO compensation values come from RANSRC[3:0] and RAPSRC[3:0] register values\nNote: SW_CTRL = 0 is not taken into account until READY = 1.\nThis means that whenever SW_CTRL, the RANSRC[3:0] and RAPSRC[3:0] are used for\nIO compensation when the compensation cell is in power down (MCU_EN=0 and\nMPU_EN=0, which is the case after a reset).\n"
              },
              {
                "range": "0",
                "field": "Reserved",
                "description": "must be kept at reset value.\n1108/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n14.3.8 SYSCFG compensation cell enable set register\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_CMPENSETR",
            "offset": "0x024",
            "page": 1109,
            "chapter": "14.3.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "MCU_EN",
                "description": "Compensation cell enable\nSet by software.\n0: (power_down) Writing '0' has no effect, reading â€˜0â€™ mean I/O compensation cell in power-\ndown mode if MPU_EN=0\n1: (enabled) Writing '1' enable I/O compensation cell, reading â€˜1â€™ mean /O compensation cell\nis enabled\nNote: The CSI oscillator must be enabled and ready (controlled in RCC) before MPU_EN could\nbe set to 1. Similarly, the CSI oscillator could be disabled only if MPU_EN and MCU_EN\nare set to 0.\n"
              },
              {
                "range": "0",
                "field": "MPU_EN",
                "description": "Compensation cell enable\nSet by software.\n0: (power_down) Writing '0' has no effect, reading â€˜0â€™ mean I/O compensation cell in power-\ndown mode if MCU_EN=0\n1: (enabled) Writing '1' enable I/O compensation cell, reading â€˜1â€™ mean /O compensation cell\nis enabled\nNote: The CSI oscillator must be enabled and ready (controlled in RCC) before MPU_EN could\nbe set to 1. Similarly, the CSI oscillator could be disabled only if MPU_EN and MCU_EN\nare set to 0.\nRM0436 Rev 7 1109/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n14.3.9 SYSCFG compensation cell enable clear register\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_CMPENCLRR",
            "offset": "0x028",
            "page": 1110,
            "chapter": "14.3.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "MCU_EN",
                "description": "Compensation cell enable\nCleared by software.\n0: (power_down) Writing '0' has no effect, reading â€˜0â€™ mean I/O compensation cell in power-\ndown mode if MPU_EN=0\n1: (enabled) Writing '1' clear MCU_EN bit, reading â€˜1â€™ mean /O compensation cell is enabled\nNote: The CSI oscillator must be enabled and ready (controlled in RCC) before MPU_EN could\nbe set to 1. Similarly, the CSI oscillator could be disabled only if MPU_EN and MCU_EN\nare set to 0.\n"
              },
              {
                "range": "0",
                "field": "MPU_EN",
                "description": "Compensation cell enable\nCleared by software.\n0: (power_down) Writing '0' has no effect, reading â€˜0â€™ mean I/O compensation cell in\npowerdown mode if MCU_EN=0\n1: (enabled) Writing '1' clear MPU_EN bit, reading â€˜1â€™ mean /O compensation cell is enabled\nNote: The CSI oscillator must be enabled and ready (controlled in RCC) before MPU_EN could\nbe set to 1. Similarly, the CSI oscillator could be disabled only if MPU_EN and MCU_EN\nare set to 0.\n1110/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_CBR",
            "offset": "0x02C",
            "page": 1111,
            "chapter": "14.3.10",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "PVDL",
                "description": "PVD lock enable bit\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock\nthe PVD connection to TIM1/8/15/16/17 Break input, as well as the PVDE and PLS[2:0] in the\nPWR_CR1 register.\n0: PVD interrupt disconnected from TIM1/8/15/16/17 Break input. PVDE and PLS[2:0] bits can\nbe programmed by the application.\n1: PVD interrupt connected to TIM1/8/15/16/17 Break input. PVDE and PLS[2:0] bits are read\nonly.\n"
              },
              {
                "range": "1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "CLL",
                "description": "Cortex-M4 LOCKUP (Hardfault) output enable bit\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock\nthe connection of Cortex-M4 LOCKUP (Hardfault) output to TIM1/8/15/16/17 Break input\n0: Cortex-M4 LOCKUP output disconnected from TIM1/8/15/16/17 Break inputs\n1: Cortex-M4 LOCKUP output connected to TIM1/8/15/16/17 Break inputs\nRM0436 Rev 7 1111/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_VERR",
            "offset": "0x03F4",
            "page": 1112,
            "chapter": "14.3.11",
            "resetvalue": "0x00000020",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "Major revision\nThese bits return the SYSCFG major revision.\nMajor revision is 2.\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "Minor revision\nThese bits return the SYSCFG minor revision.\nMinor revision is 0.\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_IPIDR",
            "offset": "0x03F8",
            "page": 1112,
            "chapter": "14.3.12",
            "resetvalue": "0x00030001",
            "bits": [
              {
                "range": "31:0",
                "field": "ID[31:0]",
                "description": "SYSCFG identifier\nThese bits return the SYSCFG identifier value.\n1112/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_SIDR",
            "offset": "0x03FC",
            "page": 1113,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SID[31:0]",
                "description": "Size identification\nThese bits return the size of the memory region allocated to SYSCFG registers.\nRM0436 Rev 7 1113/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "ADC registers (for each ADC)",
        "registers": [
          {
            "registername": "ADC_ISR",
            "offset": "0x00",
            "page": 1577,
            "chapter": "29.6.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "LDORDY",
                "description": "ADC LDO output voltage ready bit\nThis bit is set and cleared by hardware. It indicates that the ADC internal LDO output is ready and\nthat the ADC can be enabled or calibrated.\n0: ADC LDO voltage regulator disabled\n1: ADC LDO voltage regulator enabled\nNote: Refer to Section29.3: ADC implementation for the availability of the LDO regulator.\n"
              },
              {
                "range": "11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10",
                "field": "JQOVF",
                "description": "Injected context queue overflow\nThis bit is set by hardware when an Overflow of the Injected Queue of Context occurs. It is cleared\nby software writing 1 to it. Refer to Section29.4.22: Queue of context for injected conversions for\nmore information.\n0: No injected context queue overflow occurred (or the flag event was already acknowledged and\ncleared by software)\n1: Injected context queue overflow has occurred\n"
              },
              {
                "range": "9",
                "field": "AWD3",
                "description": "Analog watchdog 3 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in the fields\nLT3[7:0] and HT3[7:0] of ADC_TR3 register. It is cleared by software writing 1 to it.\n0: No analog watchdog 3 event occurred (or the flag event was already acknowledged and cleared\nby software)\n1: Analog watchdog 3 event occurred\n"
              },
              {
                "range": "8",
                "field": "AWD2",
                "description": "Analog watchdog 2 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in the fields\nLT2[7:0] and HT2[7:0] of ADC_TR2 register. It is cleared by software writing 1 to it.\n0: No analog watchdog 2 event occurred (or the flag event was already acknowledged and cleared\nby software)\n1: Analog watchdog 2 event occurred\nRM0436 Rev 7 1577/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "7",
                "field": "AWD1",
                "description": "Analog watchdog 1 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in the fields\nLT1[11:0] and HT1[11:0] of ADC_TR1 register. It is cleared by software. writing 1 to it.\n0: No analog watchdog 1 event occurred (or the flag event was already acknowledged and cleared\nby software)\n1: Analog watchdog 1 event occurred\n"
              },
              {
                "range": "6",
                "field": "JEOS",
                "description": "Injected channel end of sequence flag\nThis bit is set by hardware at the end of the conversions of all injected channels in the group. It is\ncleared by software writing 1 to it.\n0: Injected conversion sequence not complete (or the flag event was already acknowledged and\ncleared by software)\n1: Injected conversions complete\n"
              },
              {
                "range": "5",
                "field": "JEOC",
                "description": "Injected channel end of conversion flag\nThis bit is set by hardware at the end of each injected conversion of a channel when a new data is\navailable in the corresponding ADC_JDRy register. It is cleared by software writing 1 to it or by\nreading the corresponding ADC_JDRy register\n0: Injected channel conversion not complete (or the flag event was already acknowledged and\ncleared by software)\n1: Injected channel conversion complete\n"
              },
              {
                "range": "4",
                "field": "OVR",
                "description": "ADC overrun\nThis bit is set by hardware when an overrun occurs on a regular channel, meaning that a new\nconversion has completed while the EOC flag was already set. It is cleared by software writing 1 to\nit.\n0: No overrun occurred (or the flag event was already acknowledged and cleared by software)\n1: Overrun has occurred\n"
              },
              {
                "range": "3",
                "field": "EOS",
                "description": "End of regular sequence flag\nThis bit is set by hardware at the end of the conversions of a regular sequence of channels. It is\ncleared by software writing 1 to it.\n0: Regular Conversions sequence not complete (or the flag event was already acknowledged and\ncleared by software)\n1: Regular Conversions sequence complete\n1578/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "2",
                "field": "EOC",
                "description": "End of conversion flag\nThis bit is set by hardware at the end of each regular conversion of a channel when a new data is\navailable in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR\nregister\n0: Regular channel conversion not complete (or the flag event was already acknowledged and\ncleared by software)\n1: Regular channel conversion complete\n"
              },
              {
                "range": "1",
                "field": "EOSMP",
                "description": "End of sampling flag\nThis bit is set by hardware during the conversion of any channel (only for regular channels), at the\nend of the sampling phase.\n0: not at the end of the sampling phase (or the flag event was already acknowledged and cleared by\nsoftware)\n1: End of sampling phase reached\n"
              },
              {
                "range": "0",
                "field": "ADRDY",
                "description": "ADC ready\nThis bit is set by hardware after the ADC has been enabled (bit ADEN=1) and when the ADC\nreaches a state where it is ready to accept conversion requests.\nIt is cleared by software writing 1 to it.\n0: ADC not yet ready to start conversion (or the flag event was already acknowledged and cleared\nby software)\n1: ADC is ready to start conversion\nRM0436 Rev 7 1579/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_IER",
            "offset": "0x04",
            "page": 1580,
            "chapter": "29.6.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10",
                "field": "JQOVFIE",
                "description": "Injected context queue overflow interrupt enable\nThis bit is set and cleared by software to enable/disable the Injected Context Queue Overflow\ninterrupt.\n0: Injected Context Queue Overflow interrupt disabled\n1: Injected Context Queue Overflow interrupt enabled. An interrupt is generated when the JQOVF bit\nis set.\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\n"
              },
              {
                "range": "9",
                "field": "AWD3IE",
                "description": "Analog watchdog 3 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt.\n0: Analog watchdog 3 interrupt disabled\n1: Analog watchdog 3 interrupt enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "8",
                "field": "AWD2IE",
                "description": "Analog watchdog 2 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt.\n0: Analog watchdog 2 interrupt disabled\n1: Analog watchdog 2 interrupt enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "7",
                "field": "AWD1IE",
                "description": "Analog watchdog 1 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog 1 interrupt.\n0: Analog watchdog 1 interrupt disabled\n1: Analog watchdog 1 interrupt enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "6",
                "field": "JEOSIE",
                "description": "End of injected sequence of conversions interrupt enable\nThis bit is set and cleared by software to enable/disable the end of injected sequence of conversions\ninterrupt.\n0: JEOS interrupt disabled\n1: JEOS interrupt enabled. An interrupt is generated when the JEOS bit is set.\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\n1580/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "5",
                "field": "JEOCIE",
                "description": "End of injected conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of an injected conversion interrupt.\n0: JEOC interrupt disabled.\n1: JEOC interrupt enabled. An interrupt is generated when the JEOC bit is set.\nNote: The software is allowed to write this bit only when JADSTART is cleared to 0 (no injected\nconversion is ongoing).\n"
              },
              {
                "range": "4",
                "field": "OVRIE",
                "description": "Overrun interrupt enable\nThis bit is set and cleared by software to enable/disable the Overrun interrupt of a regular\nconversion.\n0: Overrun interrupt disabled\n1: Overrun interrupt enabled. An interrupt is generated when the OVR bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "3",
                "field": "EOSIE",
                "description": "End of regular sequence of conversions interrupt enable\nThis bit is set and cleared by software to enable/disable the end of regular sequence of conversions\ninterrupt.\n0: EOS interrupt disabled\n1: EOS interrupt enabled. An interrupt is generated when the EOS bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "2",
                "field": "EOCIE",
                "description": "End of regular conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of a regular conversion interrupt.\n0: EOC interrupt disabled.\n1: EOC interrupt enabled. An interrupt is generated when the EOC bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "1",
                "field": "EOSMPIE",
                "description": "End of sampling flag interrupt enable for regular conversions\nThis bit is set and cleared by software to enable/disable the end of the sampling phase interrupt for\nregular conversions.\n0: EOSMP interrupt disabled.\n1: EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "0",
                "field": "ADRDYIE",
                "description": "ADC ready interrupt enable\nThis bit is set and cleared by software to enable/disable the ADC Ready interrupt.\n0: ADRDY interrupt disabled\n1: ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nRM0436 Rev 7 1581/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_CR",
            "offset": "0x08",
            "page": 1582,
            "chapter": "29.6.3",
            "resetvalue": "0x20000000",
            "bits": [
              {
                "range": "31",
                "field": "ADCAL",
                "description": "ADC calibration\nThis bit is set by software to start the calibration of the ADC. Program first the bit ADCALDIF to\ndetermine if this calibration applies for single-ended or differential inputs mode.\nIt is cleared by hardware after calibration is complete.\n0: Calibration complete\n1: Write 1 to calibrate the ADC. Read at 1 means that a calibration in progress.\nNote: The software is allowed to launch a calibration by setting ADCAL only when ADEN=0.\nThe software is allowed to update the calibration factor by writing ADC_CALFACT only when\nADEN=1 and ADSTART=0 and JADSTART=0 (ADC enabled and no conversion is ongoing)\n"
              },
              {
                "range": "30",
                "field": "ADCALDIF",
                "description": "Differential mode for calibration\nThis bit is set and cleared by software to configure the single-ended or differential inputs mode for\nthe calibration.\n0: Writing ADCAL launches a calibration in single-ended inputs mode.\n1: Writing ADCAL launches a calibration in differential inputs mode.\nNote: The software is allowed to write this bit only when the ADC is disabled and is not calibrating\n(ADCAL=0, JADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n"
              },
              {
                "range": "29",
                "field": "DEEPPWD",
                "description": "Deep-power-down enable\nThis bit is set and cleared by software to put the ADC in deep-power-down mode.\n0: ADC not in deep-power down\n1: ADC in deep-power-down (default reset state)\nNote: The software is allowed to write this bit only when the ADC is disabled (ADCAL=0,\nJADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n"
              },
              {
                "range": "28",
                "field": "ADVREGEN",
                "description": "ADC voltage regulator enable\nThis bits is set by software to enable the ADC voltage regulator.\nBefore performing any operation such as launching a calibration or enabling the ADC, the ADC\nvoltage regulator must first be enabled and the software must wait for the regulator start-up time.\n0: ADC Voltage regulator disabled\n1: ADC Voltage regulator enabled.\nFor more details about the ADC voltage regulator enable and disable sequences, refer to\nSection29.4.6: ADC deep-power-down mode (DEEPPWD) and ADC voltage regulator\n(ADVREGEN).\nThe software can program this bitfield only when the ADC is disabled (ADCAL=0, JADSTART=0,\nADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n1582/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "27",
                "field": "LINCALRDYW6",
                "description": "Linearity calibration ready Word 6\nThis control / status bit allows to read/write the 6th linearity calibration factor.\nWhen the linearity calibration is complete, this bit is set. A bit clear launches the transfer of the\nlinearity factor 6 into the LINCALFACT[29:0] of the ADC_CALFACT2 register. The bit is reset by\nhardware when the ADC_CALFACT2 register can be read (software must poll the bit until it is\ncleared).\nWhen the LINCALRDYW6 bit is reset, a new linearity factor 6 value can be written into the\nLINCALFACT[29:0] of the ADC_CALFACT2 register. A bit set launches the linearity factor 6 update\nand the bit is effectively set by hardware once the update is done (software must poll the bit until it is\nset to indicate the write is effective).\nNote: ADC_CALFACT2[29:10] contains 0. ADC_CALFACT2[9:0] corresponds linearity correction\nfactor bits[159:150].\nThe software is allowed to toggle this bit only if the LINCALRDYW5, LINCALRDYW4,\nLINCALRDYW3, LINCALRDYW2 and LINCALRDYW1 bits are left unchanged, see chapter\n29.4.8: Calibration (ADCAL, ADCALDIF, ADCALLIN, ADC_CALFACT) for details.\nThe software is allowed to update the linearity calibration factor by writing LINCALRDYWx only\nwhen ADEN=1 and ADSTART=0 and JADSTART=0 (ADC enabled and no conversion is\nongoing)\n"
              },
              {
                "range": "26",
                "field": "LINCALRDYW5",
                "description": "Linearity calibration ready Word 5\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] corresponds linearity correction factor bits[149:120].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW3, LINCALRDYW2 and LINCALRDYW1 bits are left unchanged.\n"
              },
              {
                "range": "25",
                "field": "LINCALRDYW4",
                "description": "Linearity calibration ready Word 4\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] correspond linearity correction factor bits[119:90].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW3, LINCALRDYW2 and LINCALRDYW1 bits are left unchanged.\n"
              },
              {
                "range": "24",
                "field": "LINCALRDYW3",
                "description": "Linearity calibration ready Word 3\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] corresponds linearity correction factor bits[89:60].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW4, LINCALRDYW2 and LINCALRDYW1 bits are left unchanged.\n"
              },
              {
                "range": "23",
                "field": "LINCALRDYW2",
                "description": "Linearity calibration ready Word 2\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] corresponds linearity correction factor bits[59:30].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW4, LINCALRDYW3 and LINCALRDYW1 bits are left unchanged.\n"
              },
              {
                "range": "22",
                "field": "LINCALRDYW1",
                "description": "Linearity calibration ready Word 1\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] corresponds linearity correction factor bits[29:0].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW4, LINCALRDYW3 and LINCALRDYW2 bits are left unchanged.\n"
              },
              {
                "range": "21:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 1583/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "16",
                "field": "ADCALLIN",
                "description": "Linearity calibration\nThis bit is set and cleared by software to enable the Linearity calibration.\n0: Writing ADCAL launches a calibration without the Linearity calibration.\n1: Writing ADCAL launches a calibration with he Linearity calibration.\nNote: The software is allowed to write this bit only when the ADC is disabled and is not calibrating\n(ADCAL=0, JADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n"
              },
              {
                "range": "15:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8",
                "field": "BOOST",
                "description": "Boost mode control\nThis bit is set and cleared by software to enable/disable the boost mode.\n0: Boost mode off. Used when ADC clock < 20MHz to save power at lower clock frequency.\n1: Boost mode on. Must be used when ADC clock > 20MHz.\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nWhen dual mode is enabled (bits DAMDF of ADC_CCR register are not equal to zero), the bit\nBOOST of the slave ADC is no more writable and its content must be equal to the master ADC\nBOOST bit.\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "JADSTP",
                "description": "ADC stop of injected conversion command\nThis bit is set by software to stop and discard an ongoing injected conversion (JADSTP Command).\nIt is cleared by hardware when the conversion is effectively discarded and the ADC injected\nsequence and triggers can be re-configured. The ADC is then ready to accept a new start of injected\nconversions (JADSTART command).\n0: No ADC stop injected conversion command ongoing\n1: Write 1 to stop injected conversions ongoing. Read 1 means that an ADSTP command is in\nprogress.\nNote: The software is allowed to set JADSTP only when JADSTART=1 and ADDIS=0 (ADC is\nenabled and eventually converting an injected conversion and there is no pending request to\ndisable the ADC).\nIn auto-injection mode (JAUTO=1), setting ADSTP bit aborts both regular and injected\nconversions (do not use JADSTP)\n"
              },
              {
                "range": "4",
                "field": "ADSTP",
                "description": "ADC stop of regular conversion command\nThis bit is set by software to stop and discard an ongoing regular conversion (ADSTP Command).\nIt is cleared by hardware when the conversion is effectively discarded and the ADC regular\nsequence and triggers can be re-configured. The ADC is then ready to accept a new start of regular\nconversions (ADSTART command).\n0: No ADC stop regular conversion command ongoing\n1: Write 1 to stop regular conversions ongoing. Read 1 means that an ADSTP command is in\nprogress.\nNote: The software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 (ADC is enabled\nand eventually converting a regular conversion and there is no pending request to disable the\nADC).\nIn auto-injection mode (JAUTO=1), setting ADSTP bit aborts both regular and injected\nconversions (do not use JADSTP).\nIn dual ADC regular simultaneous mode and interleaved mode, the bit ADSTP of the master\nADC must be used to stop regular conversions. The other ADSTP bit is inactive.\n1584/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "3",
                "field": "JADSTART",
                "description": "ADC start of injected conversion\nThis bit is set by software to start ADC conversion of injected channels. Depending on the\nconfiguration bits JEXTEN, a conversion starts immediately (software trigger configuration) or once\nan injected hardware trigger event occurs (hardware trigger configuration).\nIt is cleared by hardware:\nâ€“ in single conversion mode when software trigger is selected (JEXTSEL=0x0): at the\nassertion of the End of Injected Conversion Sequence (JEOS) flag.\nâ€“ in all cases: after the execution of the JADSTP command, at the same time that JADSTP is\ncleared by hardware.\n0: No ADC injected conversion is ongoing.\n1: Write 1 to start injected conversions. Read 1 means that the ADC is operating and eventually\nconverting an injected channel.\nNote: The software is allowed to set JADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled\nand there is no pending request to disable the ADC).\nIn auto-injection mode (JAUTO=1), regular and auto-injected conversions are started by setting\nbit ADSTART (JADSTART must be kept cleared)\nRM0436 Rev 7 1585/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "2",
                "field": "ADSTART",
                "description": "ADC start of regular conversion\nThis bit is set by software to start ADC conversion of regular channels. Depending on the\nconfiguration bits EXTEN, a conversion starts immediately (software trigger configuration) or once a\nregular hardware trigger event occurs (hardware trigger configuration).\nIt is cleared by hardware:\nâ€“ in single conversion mode (CONT=0, DISCEN=0) when software trigger is selected\n(EXTEN=0x0): at the assertion of the End of Regular Conversion Sequence (EOS) flag.\nâ€“ In discontinuous conversion mode (CONT=0, DISCEN=1), when the software trigger is\nselected (EXTEN=0x0): at the end of conversion (EOC) flag.\nâ€“ in all other cases: after the execution of the ADSTP command, at the same time that\nADSTP is cleared by hardware.\n0: No ADC regular conversion is ongoing.\n1: Write 1 to start regular conversions. Read 1 means that the ADC is operating and eventually\nconverting a regular channel.\nNote: The software is allowed to set ADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled\nand there is no pending request to disable the ADC)\nIn auto-injection mode (JAUTO=1), regular and auto-injected conversions are started by setting\nbit ADSTART (JADSTART must be kept cleared)\n"
              },
              {
                "range": "1",
                "field": "ADDIS",
                "description": "ADC disable command\nThis bit is set by software to disable the ADC (ADDIS command) and put it into power-down state\n(OFF state).\nIt is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at\nthis time).\n0: no ADDIS command ongoing\n1: Write 1 to disable the ADC. Read 1 means that an ADDIS command is in progress.\nNote: The software is allowed to set ADDIS only when ADEN=1 and both ADSTART=0 and\nJADSTART=0 (which ensures that no conversion is ongoing)\n"
              },
              {
                "range": "0",
                "field": "ADEN",
                "description": "ADC enable control\nThis bit is set by software to enable the ADC. The ADC is effectively ready to operate once the flag\nADRDY has been set.\nIt is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.\n0: ADC is disabled (OFF state)\n1: Write 1 to enable the ADC.\nNote: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL=0,\nJADSTART=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0) except for bit ADVREGEN\nwhich must be 1 (and the software must have wait for the startup time of the voltage regulator)\n1586/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_CFGR",
            "offset": "0x0C",
            "page": 1587,
            "chapter": "29.6.4",
            "resetvalue": "0x80000000",
            "bits": [
              {
                "range": "31",
                "field": "JQDIS",
                "description": "Injected Queue disable\nThese bits are set and cleared by software to disable the Injected Queue mechanism:\n0: Injected Queue enabled\n1: Injected Queue disabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no regular nor injected conversion is ongoing).\nA set or reset of JQDIS bit causes the injected queue to be flushed and the ADC_JSQR register\nis cleared.\n"
              },
              {
                "range": "30:26",
                "field": "AWD1CH[4:0]",
                "description": "Analog watchdog 1 channel selection\nThese bits are set and cleared by software. They select the input channel to be guarded by the\nanalog watchdog.\n00000: ADC analog input channel-0 monitored by AWD1\n00001: ADC analog input channel-1 monitored by AWD1\n.....\n10010: ADC analog input channel-19 monitored by AWD1\nothers: Reserved, must not be used\nNote: The channel selected by AWD1CH must be also selected into the SQi or JSQi bits.\nThe software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "25",
                "field": "JAUTO",
                "description": "Automatic injected group conversion\nThis bit is set and cleared by software to enable/disable automatic injected group conversion after\nregular group conversion.\n0: Automatic injected group conversion disabled\n1: Automatic injected group conversion enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no regular nor injected conversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nJAUTO of the slave ADC is no more writable and its content is equal to the bit JAUTO of the\nmaster ADC.\n"
              },
              {
                "range": "24",
                "field": "JAWD1EN",
                "description": "Analog watchdog 1 enable on injected channels\nThis bit is set and cleared by software\n0: Analog watchdog 1 disabled on injected channels\n1: Analog watchdog 1 enabled on injected channels\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\nRM0436 Rev 7 1587/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "23",
                "field": "AWD1EN",
                "description": "Analog watchdog 1 enable on regular channels\nThis bit is set and cleared by software\n0: Analog watchdog 1 disabled on regular channels\n1: Analog watchdog 1 enabled on regular channels\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "22",
                "field": "AWD1SGL",
                "description": "Enable the watchdog 1 on a single channel or on all channels\nThis bit is set and cleared by software to enable the analog watchdog on the channel identified by\nthe AWD1CH[4:0] bits or on all the channels\n0: Analog watchdog 1 enabled on all channels\n1: Analog watchdog 1 enabled on a single channel\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "21",
                "field": "JQM",
                "description": "ADC_JSQR queue mode\nThis bit is set and cleared by software.\nIt defines how an empty Queue is managed.\n0: ADC_JSQR Mode 0: The Queue is never empty and maintains the last written configuration into\nADC_JSQR.\n1: ADC_JSQR Mode 1: The Queue can be empty and when this occurs, the software and hardware\ntriggers of the injected sequence are both internally disabled just after the completion of the last valid\ninjected sequence.\nRefer to Section29.4.22: Queue of context for injected conversions for more information.\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nJQM of the slave ADC is no more writable and its content is equal to the bit JQM of the master\nADC.\n"
              },
              {
                "range": "20",
                "field": "JDISCEN",
                "description": "Discontinuous mode on injected channels\nThis bit is set and cleared by software to enable/disable discontinuous mode on the injected\nchannels of a group.\n0: Discontinuous mode on injected channels disabled\n1: Discontinuous mode on injected channels enabled\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\nIt is not possible to use both auto-injected mode and discontinuous mode simultaneously: the\nbits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set.\nWhen dual mode is enabled (bits DAMDF of ADC_CCR register are not equal to zero), the bit\nJDISCEN of the slave ADC is no more writable and its content is equal to the bit JDISCEN of\nthe master ADC.\n1588/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "19:17",
                "field": "DISCNUM[2:0]",
                "description": "Discontinuous mode channel count\nThese bits are written by software to define the number of regular channels to be converted in\ndiscontinuous mode, after receiving an external trigger.\n000: 1 channel\n001: 2 channels\n...\n111: 8 channels\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that no\nregular conversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bits\nDISCNUM[2:0] of the slave ADC are no more writable and their content is equal to the bits\nDISCNUM[2:0] of the master ADC.\n"
              },
              {
                "range": "16",
                "field": "DISCEN",
                "description": "Discontinuous mode for regular channels\nThis bit is set and cleared by software to enable/disable discontinuous mode for regular channels.\n0: Discontinuous mode for regular channels disabled\n1: Discontinuous mode for regular channels enabled\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden\nto set both DISCEN=1 and CONT=1.\nIt is not possible to use both auto-injected mode and discontinuous mode simultaneously: the\nbits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set.\nThe software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nDISCEN of the slave ADC is no more writable and its content is equal to the bit DISCEN of the\nmaster ADC.\n"
              },
              {
                "range": "15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14",
                "field": "AUTDLY",
                "description": "Delayed conversion mode\nThis bit is set and cleared by software to enable/disable the Auto Delayed Conversion mode..\n0: Auto-delayed conversion mode off\n1: Auto-delayed conversion mode on\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nAUTDLY of the slave ADC is no more writable and its content is equal to the bit AUTDLY of the\nmaster ADC.\n"
              },
              {
                "range": "13",
                "field": "CONT",
                "description": "Single / continuous conversion mode for regular conversions\nThis bit is set and cleared by software. If it is set, regular conversion takes place continuously until it\nis cleared.\n0: Single conversion mode\n1: Continuous conversion mode\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden\nto set both DISCEN=1 and CONT=1.\nThe software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nCONT of the slave ADC is no more writable and its content is equal to the bit CONT of the\nmaster ADC.\nRM0436 Rev 7 1589/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "12",
                "field": "OVRMOD",
                "description": "Overrun Mode\nThis bit is set and cleared by software and configure the way data overrun is managed.\n0: ADC_DR register is preserved with the old data when an overrun is detected.\n1: ADC_DR register is overwritten with the last conversion result when an overrun is detected.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "11:10",
                "field": "EXTEN[1:0]",
                "description": "External trigger enable and polarity selection for regular channels\nThese bits are set and cleared by software to select the external trigger polarity and enable the\ntrigger of a regular group.\n00: Hardware trigger detection disabled (conversions can be launched by software)\n01: Hardware trigger detection on the rising edge\n10: Hardware trigger detection on the falling edge\n11: Hardware trigger detection on both the rising and falling edges\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that no\nregular conversion is ongoing).\n"
              },
              {
                "range": "9:5",
                "field": "EXTSEL[4:0]",
                "description": "External trigger selection for regular group\nThese bits select the external event used to trigger the start of conversion of a regular group:\n00000: Event 0\n00001: Event 1\n00010: Event 2\n00011: Event 3\n00100: Event 4\n00101: Event 5\n00110: Event 6\n00111: Event 7\n...\n11111: Event 31\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that no\nregular conversion is ongoing).\n"
              },
              {
                "range": "4:2",
                "field": "RES[2:0]",
                "description": "Data resolution\nThese bits are written by software to select the resolution of the conversion.\n000: 16 bits\n001: 14 bits\n010: 12 bits\n011: 10 bits\n100: 8 bits\nOthers: Reserved, must not be used.\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "1:0",
                "field": "DMNGT[1:0]",
                "description": "Data Management configuration\nThis bit is set and cleared by software to select how ADC interface output data are managed.\n00: Regular conversion data stored in DR only\n01: DMA One Shot Mode selected\n10: DFSDM mode selected\n11: DMA Circular Mode selected\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nIn dual-ADC modes, this bit is not relevant and replaced by control bit DAMDF of the\nADC_CCR register.\n1590/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_CFGR2",
            "offset": "0x10",
            "page": 1591,
            "chapter": "29.6.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:28",
                "field": "LSHIFT[3:0]",
                "description": "Left shift factor\nThis bitfield is set and cleared by software to define the left shifting applied to the final result with or\nwithout oversampling.\n0000: No left shift\n0001: Shift left 1-bit\n0010: Shift left 2-bits\n0011: Shift left 3-bits\n0100: Shift left 4-bits\n0101: Shift left 5-bits\n0110: Shift left 6-bits\n0111: Shift left 7-bits\n1000: Shift left 8-bits\n1001: Shift left 9-bits\n1010: Shift left 10-bits\n1011: Shift left 11-bits\n1100: Shift left 12-bits\n1101: Shift left 13-bits\n1110: Shift left 14-bits\n1111: Shift left 15-bits\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n"
              },
              {
                "range": "27:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:16",
                "field": "OSVR[9:0]",
                "description": "Oversampling ratio\nThis bitfield is set and cleared by software to define the oversampling ratio.\n0: 1x (no oversampling)\n1: 2x\n2: 3x\n...\n1023: 1024x\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n"
              },
              {
                "range": "15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14",
                "field": "RSHIFT4",
                "description": "Right-shift data after Offset 4 correction\nRefer to RSHIFT1 description.\nRM0436 Rev 7 1591/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "13",
                "field": "RSHIFT3",
                "description": "Right-shift data after Offset 3 correction\nRefer to RSHIFT1 description\n"
              },
              {
                "range": "12",
                "field": "RSHIFT2",
                "description": "Right-shift data after Offset 2 correction\nRefer to RSHIFT1 description\n"
              },
              {
                "range": "11",
                "field": "RSHIFT1",
                "description": "Right-shift data after Offset 1 correction\nThis bitfield is set and cleared by software to right-shift 1-bit data after offset1 correction. This bit can\nonly be used for 8-bit and 16-bit data format (see Section: Data register, data alignment and offset\n(ADC_DR, ADC_JDRy, OFFSETy, OFFSETy_CH, OVSS, LSHIFT, RSHIFT, SSATE) for details).\n0: Right-shifting disabled\n1: Data is right-shifted 1-bit.\n"
              },
              {
                "range": "10",
                "field": "ROVSM",
                "description": "Regular Oversampling mode\nThis bit is set and cleared by software to select the regular oversampling mode.\n0: Continued mode: When injected conversions are triggered, the oversampling is temporary\nstopped and continued after the injection sequence (oversampling buffer is maintained during\ninjected sequence)\n1: Resumed mode: When injected conversions are triggered, the current oversampling is aborted\nand resumed from start after the injection sequence (oversampling buffer is zeroed by injected\nsequence start)\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n"
              },
              {
                "range": "9",
                "field": "TROVS",
                "description": "Triggered Regular Oversampling\nThis bit is set and cleared by software to enable triggered oversampling\n0: All oversampled conversions for a channel are done consecutively following a trigger\n1: Each oversampled conversion for a channel needs a new trigger\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n"
              },
              {
                "range": "8:5",
                "field": "OVSS[3:0]",
                "description": "Oversampling right shift\nThis bitfield is set and cleared by software to define the right shifting applied to the raw oversampling\nresult.\n0000: No right shift\n0001: Shift right 1-bit\n0010: Shift right 2-bits\n0011: Shift right 3-bits\n0100: Shift right 4-bits\n0101: Shift right 5-bits\n0110: Shift right 6-bits\n0111: Shift right 7-bits\n1000: Shift right 8-bits\n1001: Shift right 9-bits\n1010: Shift right 10-bits\n1011: Shift right 11-bits\nOthers: Reserved, must not be used.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n1592/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "4:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "JOVSE",
                "description": "Injected Oversampling Enable\nThis bit is set and cleared by software to enable injected oversampling.\n0: Injected Oversampling disabled\n1: Injected Oversampling enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing)\n"
              },
              {
                "range": "0",
                "field": "ROVSE",
                "description": "Regular Oversampling Enable\nThis bit is set and cleared by software to enable regular oversampling.\n0: Regular Oversampling disabled\n1: Regular Oversampling enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing)\n"
              }
            ]
          },
          {
            "registername": "ADC_SMPR1",
            "offset": "0x14",
            "page": 1593,
            "chapter": "29.6.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:0",
                "field": "SMPx[2:0]",
                "description": "Channel x sampling time selection (x = 9 to 0)\nThese bits are written by software to select the sampling time individually for each channel.\nDuring sample cycles, the channel selection bits must remain unchanged.\n000: 1.5 ADC clock cycles\n001: 2.5 ADC clock cycles\n010: 8.5 ADC clock cycles\n011: 16.5 ADC clock cycles\n100: 32.5 ADC clock cycles\n101: 64.5 ADC clock cycles\n110: 387.5 ADC clock cycles\n111: 810.5 ADC clock cycles\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\nRM0436 Rev 7 1593/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_SMPR2",
            "offset": "0x18",
            "page": 1594,
            "chapter": "29.6.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:0",
                "field": "SMPx[2:0]",
                "description": "Channel x sampling time selection (x = 19 to 10)\nThese bits are written by software to select the sampling time individually for each channel.\nDuring sampling cycles, the channel selection bits must remain unchanged.\n000: 1.5 ADC clock cycles\n001: 2.5 ADC clock cycles\n010: 8.5 ADC clock cycles\n011: 16.5 ADC clock cycles\n100: 32.5 ADC clock cycles\n101: 64.5 ADC clock cycles\n110: 387.5 ADC clock cycles\n111: 810.5 ADC clock cycles\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\n1594/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_PCSEL",
            "offset": "0x1C",
            "page": 1595,
            "chapter": "29.6.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "PCSEL[19:0]",
                "description": "Channel x (V ) pre selection (x = 0 to 19)\nINP[i]\nThese bits are written by software to pre select the input channel at IO instance to be\nconverted.\n0: Input Channel x (Vinp x) is not pre selected for conversion, the ADC conversion result with\nthis channel shows wrong result.\n1: Input Channel x (Vinp x) is pre selected for conversion\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_LTR1",
            "offset": "0x20",
            "page": 1595,
            "chapter": "29.6.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "LTR1[25:0]",
                "description": "Analog watchdog 1 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog 1.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy)\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nRM0436 Rev 7 1595/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_HTR1",
            "offset": "0x24",
            "page": 1596,
            "chapter": "29.6.10",
            "resetvalue": "0x03ffffff",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "HTR1[25:0]",
                "description": "Analog watchdog 1 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog 1.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy)\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n1596/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_SQR1",
            "offset": "0x30",
            "page": 1597,
            "chapter": "29.6.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:24",
                "field": "SQ4[4:0]",
                "description": "4th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 4th in the\nregular conversion sequence.\n"
              },
              {
                "range": "23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22:18",
                "field": "SQ3[4:0]",
                "description": "3rd conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 3rd in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16:12",
                "field": "SQ2[4:0]",
                "description": "2nd conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 2nd in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:6",
                "field": "SQ1[4:0]",
                "description": "1st conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 1st in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "5:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "L[3:0]",
                "description": "Regular channel sequence length\nThese bits are written by software to define the total number of conversions in the regular\nchannel conversion sequence.\n0000: 1 conversion\n0001: 2 conversions\n...\n1111: 16 conversions\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\nRM0436 Rev 7 1597/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_SQR2",
            "offset": "0x34",
            "page": 1598,
            "chapter": "29.6.12",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:24",
                "field": "SQ9[4:0]",
                "description": "9th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 9th in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22:18",
                "field": "SQ8[4:0]",
                "description": "8th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 8th in the\nregular conversion sequence\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16:12",
                "field": "SQ7[4:0]",
                "description": "7th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 7th in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:6",
                "field": "SQ6[4:0]",
                "description": "6th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 6th in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "SQ5[4:0]",
                "description": "5th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 5th in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n1598/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_SQR3",
            "offset": "0x38",
            "page": 1599,
            "chapter": "29.6.13",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:24",
                "field": "SQ14[4:0]",
                "description": "14th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 14th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22:18",
                "field": "SQ13[4:0]",
                "description": "13th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 13th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16:12",
                "field": "SQ12[4:0]",
                "description": "12th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 12th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:6",
                "field": "SQ11[4:0]",
                "description": "11th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 11th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "SQ10[4:0]",
                "description": "10th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 10th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\nRM0436 Rev 7 1599/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_SQR4",
            "offset": "0x3C",
            "page": 1600,
            "chapter": "29.6.14",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:6",
                "field": "SQ16[4:0]",
                "description": "16th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 16th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "SQ15[4:0]",
                "description": "15th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 15th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n1600/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_DR",
            "offset": "0x40",
            "page": 1601,
            "chapter": "29.6.15",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "RDATA[31:0]",
                "description": "Regular Data converted\nThese bits are read-only. They contain the conversion result from the last converted regular channel.\nThe data are left- or right-aligned as described in Section29.4.27: Data management.\nRM0436 Rev 7 1601/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_JSQR",
            "offset": "0x4C",
            "page": 1602,
            "chapter": "29.6.16",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:27",
                "field": "JSQ4[4:0]",
                "description": "4th conversion in the injected sequence\nThese bits are written by software with the channel number (0..19) assigned as the 4th in the\ninjected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing) unless the context queue is enabled (JQDIS=0 in\nADC_CFGR register).\n"
              },
              {
                "range": "26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:21",
                "field": "JSQ3[4:0]",
                "description": "3rd conversion in the injected sequence\nThese bits are written by software with the channel number (0..19) assigned as the 3rd in the\ninjected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing) unless the context queue is enabled (JQDIS=0 in\nADC_CFGR register).\n"
              },
              {
                "range": "20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:15",
                "field": "JSQ2[4:0]",
                "description": "2nd conversion in the injected sequence\nThese bits are written by software with the channel number (0..19) assigned as the 2nd in\nthe injected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing) unless the context queue is enabled (JQDIS=0 in\nADC_CFGR register).\n"
              },
              {
                "range": "14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13:9",
                "field": "JSQ1[4:0]",
                "description": "1st conversion in the injected sequence\nThese bits are written by software with the channel number (0..19) assigned as the 1st in the\ninjected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing) unless the context queue is enabled (JQDIS=0 in\nADC_CFGR register).\n1602/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "8:7",
                "field": "JEXTEN[1:0]",
                "description": "External trigger enable and polarity selection for injected channels\nThese bits are set and cleared by software to select the external trigger polarity and enable\nthe trigger of an injected group.\n00: If JQDIS=0 (queue enabled), Hardware and software trigger detection disabled and\nIf JQDIS=1 (queue disabled), Hardware trigger detection disabled (conversions can be\nlaunched by software\n01: Hardware trigger detection on the rising edge\n10: Hardware trigger detection on the falling edge\n11: Hardware trigger detection on both the rising and falling edges\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing).\nIf JQM=1 and if the Queue of Context becomes empty, the software and hardware\ntriggers of the injected sequence are both internally disabled (refer to Section29.4.22:\nQueue of context for injected conversions)\n"
              },
              {
                "range": "6:2",
                "field": "JEXTSEL[4:0]",
                "description": "External trigger selection for injected group\nThese bits select the external event used to trigger the start of conversion of an injected\ngroup:\n00000: Event 0\n00001: Event 1\n00010: Event 2\n00011: Event 3\n00100: Event 4\n00101: Event 5\n00110: Event 6\n00111: Event 7\n...\n11111: Event 31:\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing).\n"
              },
              {
                "range": "1:0",
                "field": "JL[1:0]",
                "description": "Injected channel sequence length\nThese bits are written by software to define the total number of conversions in the injected\nchannel conversion sequence.\n00: 1 conversion\n01: 2 conversions\n10: 3 conversions\n11: 4 conversions\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing).\nRM0436 Rev 7 1603/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_OFRy",
            "offset": "0x60",
            "page": 1604,
            "chapter": "29.6.17",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "SSATE",
                "description": "Signed saturation Enable\nThis bit is written by software to enable or disable the Signed saturation feature.\nThis bit can be enabled only for 8-bit and 16-bit data format (see Section: Data register, data\nalignment and offset (ADC_DR, ADC_JDRy, OFFSETy, OFFSETy_CH, OVSS, LSHIFT,\nRSHIFT, SSATE) for details).\n0: Offset is subtracted maintaining data integrity and extending result size (9-bit and 17-bit\nsigned format).\n1: Offset is subtracted and result is saturated to maintain result size.\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\n"
              },
              {
                "range": "30:26",
                "field": "OFFSET_CH[4:0]",
                "description": "Channel selection for the Data offset y\nThese bits are written by software to define the channel to which the offset programmed into\nbits OFFSETy[25:0] applies.\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\n"
              },
              {
                "range": "25:0",
                "field": "OFFSET[25:0]",
                "description": "Data offset y for the channel programmed into bits OFFSETy_CH[4:0]\nThese bits are written by software to define the offset y to be subtracted from the raw\nconverted data when converting a channel (can be regular or injected). The channel to which\napplies the data offset y must be programmed in the bits OFFSETy_CH[4:0]. The conversion\nresult can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi\nregisters (injected conversion).\nWhen OFFSETy[25:0] bitfield is reset, the offset compensation is disabled.\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\nIf several offset (OFFSETy) point to the same channel, only the offset with the lowest x\nvalue is considered for the subtraction.\nEx: if OFFSET1_CH[4:0]=4 and OFFSET2_CH[4:0]=4, this is OFFSET1[25:0] which is\nsubtracted when converting channel 4.\n1604/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_JDRy",
            "offset": "0x80",
            "page": 1605,
            "chapter": "29.6.18",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "JDATA[31:0]",
                "description": "Injected data\nThese bits are read-only. They contain the conversion result from injected channel y. The\ndata are left -or right-aligned as described in Section29.4.27: Data management.\n29.6.19 ADC analog watchdog 2 configuration register\n(ADC_AWD2CR)\nAddress offset: 0xA0\nReset value: 0x0000 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. AWD2CH[19:16]\nrw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nAWD2CH[15:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "AWD2CH[19:0]",
                "description": "Analog watchdog 2 channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded\nby the analog watchdog 2.\nAWD2CH[i] = 0: ADC analog input channel-i is not monitored by AWD2\nAWD2CH[i] = 1: ADC analog input channel-i is monitored by AWD2\nWhen AWD2CH[19:0] = 000..0, the analog Watchdog 2 is disabled\nNote: The channels selected by AWD2CH must be also selected into the SQi or JSQi bits.\nThe software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nRM0436 Rev 7 1605/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n29.6.20 ADC analog watchdog 3 configuration register\n(ADC_AWD3CR)\nAddress offset: 0xA4\nReset value: 0x0000 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. AWD3CH[19:16]\nrw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nAWD3CH[15:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "AWD3CH[19:0]",
                "description": "Analog watchdog 3 channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded\nby the analog watchdog 3.\nAWD3CH[i] = 0: ADC analog input channel-i is not monitored by AWD3\nAWD3CH[i] = 1: ADC analog input channel-i is monitored by AWD3\nWhen AWD3CH[19:0] = 000..0, the analog Watchdog 3 is disabled\nNote: The channels selected by AWD3CH must be also selected into the SQi or JSQi bits.\nThe software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_LTR2",
            "offset": "0xB0",
            "page": 1606,
            "chapter": "29.6.21",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "LTR2[25:0]",
                "description": "Analog watchdog 2 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog 2.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n1606/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_HTR2",
            "offset": "0xB4",
            "page": 1607,
            "chapter": "29.6.22",
            "resetvalue": "0x03ffffff",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "HTR2[25:0]",
                "description": "Analog watchdog 2 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog 2.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_LTR3",
            "offset": "0xB8",
            "page": 1607,
            "chapter": "29.6.23",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "LTR3[25:0]",
                "description": "Analog watchdog 3 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog 3.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy)\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nRM0436 Rev 7 1607/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_HTR3",
            "offset": "0xBC",
            "page": 1608,
            "chapter": "29.6.24",
            "resetvalue": "0x03ffffff",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "HTR3[25:0]",
                "description": "Analog watchdog 3 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog 3.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy)\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_DIFSEL",
            "offset": "0xC0",
            "page": 1608,
            "chapter": "29.6.25",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "DIFSEL[19:0]",
                "description": "Differential mode for channels 19 to 0\nThese bits are set and cleared by software. They allow to select if a channel is configured as single\nended or differential mode.\nDIFSEL[i] = 0: ADC analog input channel-i is configured in single ended mode\nDIFSEL[i] = 1: ADC analog input channel-i is configured in differential mode\nNote: The software is allowed to write these bits only when the ADC is disabled (ADCAL=0,\nJADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n1608/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_CALFACT",
            "offset": "0xC4",
            "page": 1609,
            "chapter": "29.6.26",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26:16",
                "field": "CALFACT_D[10:0]",
                "description": "Calibration Factors in differential mode\nThese bits are written by hardware or by software.\nOnce a differential inputs calibration is complete,they are updated by hardware with the calibration\nfactors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different\nfrom the current one stored into the analog ADC, it is then applied once a new differential conversion\nis launched.\nNote: The software is allowed to write these bits only when ADEN=1, ADSTART=0 and JADSTART=0\n(ADC is enabled and no calibration is ongoing and no conversion is ongoing).\n"
              },
              {
                "range": "15:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:0",
                "field": "CALFACT_S[10:0]",
                "description": "Calibration Factors In single-Ended mode\nThese bits are written by hardware or by software.\nOnce a single-ended inputs calibration is complete,they are updated by hardware with the\ncalibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different\nfrom the current one stored into the analog ADC, it is then applied once a new single-ended\nconversion is launched.\nNote: The software is allowed to write these bits only when ADEN=1, ADSTART=0 and JADSTART=0\n(ADC is enabled and no calibration is ongoing and no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_CALFACT2",
            "offset": "0xC8",
            "page": 1609,
            "chapter": "29.6.27",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:0",
                "field": "LINCALFACT[29:0]",
                "description": "Linearity Calibration Factor\nThese bits are written by hardware or by software.\nThey hold 30-bit out of the 160-bit linearity calibration factor.\nOnce a single-ended inputs calibration is complete,they are updated by hardware with the\ncalibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different\nfrom the current one stored into the analog ADC, it is then applied once a new single-ended\ncalibration is launched.\nNote: The software is allowed to write these bits only when ADEN=1, ADSTART=0 and JADSTART=0\n(ADC is enabled and no calibration is ongoing and no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC2_OR",
            "offset": "0xD0",
            "page": 1610,
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "VDDCOREEN",
                "description": "V enable bit\nDDCORE\nThis bit can be set and cleared by software to control ADC2 channel 14.\n0: V channel disabled\nDDCORE\n1: V channel enabled\nDDCORE\n"
              }
            ]
          }
        ]
      }
    ]
  }
]