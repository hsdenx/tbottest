[
  {
    "peripheralmaps": [
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0026000 - 0xA0027FFF",
        "size": "8KB",
        "peripheral": "GICV",
        "peripheralmap": "GIC virtual CPU interface (GICV)"
      },
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0024000 - 0xA0025FFF",
        "size": "8KB",
        "peripheral": "GICH",
        "peripheralmap": "GIC virtual interface control, common(GICH)"
      },
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0022000 - 0xA0023FFF",
        "size": "8KB",
        "peripheral": "GICC",
        "peripheralmap": "GIC CPU Interface (GICC)"
      },
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0021000 - 0xA0021FFF",
        "size": "4KB",
        "peripheral": "GICD",
        "peripheralmap": "GIC distributor (GICD)"
      },
      {
        "bus": "Cortex-A7internal",
        "range": "0xA0000000 - 0xA0020FFF",
        "size": "132KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C00A400 - 0x5FFFFFFF",
        "size": "65495KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C00A000 - 0x5C00A3FF",
        "size": "1KB",
        "peripheral": "TAMP",
        "peripheralmap": "TAMP registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C009400 - 0x5C009FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C009000 - 0x5C0093FF",
        "size": "1KB",
        "peripheral": "I2C6",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C008000 - 0x5C008FFF",
        "size": "4KB",
        "peripheral": "STGENC",
        "peripheralmap": "STGEN registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C007400 - 0x5C007FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C007000 - 0x5C0073FF",
        "size": "1KB",
        "peripheral": "ETZPC",
        "peripheralmap": "ETZPC registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C006000 - 0x5C006FFF",
        "size": "4KB",
        "peripheral": "TZC",
        "peripheralmap": "TZC registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C005000 - 0x5C005FFF",
        "size": "4KB",
        "peripheral": "BSEC",
        "peripheralmap": "BSEC registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C004400 - 0x5C004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C004000 - 0x5C0043FF",
        "size": "1KB",
        "peripheral": "RTC",
        "peripheralmap": "RTC registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C003400 - 0x5C003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C003000 - 0x5C0033FF",
        "size": "1KB",
        "peripheral": "IWDG1",
        "peripheralmap": "IWDG registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C002400 - 0x5C002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C002000 - 0x5C0023FF",
        "size": "1KB",
        "peripheral": "I2C4",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C001400 - 0x5C001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C001000 - 0x5C0013FF",
        "size": "1KB",
        "peripheral": "SPI6",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB5",
        "range": "0x5C000400 - 0x5C000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB5",
        "range": "0x5C000000 - 0x5C0003FF",
        "size": "1KB",
        "peripheral": "USART1",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A007400 - 0x5BFFFFFF",
        "size": "32739KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB4",
        "range": "0x5A007000 - 0x5A0073FF",
        "size": "1KB",
        "peripheral": "DDRPERFM",
        "peripheralmap": "DDRPERFM registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A006000 - 0x5A006FFF",
        "size": "4KB",
        "peripheral": "USBPHYC",
        "peripheralmap": "USBPHYC registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A005000 - 0x5A005FFF",
        "size": "4KB",
        "peripheral": "STGENR",
        "peripheralmap": "STGEN registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A004000 - 0x5A004FFF",
        "size": "4KB",
        "peripheral": "DDRPHYC",
        "peripheralmap": "PUBL registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A003000 - 0x5A003FFF",
        "size": "4KB",
        "peripheral": "DDRCTRL",
        "peripheralmap": "DDRCTRL registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A002400 - 0x5A002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB4",
        "range": "0x5A002000 - 0x5A0023FF",
        "size": "1KB",
        "peripheral": "IWDG2",
        "peripheralmap": "IWDG registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A001400 - 0x5A001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB4",
        "range": "0x5A001000 - 0x5A0013FF",
        "size": "1KB",
        "peripheral": "LTDC",
        "peripheralmap": "LTDC registers"
      },
      {
        "bus": "APB4",
        "range": "0x5A000800 - 0x5A000FFF",
        "size": "2KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB4",
        "range": "0x5A000000 - 0x5A0007FF",
        "size": "2KB",
        "peripheral": "DSI",
        "peripheralmap": "DSI Host registers"
      },
      {
        "bus": "AHB6",
        "range": "0x59040000 - 0x59FFFFFF",
        "size": "16128KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB6",
        "range": "0x59000000 - 0x5903FFFF",
        "size": "256KB",
        "peripheral": "GPU",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB6",
        "range": "0x5800E000 - 0x58FFFFFF",
        "size": "16328KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB6",
        "range": "0x5800D000 - 0x5800DFFF",
        "size": "4KB",
        "peripheral": "USBH_EHCI",
        "peripheralmap": "USBH registers"
      },
      {
        "bus": "AHB6",
        "range": "0x5800C000 - 0x5800CFFF",
        "size": "4KB",
        "peripheral": "USBH_OHCI",
        "peripheralmap": "USBH registers"
      },
      {
        "bus": "AHB6",
        "range": "0x5800A000 - 0x5800BFFF",
        "size": "8KB",
        "peripheral": "ETH1",
        "peripheralmap": "Ethernet registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58009000 - 0x58009FFF",
        "size": "4KB",
        "peripheral": "CRC1",
        "peripheralmap": "CRC registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58008000 - 0x58008FFF",
        "size": "4KB",
        "peripheral": "DLYBSD2",
        "peripheralmap": "DLYB registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58007000 - 0x58007FFF",
        "size": "4KB",
        "peripheral": "SDMMC2",
        "peripheralmap": "SDMMC registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58006000 - 0x58006FFF",
        "size": "4KB",
        "peripheral": "DLYBSD1",
        "peripheralmap": "DLYB registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58005000 - 0x58005FFF",
        "size": "4KB",
        "peripheral": "SDMMC1",
        "peripheralmap": "SDMMC registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58004000 - 0x58004FFF",
        "size": "4KB",
        "peripheral": "DLYBQS",
        "peripheralmap": "DLYB registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58003000 - 0x58003FFF",
        "size": "4KB",
        "peripheral": "QUADSPI",
        "peripheralmap": "QUADSPI registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58002000 - 0x58002FFF",
        "size": "4KB",
        "peripheral": "FMC",
        "peripheralmap": "NOR/PSRAM controller registersNAND flash controller registers"
      },
      {
        "bus": "AHB6",
        "range": "0x58001000 - 0x58001FFF",
        "size": "4KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB6",
        "range": "0x58000000 - 0x58000FFF",
        "size": "4KB",
        "peripheral": "MDMA",
        "peripheralmap": "MDMA registers"
      },
      {
        "bus": "AXIM",
        "range": "0x57100000 - 0x57FFFFFF",
        "size": "15360KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AXIM",
        "range": "0x57000000 - 0x570FFFFF",
        "size": "1024KB",
        "peripheral": "AXIMC",
        "peripheralmap": "AXIMC registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54004400 - 0x56FFFFFF",
        "size": "49135KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB5",
        "range": "0x54004000 - 0x540043FF",
        "size": "1KB",
        "peripheral": "GPIOZ",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54003400 - 0x54003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB5",
        "range": "0x54003000 - 0x540033FF",
        "size": "1KB",
        "peripheral": "RNG1",
        "peripheralmap": "RNG registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54002400 - 0x54002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB5",
        "range": "0x54002000 - 0x540023FF",
        "size": "1KB",
        "peripheral": "HASH1",
        "peripheralmap": "HASH registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54001400 - 0x54001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB5",
        "range": "0x54001000 - 0x540013FF",
        "size": "1KB",
        "peripheral": "CRYP1(1)",
        "peripheralmap": "CRYP registers"
      },
      {
        "bus": "AHB5",
        "range": "0x54000000 - 0x54000FFF",
        "size": "4KB",
        "peripheral": "BKPSRAM",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x5002A400 - 0x5007FFFF",
        "size": "343KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x5002A000 - 0x5002A3FF",
        "size": "1KB",
        "peripheral": "HDP",
        "peripheralmap": "HDP registers"
      },
      {
        "bus": "APB3",
        "range": "0x50028400 - 0x50029FFF",
        "size": "7KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50028000 - 0x500283FF",
        "size": "1KB",
        "peripheral": "DTS",
        "peripheralmap": "DTS registers"
      },
      {
        "bus": "APB3",
        "range": "0x50027400 - 0x50027FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50027000 - 0x500273FF",
        "size": "1KB",
        "peripheral": "SAI4",
        "peripheralmap": "SAI registers"
      },
      {
        "bus": "APB3",
        "range": "0x50025400 - 0x50026FFF",
        "size": "7KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50025000 - 0x500253FF",
        "size": "1KB",
        "peripheral": "VREFBUF",
        "peripheralmap": "VREFBUF registers"
      },
      {
        "bus": "APB3",
        "range": "0x50024400 - 0x50024FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50024000 - 0x500243FF",
        "size": "1KB",
        "peripheral": "LPTIM5",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB3",
        "range": "0x50023400 - 0x50023FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50023000 - 0x500233FF",
        "size": "1KB",
        "peripheral": "LPTIM4",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB3",
        "range": "0x50022400 - 0x50022FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50022000 - 0x500223FF",
        "size": "1KB",
        "peripheral": "LPTIM3",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB3",
        "range": "0x50021400 - 0x50021FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50021000 - 0x500213FF",
        "size": "1KB",
        "peripheral": "LPTIM2",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB3",
        "range": "0x50020400 - 0x50020FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB3",
        "range": "0x50020000 - 0x500203FF",
        "size": "1KB",
        "peripheral": "SYSCFG",
        "peripheralmap": "SYSCFG registers"
      },
      {
        "bus": "AHB4",
        "range": "0x5000D400 - 0x5001FFFF",
        "size": "75KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x5000D000 - 0x5000D3FF",
        "size": "1KB",
        "peripheral": "EXTI",
        "peripheralmap": "EXTI registers"
      },
      {
        "bus": "AHB4",
        "range": "0x5000C400 - 0x5000CFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x5000C000 - 0x5000C3FF",
        "size": "1KB",
        "peripheral": "GPIOK",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x5000B400 - 0x5000BFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x5000B000 - 0x5000B3FF",
        "size": "1KB",
        "peripheral": "GPIOJ",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x5000A400 - 0x5000AFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x5000A000 - 0x5000A3FF",
        "size": "1KB",
        "peripheral": "GPIOI",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50009400 - 0x50009FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50009000 - 0x500093FF",
        "size": "1KB",
        "peripheral": "GPIOH",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50008400 - 0x50008FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50008000 - 0x500083FF",
        "size": "1KB",
        "peripheral": "GPIOG",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50007400 - 0x50007FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50007000 - 0x500073FF",
        "size": "1KB",
        "peripheral": "GPIOF",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50006400 - 0x50006FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50006000 - 0x500063FF",
        "size": "1KB",
        "peripheral": "GPIOE",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50005400 - 0x50005FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50005000 - 0x500053FF",
        "size": "1KB",
        "peripheral": "GPIOD",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50004400 - 0x50004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50004000 - 0x500043FF",
        "size": "1KB",
        "peripheral": "GPIOC",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50003400 - 0x50003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50003000 - 0x500033FF",
        "size": "1KB",
        "peripheral": "GPIOB",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50002400 - 0x50002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50002000 - 0x500023FF",
        "size": "1KB",
        "peripheral": "GPIOA",
        "peripheralmap": "GPIO registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50001400 - 0x50001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB4",
        "range": "0x50001000 - 0x500013FF",
        "size": "1KB",
        "peripheral": "PWR",
        "peripheralmap": "PWR registers"
      },
      {
        "bus": "AHB4",
        "range": "0x50000000 - 0x50000FFF",
        "size": "4KB",
        "peripheral": "RCC",
        "peripheralmap": "RCC registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C006400 - 0x4FFFFFFF",
        "size": "65511KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C006000 - 0x4C0063FF",
        "size": "1KB",
        "peripheral": "DCMI",
        "peripheralmap": "DCMI registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C005400 - 0x4C005FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C005000 - 0x4C0053FF",
        "size": "1KB",
        "peripheral": "CRYP2(1)",
        "peripheralmap": "CRYP registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C004400 - 0x4C004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C004000 - 0x4C0043FF",
        "size": "1KB",
        "peripheral": "CRC2",
        "peripheralmap": "CRC registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C003400 - 0x4C003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C003000 - 0x4C0033FF",
        "size": "1KB",
        "peripheral": "RNG2",
        "peripheralmap": "RNG registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C002400 - 0x4C002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C002000 - 0x4C0023FF",
        "size": "1KB",
        "peripheral": "HASH2",
        "peripheralmap": "HASH registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C001400 - 0x4C001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C001000 - 0x4C0013FF",
        "size": "1KB",
        "peripheral": "IPCC",
        "peripheralmap": "IPCC registers"
      },
      {
        "bus": "AHB3",
        "range": "0x4C000400 - 0x4C000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB3",
        "range": "0x4C000000 - 0x4C0003FF",
        "size": "1KB",
        "peripheral": "HSEM",
        "peripheralmap": "HSEM registers"
      },
      {
        "bus": "AHB2",
        "range": "0x49040000 - 0x4BFFFFFF",
        "size": "48896KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x49000000 - 0x4903FFFF",
        "size": "256KB",
        "peripheral": "OTG",
        "peripheralmap": "OTG registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48005400 - 0x48FFFFFF",
        "size": "16363KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48005000 - 0x480053FF",
        "size": "1KB",
        "peripheral": "DLYBSD3",
        "peripheralmap": "DLYB registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48004400 - 0x48004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48004000 - 0x480043FF",
        "size": "1KB",
        "peripheral": "SDMMC3",
        "peripheralmap": "SDMMC registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48003400 - 0x48003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48003000 - 0x480033FF",
        "size": "1KB",
        "peripheral": "ADC12",
        "peripheralmap": "ADC registers (for each ADC)"
      },
      {
        "bus": "AHB2",
        "range": "0x48002400 - 0x48002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48002000 - 0x480023FF",
        "size": "1KB",
        "peripheral": "DMAMUX1",
        "peripheralmap": "DMAMUX registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48001400 - 0x48001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48001000 - 0x480013FF",
        "size": "1KB",
        "peripheral": "DMA2",
        "peripheralmap": "DMA registers"
      },
      {
        "bus": "AHB2",
        "range": "0x48000400 - 0x48000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "AHB2",
        "range": "0x48000000 - 0x480003FF",
        "size": "1KB",
        "peripheral": "DMA1",
        "peripheralmap": "DMA registers"
      },
      {
        "bus": "APB2",
        "range": "0x44013800 - 0x47FFFFFF",
        "size": "65458KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44011000 - 0x440137FF",
        "size": "10KB",
        "peripheral": "CANSRAM",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44010400 - 0x44010FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44010000 - 0x440103FF",
        "size": "1KB",
        "peripheral": "CCU",
        "peripheralmap": "CCU registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400F400 - 0x4400FFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400F000 - 0x4400F3FF",
        "size": "1KB",
        "peripheral": "FDCAN2",
        "peripheralmap": "FDCAN registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400E400 - 0x4400EFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400E000 - 0x4400E3FF",
        "size": "1KB",
        "peripheral": "FDCAN1",
        "peripheralmap": "FDCAN registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400D800 - 0x4400DFFF",
        "size": "2KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400D000 - 0x4400D7FF",
        "size": "2KB",
        "peripheral": "DFSDM1",
        "peripheralmap": "DFSDM channel y registers (y=0..7)DFSDM filter x module registers (x=0..5)"
      },
      {
        "bus": "APB2",
        "range": "0x4400C400 - 0x4400CFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400C000 - 0x4400C3FF",
        "size": "1KB",
        "peripheral": "SAI3",
        "peripheralmap": "SAI registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400B400 - 0x4400BFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400B000 - 0x4400B3FF",
        "size": "1KB",
        "peripheral": "SAI2",
        "peripheralmap": "SAI registers"
      },
      {
        "bus": "APB2",
        "range": "0x4400A400 - 0x4400AFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x4400A000 - 0x4400A3FF",
        "size": "1KB",
        "peripheral": "SAI1",
        "peripheralmap": "SAI registers"
      },
      {
        "bus": "APB2",
        "range": "0x44009400 - 0x44009FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44009000 - 0x440093FF",
        "size": "1KB",
        "peripheral": "SPI5",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB2",
        "range": "0x44008400 - 0x44008FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44008000 - 0x440083FF",
        "size": "1KB",
        "peripheral": "TIM17",
        "peripheralmap": "TIM16/TIM17 registers"
      },
      {
        "bus": "APB2",
        "range": "0x44007400 - 0x44007FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44007000 - 0x440073FF",
        "size": "1KB",
        "peripheral": "TIM16",
        "peripheralmap": "TIM16/TIM17 registers"
      },
      {
        "bus": "APB2",
        "range": "0x44006400 - 0x44006FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44006000 - 0x440063FF",
        "size": "1KB",
        "peripheral": "TIM15",
        "peripheralmap": "TIM15 registers"
      },
      {
        "bus": "APB2",
        "range": "0x44005400 - 0x44005FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44005000 - 0x440053FF",
        "size": "1KB",
        "peripheral": "SPI4",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB2",
        "range": "0x44004400 - 0x44004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44004000 - 0x440043FF",
        "size": "1KB",
        "peripheral": "SPI1",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB2",
        "range": "0x44003400 - 0x44003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44003000 - 0x440033FF",
        "size": "1KB",
        "peripheral": "USART6",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB2",
        "range": "0x44001400 - 0x44002FFF",
        "size": "7KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44001000 - 0x440013FF",
        "size": "1KB",
        "peripheral": "TIM 8",
        "peripheralmap": "TIM1/TIM8 registers"
      },
      {
        "bus": "APB2",
        "range": "0x44000400 - 0x44000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB2",
        "range": "0x44000000 - 0x440003FF",
        "size": "1KB",
        "peripheral": "TIM 1",
        "peripheralmap": "TIM1/TIM8 registers"
      },
      {
        "bus": "APB1",
        "range": "0x4001C400 - 0x43FFFFFF",
        "size": "65423KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4001C000 - 0x4001C3FF",
        "size": "1KB",
        "peripheral": "MDIOS",
        "peripheralmap": "MDIOS registers"
      },
      {
        "bus": "APB1",
        "range": "0x40019400 - 0x4001BFFF",
        "size": "11KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40019000 - 0x400193FF",
        "size": "1KB",
        "peripheral": "UART8",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x40018400 - 0x40018FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40018000 - 0x400183FF",
        "size": "1KB",
        "peripheral": "UART7",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x40017400 - 0x40017FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40017000 - 0x400173FF",
        "size": "1KB",
        "peripheral": "DAC1",
        "peripheralmap": "DAC registers"
      },
      {
        "bus": "APB1",
        "range": "0x40016400 - 0x40016FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40016000 - 0x400163FF",
        "size": "1KB",
        "peripheral": "CEC",
        "peripheralmap": "HDMI-CEC registers"
      },
      {
        "bus": "APB1",
        "range": "0x40015400 - 0x40015FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40015000 - 0x400153FF",
        "size": "1KB",
        "peripheral": "I2C5",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB1",
        "range": "0x40014400 - 0x40014FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40014000 - 0x400143FF",
        "size": "1KB",
        "peripheral": "I2C3",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB1",
        "range": "0x40013400 - 0x40013FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40013000 - 0x400133FF",
        "size": "1KB",
        "peripheral": "I2C2",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB1",
        "range": "0x40012400 - 0x40012FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40012000 - 0x400123FF",
        "size": "1KB",
        "peripheral": "I2C1",
        "peripheralmap": "I2C registers"
      },
      {
        "bus": "APB1",
        "range": "0x40011400 - 0x40011FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40011000 - 0x400113FF",
        "size": "1KB",
        "peripheral": "UART5",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x40010400 - 0x40010FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40010000 - 0x400103FF",
        "size": "1KB",
        "peripheral": "UART4",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000F400 - 0x4000FFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000F000 - 0x4000F3FF",
        "size": "1KB",
        "peripheral": "USART3",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000E400 - 0x4000EFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000E000 - 0x4000E3FF",
        "size": "1KB",
        "peripheral": "USART2",
        "peripheralmap": "USART registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000D400 - 0x4000DFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000D000 - 0x4000D3FF",
        "size": "1KB",
        "peripheral": "SPDIFRX",
        "peripheralmap": "SPDIFRX interface registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000C400 - 0x4000CFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000C000 - 0x4000C3FF",
        "size": "1KB",
        "peripheral": "SPI3",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000B400 - 0x4000BFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000B000 - 0x4000B3FF",
        "size": "1KB",
        "peripheral": "SPI2",
        "peripheralmap": "SPI/I2S registers"
      },
      {
        "bus": "APB1",
        "range": "0x4000A400 - 0x4000AFFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x4000A000 - 0x4000A3FF",
        "size": "1KB",
        "peripheral": "WWDG1",
        "peripheralmap": "WWDG registers"
      },
      {
        "bus": "APB1",
        "range": "0x40009400 - 0x40009FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40009000 - 0x400093FF",
        "size": "1KB",
        "peripheral": "LPTIM1",
        "peripheralmap": "LPTIM registers"
      },
      {
        "bus": "APB1",
        "range": "0x40008400 - 0x40008FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40008000 - 0x400083FF",
        "size": "1KB",
        "peripheral": "TIM14",
        "peripheralmap": "TIM13/TIM14 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40007400 - 0x40007FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40007000 - 0x400073FF",
        "size": "1KB",
        "peripheral": "TIM13",
        "peripheralmap": "TIM13/TIM14 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40006400 - 0x40006FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40006000 - 0x400063FF",
        "size": "1KB",
        "peripheral": "TIM12",
        "peripheralmap": "TIM12 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40005400 - 0x40005FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40005000 - 0x400053FF",
        "size": "1KB",
        "peripheral": "TIM7",
        "peripheralmap": "TIM6/TIM7 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40004400 - 0x40004FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40004000 - 0x400043FF",
        "size": "1KB",
        "peripheral": "TIM6",
        "peripheralmap": "TIM6/TIM7 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40003400 - 0x40003FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40003000 - 0x400033FF",
        "size": "1KB",
        "peripheral": "TIM5",
        "peripheralmap": "TIM2/TIM3/TIM4/TIM5 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40002400 - 0x40002FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40002000 - 0x400023FF",
        "size": "1KB",
        "peripheral": "TIM4",
        "peripheralmap": "TIM2/TIM3/TIM4/TIM5 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40001400 - 0x40001FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40001000 - 0x400013FF",
        "size": "1KB",
        "peripheral": "TIM3",
        "peripheralmap": "TIM2/TIM3/TIM4/TIM5 registers"
      },
      {
        "bus": "APB1",
        "range": "0x40000400 - 0x40000FFF",
        "size": "3KB",
        "peripheral": "Reserved",
        "peripheralmap": "-"
      },
      {
        "bus": "APB1",
        "range": "0x40000000 - 0x400003FF",
        "size": "1KB",
        "peripheral": "TIM2",
        "peripheralmap": "TIM2/TIM3/TIM4/TIM5 registers"
      }
    ]
  },
  {
    "registermaps": [
      {
        "mapname": "I2C registers",
        "registers": [
          {
            "registername": "I2C_CR1",
            "offset": "0x00",
            "page": 2559,
            "chapter": "52.9.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23",
                "field": "PECEN",
                "description": "PEC enable\n0: PEC calculation disabled\n1: PEC calculation enabled\n"
              },
              {
                "range": "22",
                "field": "ALERTEN",
                "description": "SMBus alert enable\n0: The SMBALERT# signal on SMBA pin is not supported in host mode (SMBHEN = 1). In\ndevice mode (SMBHEN = 0), the SMBA pin is released and the alert response address\nheader is disabled (0001100x followed by NACK).\n1: The SMBALERT# signal on SMBA pin is supported in host mode (SMBHEN = 1). In\ndevice mode (SMBHEN = 0), the SMBA pin is driven low and the alert response address\nheader is enabled (0001100x followed by ACK).\nNote: When ALERTEN = 0, the SMBA pin can be used as a standard GPIO.\n"
              },
              {
                "range": "21",
                "field": "SMBDEN",
                "description": "SMBus device default address enable\n0: Device default address disabled. Address 0b1100001x is NACKed.\n1: Device default address enabled. Address 0b1100001x is ACKed.\n"
              },
              {
                "range": "20",
                "field": "SMBHEN",
                "description": "SMBus host address enable\n0: Host address disabled. Address 0b0001000x is NACKed.\n1: Host address enabled. Address 0b0001000x is ACKed.\n"
              },
              {
                "range": "19",
                "field": "GCEN",
                "description": "General call enable\n0: General call disabled. Address 0b00000000 is NACKed.\n1: General call enabled. Address 0b00000000 is ACKed.\n"
              },
              {
                "range": "18",
                "field": "WUPEN",
                "description": "Wake-up from Stop mode enable\n0: Wake-up from Stop mode disabled.\n1: Wake-up from Stop mode enabled.\nNote: WUPEN can be set only when DNF[3:0] = 0000.\nRM0436 Rev 7 2559/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              },
              {
                "range": "17",
                "field": "NOSTRETCH",
                "description": "Clock stretching disable\nThis bit is used to disable clock stretching in target mode. It must be kept cleared in\ncontroller mode.\n0: Clock stretching enabled\n1: Clock stretching disabled\nNote: This bit can be programmed only when the I2C peripheral is disabled (PE = 0).\n"
              },
              {
                "range": "16",
                "field": "SBC",
                "description": "Target byte control\nThis bit is used to enable hardware byte control in target mode.\n0: Target byte control disabled\n1: Target byte control enabled\n"
              },
              {
                "range": "15",
                "field": "RXDMAEN",
                "description": "DMA reception requests enable\n0: DMA mode disabled for reception\n1: DMA mode enabled for reception\n"
              },
              {
                "range": "14",
                "field": "TXDMAEN",
                "description": "DMA transmission requests enable\n0: DMA mode disabled for transmission\n1: DMA mode enabled for transmission\n"
              },
              {
                "range": "13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "ANFOFF",
                "description": "Analog noise filter OFF\n0: Analog noise filter enabled\n1: Analog noise filter disabled\nNote: This bit can be programmed only when the I2C peripheral is disabled (PE = 0).\n"
              },
              {
                "range": "11:8",
                "field": "DNF[3:0]",
                "description": "Digital noise filter\nThese bits are used to configure the digital noise filter on SDA and SCL input. The digital\nfilter, filters spikes with a length of up to DNF[3:0] * t\nI2CCLK\n0000: Digital filter disabled\n0001: Digital filter enabled and filtering capability up to one t\nI2CCLK\n...\n1111: digital filter enabled and filtering capability up to fifteen t\nI2CCLK\nNote: If the analog filter is enabled, the digital filter is added to it. This filter can be\nprogrammed only when the I2C peripheral is disabled (PE = 0).\n"
              },
              {
                "range": "7",
                "field": "ERRIE",
                "description": "Error interrupts enable\n0: Error detection interrupts disabled\n1: Error detection interrupts enabled\nNote: Any of these errors generates an interrupt:\n- arbitration loss (ARLO)\n- bus error detection (BERR)\n- overrun/underrun (OVR)\n- timeout detection (TIMEOUT)\n- PEC error detection (PECERR)\n- alert pin event detection (ALERT)\n"
              },
              {
                "range": "6",
                "field": "TCIE",
                "description": "Transfer complete interrupt enable\n0: Transfer complete interrupt disabled\n1: Transfer complete interrupt enabled\nNote: Any of these events generates an interrupt:\nTransfer complete (TC)\nTransfer complete reload (TCR)\n2560/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              },
              {
                "range": "5",
                "field": "STOPIE",
                "description": "STOP detection interrupt enable\n0: STOP detection (STOPF) interrupt disabled\n1: STOP detection (STOPF) interrupt enabled\n"
              },
              {
                "range": "4",
                "field": "NACKIE",
                "description": "Not acknowledge received interrupt enable\n0: Not acknowledge (NACKF) received interrupts disabled\n1: Not acknowledge (NACKF) received interrupts enabled\n"
              },
              {
                "range": "3",
                "field": "ADDRIE",
                "description": "Address match interrupt enable (target only)\n0: Address match (ADDR) interrupts disabled\n1: Address match (ADDR) interrupts enabled\n"
              },
              {
                "range": "2",
                "field": "RXIE",
                "description": "RX interrupt enable\n0: Receive (RXNE) interrupt disabled\n1: Receive (RXNE) interrupt enabled\n"
              },
              {
                "range": "1",
                "field": "TXIE",
                "description": "TX interrupt enable\n0: Transmit (TXIS) interrupt disabled\n1: Transmit (TXIS) interrupt enabled\n"
              },
              {
                "range": "0",
                "field": "PE",
                "description": "Peripheral enable\n0: Peripheral disabled\n1: Peripheral enabled\nNote: When PE = 0, the I2C SCL and SDA lines are released. Internal state machines and\nstatus bits are put back to their reset value. When cleared, PE must be kept low for at\nleast three APB clock cycles.\n"
              }
            ]
          },
          {
            "registername": "I2C_CR2",
            "offset": "0x04",
            "page": 2561,
            "chapter": "52.9.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26",
                "field": "PECBYTE",
                "description": "Packet error checking byte\nThis bit is set by software, and cleared by hardware when the PEC is transferred, or when a\nSTOP condition or an Address matched is received, also when PE = 0.\n0: No PEC transfer\n1: PEC transmission/reception is requested\nNote: Writing 0 to this bit has no effect.\nThis bit has no effect when RELOAD is set, and in target mode when SBC = 0.\nRM0436 Rev 7 2561/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              },
              {
                "range": "25",
                "field": "AUTOEND",
                "description": "Automatic end mode (controller mode)\nThis bit is set and cleared by software.\n0: software end mode: TC flag is set when NBYTES data are transferred, stretching SCL low.\n1: Automatic end mode: a STOP condition is automatically sent when NBYTES data are\ntransferred.\nNote: This bit has no effect in target mode or when the RELOAD bit is set.\n"
              },
              {
                "range": "24",
                "field": "RELOAD",
                "description": "NBYTES reload mode\nThis bit is set and cleared by software.\n0: The transfer is completed after the NBYTES data transfer (STOP or RESTART follows).\n1: The transfer is not completed after the NBYTES data transfer (NBYTES is reloaded). TCR\nflag is set when NBYTES data are transferred, stretching SCL low.\n"
              },
              {
                "range": "23:16",
                "field": "NBYTES[7:0]",
                "description": "Number of bytes\nThe number of bytes to be transmitted/received is programmed there. This field is donâ€™t care\nin target mode with SBC = 0.\nNote: Changing these bits when the START bit is set is not allowed.\n"
              },
              {
                "range": "15",
                "field": "NACK",
                "description": "NACK generation (target mode)\nThe bit is set by software, cleared by hardware when the NACK is sent, or when a STOP\ncondition or an Address matched is received, or when PE = 0.\n0: an ACK is sent after current received byte.\n1: a NACK is sent after current received byte.\nNote: Writing 0 to this bit has no effect.\nThis bit is used only in target mode: in controller receiver mode, NACK is automatically\ngenerated after last byte preceding STOP or RESTART condition, whatever the NACK\nbit value.\nWhen an overrun occurs in target receiver NOSTRETCH mode, a NACK is\nautomatically generated, whatever the NACK bit value.\nWhen hardware PEC checking is enabled (PECBYTE = 1), the PEC acknowledge value\ndoes not depend on the NACK value.\n"
              },
              {
                "range": "14",
                "field": "STOP",
                "description": "STOP condition generation\nThis bit only pertains to controller mode. It is set by software and cleared by hardware when\na STOP condition is detected or when PE = 0.\n0: No STOP generation\n1: STOP generation after current byte transfer\nNote: Writing 0 to this bit has no effect.\n"
              },
              {
                "range": "13",
                "field": "START",
                "description": "START condition generation\nThis bit is set by software. It is cleared by hardware after the START condition followed by\nthe address sequence is sent, by an arbitration loss, by a timeout error detection, or when\nPE = 0. It can also be cleared by software, by setting the ADDRCF bit of the I2C_ICR\nregister.\n0: No START generation\n1: RESTART/START generation:\nIf the I2C is already in controller mode with AUTOEND = 0, setting this bit generates a\nrepeated START condition when RELOAD = 0, after the end of the NBYTES transfer.\nOtherwise, setting this bit generates a START condition once the bus is free.\nNote: Writing 0 to this bit has no effect.\nThe START bit can be set even if the bus is BUSY or I2C is in target mode.\nThis bit has no effect when RELOAD is set.\n2562/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              },
              {
                "range": "12",
                "field": "HEAD10R",
                "description": "10-bit address header only read direction (controller receiver mode)\n0: The controller sends the complete 10-bit target address read sequence: START + 2 bytes\n10-bit address in write direction + RESTART + first seven bits of the 10-bit address in read\ndirection.\n1: The controller sends only the first seven bits of the 10-bit address, followed by read\ndirection.\nNote: Changing this bit when the START bit is set is not allowed.\n"
              },
              {
                "range": "11",
                "field": "ADD10",
                "description": "10-bit addressing mode (controller mode)\n0: The controller operates in 7-bit addressing mode\n1: The controller operates in 10-bit addressing mode\nNote: Changing this bit when the START bit is set is not allowed.\n"
              },
              {
                "range": "10",
                "field": "RD_WRN",
                "description": "Transfer direction (controller mode)\n0: Controller requests a write transfer\n1: Controller requests a read transfer\nNote: Changing this bit when the START bit is set is not allowed.\n"
              },
              {
                "range": "9:0",
                "field": "SADD[9:0]",
                "description": "Target address (controller mode)\nCondition: In 7-bit addressing mode (ADD10 = 0):\nSADD[7:1] must be written with the 7-bit target address to be sent. Bits SADD[9], SADD[8]\nand SADD[0] are don't care.\nCondition: In 10-bit addressing mode (ADD10 = 1):\nSADD[9:0] must be written with the 10-bit target address to be sent.\nNote: Changing these bits when the START bit is set is not allowed.\n"
              }
            ]
          },
          {
            "registername": "I2C_OAR1",
            "offset": "0x08",
            "page": 2563,
            "chapter": "52.9.3",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "OA1EN",
                "description": "Own address 1 enable\n0: Own address 1 disabled. The received target address OA1 is NACKed.\n1: Own address 1 enabled. The received target address OA1 is ACKed.\n"
              },
              {
                "range": "14:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2563/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              },
              {
                "range": "10",
                "field": "OA1MODE",
                "description": "Own address 1 10-bit mode\n0: Own address 1 is a 7-bit address.\n1: Own address 1 is a 10-bit address.\nNote: This bit can be written only when OA1EN = 0.\n"
              },
              {
                "range": "9:0",
                "field": "OA1[9:0]",
                "description": "Interface own target address\n7-bit addressing mode: OA1[7:1] contains the 7-bit own target address. Bits OA1[9], OA1[8]\nand OA1[0] are don't care.\n10-bit addressing mode: OA1[9:0] contains the 10-bit own target address.\nNote: These bits can be written only when OA1EN = 0.\n"
              }
            ]
          },
          {
            "registername": "I2C_OAR2",
            "offset": "0x0C",
            "page": 2564,
            "chapter": "52.9.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "OA2EN",
                "description": "Own address 2 enable\n0: Own address 2 disabled. The received target address OA2 is NACKed.\n1: Own address 2 enabled. The received target address OA2 is ACKed.\n"
              },
              {
                "range": "14:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:8",
                "field": "OA2MSK[2:0]",
                "description": "Own address 2 masks\n000: No mask\n001: OA2[1] is masked and donâ€™t care. Only OA2[7:2] are compared.\n010: OA2[2:1] are masked and donâ€™t care. Only OA2[7:3] are compared.\n011: OA2[3:1] are masked and donâ€™t care. Only OA2[7:4] are compared.\n100: OA2[4:1] are masked and donâ€™t care. Only OA2[7:5] are compared.\n101: OA2[5:1] are masked and donâ€™t care. Only OA2[7:6] are compared.\n110: OA2[6:1] are masked and donâ€™t care. Only OA2[7] is compared.\n111: OA2[7:1] are masked and donâ€™t care. No comparison is done, and all (except reserved)\n7-bit received addresses are acknowledged.\nNote: These bits can be written only when OA2EN = 0.\nAs soon as OA2MSK â‰  0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are\nnot acknowledged, even if the comparison matches.\n"
              },
              {
                "range": "7:1",
                "field": "OA2[7:1]",
                "description": "Interface address\n7-bit addressing mode: 7-bit address\nNote: These bits can be written only when OA2EN = 0.\n2564/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              },
              {
                "range": "0",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              }
            ]
          },
          {
            "registername": "I2C_TIMINGR",
            "offset": "0x10",
            "page": 2565,
            "chapter": "52.9.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:28",
                "field": "PRESC[3:0]",
                "description": "Timing prescaler\nThis field is used to prescale i2c_ker_ck to generate the clock period t used for data\nPRESC\nsetup and hold counters (refer to section I2C timings), and for SCL high and low level\ncounters (refer to section I2C controller initialization).\nt = (PRESC + 1) x t\nPRESC I2CCLK\n"
              },
              {
                "range": "27:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:20",
                "field": "SCLDEL[3:0]",
                "description": "Data setup time\nThis field is used to generate a delay t = (SCLDEL + 1) x t between SDA edge\nSCLDEL PRESC\nand SCL rising edge. In controller and in target modes with NOSTRETCH = 0, the SCL line is\nstretched low during t .\nSCLDEL\nNote: t is used to generate t timing.\nSCLDEL SU:DAT\n"
              },
              {
                "range": "19:16",
                "field": "SDADEL[3:0]",
                "description": "Data hold time\nThis field is used to generate the delay t between SCL falling edge and SDA edge. In\nSDADEL\ncontroller and in target modes with NOSTRETCH = 0, the SCL line is stretched low during\nt .\nSDADEL\nt = SDADEL x t\nSDADEL PRESC\nNote: SDADEL is used to generate t timing.\nHD:DAT\n"
              },
              {
                "range": "15:8",
                "field": "SCLH[7:0]",
                "description": "SCL high period (controller mode)\nThis field is used to generate the SCL high period in controller mode.\nt = (SCLH + 1) x t\nSCLH PRESC\nNote: SCLH is also used to generate t and t timing.\nSU:STO HD:STA\n"
              },
              {
                "range": "7:0",
                "field": "SCLL[7:0]",
                "description": "SCL low period (controller mode)\nThis field is used to generate the SCL low period in controller mode.\nt = (SCLL + 1) x t\nSCLL PRESC\nNote: SCLL is also used to generate t and t timings.\nBUF SU:STA\nNote: This register must be configured when the I2C peripheral is disabled (PE = 0).\nNote: The STM32CubeMX tool calculates and provides the I2C_TIMINGR content in the I2C\nConfiguration window.\nRM0436 Rev 7 2565/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              }
            ]
          },
          {
            "registername": "I2C_TIMEOUTR",
            "offset": "0x14",
            "page": 2566,
            "chapter": "52.9.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "TEXTEN",
                "description": "Extended clock timeout enable\n0: Extended clock timeout detection is disabled\n1: Extended clock timeout detection is enabled. When a cumulative SCL stretch for more\nthan t is done by the I2C interface, a timeout error is detected (TIMEOUT = 1).\nLOW:EXT\n"
              },
              {
                "range": "30:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27:16",
                "field": "TIMEOUTB[11:0]",
                "description": "Bus timeout B\nThis field is used to configure the cumulative clock extension timeout:\nâ€“ Controller mode: the controller cumulative clock low extend time (t ) is\nLOW:MEXT\ndetected\nâ€“ Target mode: the target cumulative clock low extend time (t ) is detected\nLOW:SEXT\nt = (TIMEOUTB + TIDLE = 01) x 2048 x t\nLOW:EXT I2CCLK\nNote: These bits can be written only when TEXTEN = 0.\n"
              },
              {
                "range": "15",
                "field": "TIMOUTEN",
                "description": "Clock timeout enable\n0: SCL timeout detection is disabled\n1: SCL timeout detection is enabled. When SCL is low for more than t (TIDLE = 0) or\nTIMEOUT\nhigh for more than t (TIDLE = 1), a timeout error is detected (TIMEOUT = 1).\nIDLE\n"
              },
              {
                "range": "14:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "TIDLE",
                "description": "Idle clock timeout detection\n0: TIMEOUTA is used to detect SCL low timeout\n1: TIMEOUTA is used to detect both SCL and SDA high timeout (bus idle condition)\nNote: This bit can be written only when TIMOUTEN = 0.\n"
              },
              {
                "range": "11:0",
                "field": "TIMEOUTA[11:0]",
                "description": "Bus timeout A\nThis field is used to configure:\nThe SCL low timeout condition t when TIDLE = 0\nTIMEOUT\nt = (TIMEOUTA + 1) x 2048 x t\nTIMEOUT I2CCLK\nThe bus idle condition (both SCL and SDA high) when TIDLE = 1\nt = (TIMEOUTA + 1) x 4 x t\nIDLE I2CCLK\nNote: These bits can be written only when TIMOUTEN = 0.\n2566/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              }
            ]
          },
          {
            "registername": "I2C_ISR",
            "offset": "0x18",
            "page": 2567,
            "chapter": "52.9.7",
            "resetvalue": "0x00000001",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:17",
                "field": "ADDCODE[6:0]",
                "description": "Address match code (target mode)\nThese bits are updated with the received address when an address match event occurs\n(ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed\nby the two MSBs of the address.\n"
              },
              {
                "range": "16",
                "field": "DIR",
                "description": "Transfer direction (target mode)\nThis flag is updated when an address match event occurs (ADDR = 1).\n0: Write transfer, target enters receiver mode.\n1: Read transfer, target enters transmitter mode.\n"
              },
              {
                "range": "15",
                "field": "BUSY",
                "description": "Bus busy\nThis flag indicates that a communication is in progress on the bus. It is set by hardware\nwhen a START condition is detected, and cleared by hardware when a STOP condition is\ndetected, or when PE = 0.\n"
              },
              {
                "range": "14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13",
                "field": "ALERT",
                "description": "SMBus alert\nThis flag is set by hardware when SMBHEN = 1 (SMBus host configuration), ALERTEN = 1\nand an SMBALERT# event (falling edge) is detected on SMBA pin. It is cleared by software\nby setting the ALERTCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "12",
                "field": "TIMEOUT",
                "description": "Timeout or t detection flag\nLOW\nThis flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared\nby software by setting the TIMEOUTCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "11",
                "field": "PECERR",
                "description": "PEC error in reception\nThis flag is set by hardware when the received PEC does not match with the PEC register\ncontent. A NACK is automatically sent after the wrong PEC reception. It is cleared by\nsoftware by setting the PECCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "10",
                "field": "OVR",
                "description": "Overrun/underrun (target mode)\nThis flag is set by hardware in target mode with NOSTRETCH = 1, when an\noverrun/underrun error occurs. It is cleared by software by setting the OVRCF bit.\nNote: This bit is cleared by hardware when PE = 0.\nRM0436 Rev 7 2567/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              },
              {
                "range": "9",
                "field": "ARLO",
                "description": "Arbitration lost\nThis flag is set by hardware in case of arbitration loss. It is cleared by software by setting the\nARLOCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "8",
                "field": "BERR",
                "description": "Bus error\nThis flag is set by hardware when a misplaced START or STOP condition is detected\nwhereas the peripheral is involved in the transfer. The flag is not set during the address\nphase in target mode. It is cleared by software by setting the BERRCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "7",
                "field": "TCR",
                "description": "Transfer complete reload\nThis flag is set by hardware when RELOAD = 1 and NBYTES data have been transferred. It\nis cleared by software when NBYTES is written to a non-zero value.\nNote: This bit is cleared by hardware when PE = 0.\nThis flag is only for controller mode, or for target mode when the SBC bit is set.\n"
              },
              {
                "range": "6",
                "field": "TC",
                "description": "Transfer complete (controller mode)\nThis flag is set by hardware when RELOAD = 0, AUTOEND = 0 and NBYTES data have\nbeen transferred. It is cleared by software when START bit or STOP bit is set.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "5",
                "field": "STOPF",
                "description": "STOP detection flag\nThis flag is set by hardware when a STOP condition is detected on the bus and the\nperipheral is involved in this transfer:\nâ€“ as a controller, provided that the STOP condition is generated by the peripheral.\nâ€“ as a target, provided that the peripheral has been addressed previously during this\ntransfer.\nIt is cleared by software by setting the STOPCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "4",
                "field": "NACKF",
                "description": "Not acknowledge received flag\nThis flag is set by hardware when a NACK is received after a byte transmission. It is cleared\nby software by setting the NACKCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "3",
                "field": "ADDR",
                "description": "Address matched (target mode)\nThis bit is set by hardware as soon as the received target address matched with one of the\nenabled target addresses. It is cleared by software by setting ADDRCF bit.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "2",
                "field": "RXNE",
                "description": "Receive data register not empty (receivers)\nThis bit is set by hardware when the received data is copied into the I2C_RXDR register, and\nis ready to be read. It is cleared when I2C_RXDR is read.\nNote: This bit is cleared by hardware when PE = 0.\n"
              },
              {
                "range": "1",
                "field": "TXIS",
                "description": "Transmit interrupt status (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty and the data to be\ntransmitted must be written in the I2C_TXDR register. It is cleared when the next data to be\nsent is written in the I2C_TXDR register.\nThis bit can be written to 1 by software only when NOSTRETCH = 1, to generate a TXIS\nevent (interrupt if TXIE = 1 or DMA request if TXDMAEN = 1).\nNote: This bit is cleared by hardware when PE = 0.\n2568/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              },
              {
                "range": "0",
                "field": "TXE",
                "description": "Transmit data register empty (transmitters)\nThis bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next\ndata to be sent is written in the I2C_TXDR register.\nThis bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR.\nNote: This bit is set by hardware when PE = 0.\n"
              }
            ]
          },
          {
            "registername": "I2C_ICR",
            "offset": "0x1C",
            "page": 2569,
            "chapter": "52.9.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13",
                "field": "ALERTCF",
                "description": "Alert flag clear\nWriting 1 to this bit clears the ALERT flag in the I2C_ISR register.\n"
              },
              {
                "range": "12",
                "field": "TIMOUTCF",
                "description": "Timeout detection flag clear\nWriting 1 to this bit clears the TIMEOUT flag in the I2C_ISR register.\n"
              },
              {
                "range": "11",
                "field": "PECCF",
                "description": "PEC error flag clear\nWriting 1 to this bit clears the PECERR flag in the I2C_ISR register.\n"
              },
              {
                "range": "10",
                "field": "OVRCF",
                "description": "Overrun/underrun flag clear\nWriting 1 to this bit clears the OVR flag in the I2C_ISR register.\n"
              },
              {
                "range": "9",
                "field": "ARLOCF",
                "description": "Arbitration lost flag clear\nWriting 1 to this bit clears the ARLO flag in the I2C_ISR register.\n"
              },
              {
                "range": "8",
                "field": "BERRCF",
                "description": "Bus error flag clear\nWriting 1 to this bit clears the BERRF flag in the I2C_ISR register.\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "STOPCF",
                "description": "STOP detection flag clear\nWriting 1 to this bit clears the STOPF flag in the I2C_ISR register.\n"
              },
              {
                "range": "4",
                "field": "NACKCF",
                "description": "Not acknowledge flag clear\nWriting 1 to this bit clears the NACKF flag in I2C_ISR register.\n"
              },
              {
                "range": "3",
                "field": "ADDRCF",
                "description": "Address matched flag clear\nWriting 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also\nclears the START bit in the I2C_CR2 register.\n"
              },
              {
                "range": "2:0",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2569/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              }
            ]
          },
          {
            "registername": "I2C_PECR",
            "offset": "0x20",
            "page": 2570,
            "chapter": "52.9.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:0",
                "field": "PEC[7:0]",
                "description": "Packet error checking register\nThis field contains the internal PEC when PECEN=1.\nThe PEC is cleared by hardware when PE = 0.\n"
              }
            ]
          },
          {
            "registername": "I2C_RXDR",
            "offset": "0x24",
            "page": 2570,
            "chapter": "52.9.10",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:0",
                "field": "RXDATA[7:0]",
                "description": "8-bit receive data\nData byte received from the IÂ²C-bus.\n2570/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              }
            ]
          },
          {
            "registername": "I2C_TXDR",
            "offset": "0x28",
            "page": 2571,
            "chapter": "52.9.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:0",
                "field": "TXDATA[7:0]",
                "description": "8-bit transmit data\nData byte to be transmitted to the IÂ²C-bus\nNote: These bits can be written only when TXE = 1.\n"
              }
            ]
          },
          {
            "registername": "I2C_HWCFGR",
            "offset": "0x3F0",
            "page": 2571,
            "chapter": "52.9.12",
            "resetvalue": "0x00000111",
            "bits": [
              {
                "range": "31:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "WKP[3:0]",
                "description": "\n0: Wake-up from Stop mode not implemented\n1: Wake-up from Stop mode implemented\n"
              },
              {
                "range": "7:4",
                "field": "ASYN[3:0]",
                "description": "\n0: Independent kernel clock not implemented\n1: Independent kernel clock implemented\n"
              },
              {
                "range": "3:0",
                "field": "SMBUS[3:0]",
                "description": "\n0: SMBus mode not implemented\n1: SMBus mode implemented\nRM0436 Rev 7 2571/4054\n2574\nInter-integrated circuit interface (I2C) RM0436\n"
              }
            ]
          },
          {
            "registername": "I2C_VERR",
            "offset": "0x3F4",
            "page": 2572,
            "chapter": "52.9.13",
            "resetvalue": "0x00000013",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "Major revision\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "Minor revision\n"
              }
            ]
          },
          {
            "registername": "I2C_IPIDR",
            "offset": "0x3F8",
            "page": 2572,
            "chapter": "52.9.14",
            "resetvalue": "0x00130012",
            "bits": [
              {
                "range": "31:0",
                "field": "ID[31:0]",
                "description": "Identifier.\n"
              }
            ]
          },
          {
            "registername": "I2C_SIDR",
            "offset": "0x3FC",
            "page": 2572,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SID[31:0]",
                "description": "Size identifier.\n2572/4054 RM0436 Rev 7\nRM0436 Inter-integrated circuit interface (I2C)\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "SPI/I2S registers",
        "registers": [
          {
            "registername": "SPI_CR1",
            "offset": "0x00",
            "page": 2723,
            "chapter": "54.11.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "IOLOCK",
                "description": "locking the AF configuration of associated I/Os\nThis bit is set by software and cleared by hardware whenever SPE bit is changed from 1 to 0.\n0: AF configuration is not locked\n1: AF configuration is locked\nWhen this bit is set, the SPI_CFG2 register content cannot be modified. This bit can be set\nwhen SPI is disabled only else it is write protected. It is cleared and cannot be set when the\nMODF bit is set.\n"
              },
              {
                "range": "15",
                "field": "TCRCINI",
                "description": "CRC calculation initialization pattern control for transmitter\n0: All zero pattern is applied\n1: All ones pattern is applied\n"
              },
              {
                "range": "14",
                "field": "RCRCINI",
                "description": "CRC calculation initialization pattern control for receiver\n0: all zero pattern is applied\n1: all ones pattern is applied\n"
              },
              {
                "range": "13",
                "field": "CRC33_17",
                "description": "32-bit CRC polynomial configuration\n0: full size (33-bit or 17-bit) CRC polynomial is not used\n1: full size (33-bit or 17-bit) CRC polynomial is used\n"
              },
              {
                "range": "12",
                "field": "SSI",
                "description": "internal SS signal input level\nThis bit has an effect only when the SSM bit is set. The value of this bit is forced onto the\nperipheral SS input and the I/O value of the SS pin is ignored.\n"
              },
              {
                "range": "11",
                "field": "HDDIR",
                "description": "Rx/Tx direction at Half-duplex mode\nIn Half-Duplex configuration the HDDIR bit establishes the Rx/Tx direction of the data\ntransfer. This bit is ignored in Full-Duplex or any Simplex configuration.\n0: SPI is Receiver\n1: SPI is transmitter\nRM0436 Rev 7 2723/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "10",
                "field": "CSUSP",
                "description": "master suspend request\nThis bit reads as zero.\nIn master mode, when this bit is set by software, CSTART bit is reset at the end of the current\nframe and communication is suspended. The user has to check SUSP flag to check end of\nthe frame transaction.\nThe master mode communication must be suspended (using this bit or keeping TXDR\nempty) before disabling the SPI or going to low-power mode. This bit can be used in SPI or\nI2S mode.\nAfter software suspension, the SUSP flag has to be cleared and the SPI disabled and re-\nenabled before any next transaction starts.\n"
              },
              {
                "range": "9",
                "field": "CSTART",
                "description": "master transfer start\nThis bit is set by software to start an SPI or I2S/PCM communication. In SPI mode, it is\ncleared by hardware when End Of Transfer (EOT) flag is set or when a transaction suspend\nrequest is accepted. In I2S/PCM mode, it is also cleared by hardware as described in the\nsection stop sequence.\n0: master transfer is at idle\n1: master transfer is on-going or temporary suspended by automatic suspend\nIn SPI mode, the bit is taken into account at master mode only. If transmission is enabled,\ncommunication starts or continues only if any data is available in the transmission FIFO.\n"
              },
              {
                "range": "8",
                "field": "MASRX",
                "description": "master automatic SUSP in Receive mode\nThis bit is set and cleared by software to control continuous SPI transfer in master receiver\nmode and automatic management in order to avoid overrun condition.\n0: SPI flow/clock generation is continuous, regardless of overrun condition. (data are lost)\n1: SPI flow is suspended temporary on RxFIFO full condition, before reaching overrun\ncondition. The SUSP flag is set when SPI communication is suspended.\nWhen SPI communication is suspended by hardware automatically, it could happen that few\nbits of next frame are already clocked out due to internal synchronization delay.\nThat is why the automatic suspension is not quite reliable when size of data drops below 8\nbits. In this case, a safe suspension can be achieved by combination with delay inserted\nbetween data frames applied when MIDI parameter keeps a non zero value; sum of data size\nand the interleaved SPI cycles must always produce interval at length of 8 SPI clock periods\nat minimum. After software clearing of the SUSP bit, the communication resumes and\ncontinues by subsequent bits transaction without any next constraint. Prior the SUSP bit is\ncleared, the user must release the RxFIFO space as much as possible by reading out all the\ndata packets available at RxFIFO based on the RXP flag indication to prevent any\nsubsequent suspension.\n"
              },
              {
                "range": "7:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "SPE",
                "description": "serial peripheral enable\nThis bit is set by and cleared by software.\n0: serial peripheral disabled.\n1: serial peripheral enabled\nWhen SPE=1, the SPI data transfer is enabled, the configuration registers SPI_CFG1,\nSPI_CFG2, CRCPOLY and UDRDR and the IOLOCK bit in SPI_CR1 are write protected.\nThey can be changed only when SPE=0.\nWhen SPE=0 any SPI operation is stopped and disabled, all the not cleared requests with\nenabled interrupt stay pending and propagates the spi_plck clock request, the SS output is\ndeactivated at master, internal state machine is reseted, all the FIFOs content is flushed,\nCRC calculation initialized, receive data register is read zero.\nSPE is cleared and cannot be set when MODF error flag is active.\n2724/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              }
            ]
          },
          {
            "registername": "SPI_CR2",
            "offset": "0x04",
            "page": 2725,
            "chapter": "54.11.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "TSER[15:0]",
                "description": "number of data transfer extension to be reload into TSIZE just when a previous\nnumber of data stored at TSIZE is transacted\nThis register can be set by software when its content is cleared only. It is cleared by hardware\nonce TSIZE reload is done. The TSER value must be programmed in advance before\nCTSIZE counter reaches zero otherwise the reload is not taken into account and traffic\nterminates with normal EOT event.\n"
              },
              {
                "range": "15:0",
                "field": "TSIZE[15:0]",
                "description": "number of data at current transfer\nWhen these bits are changed by software, the SPI must be disabled. The field can be\nupdated by hardware optionally, too, to be reloaded by the TSER value if applicable.\nEndless transaction is initialized when CSTART is set while zero value is stored at TSIZE.\nTSIZE cannot be set to 0xFFFF value when CRC is enabled.\n"
              }
            ]
          },
          {
            "registername": "SPI_CFG1",
            "offset": "0x08",
            "page": 2725,
            "chapter": "54.11.3",
            "resetvalue": "0x00070007",
            "bits": [
              {
                "range": "31",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2725/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "30:28",
                "field": "MBR[2:0]",
                "description": "master baud rate\n000: SPI master clock/2\n001: SPI master clock/4\n010: SPI master clock/8\n011: SPI master clock/16\n100: SPI master clock/32\n101: SPI master clock/64\n110: SPI master clock/128\n111: SPI master clock/256\nNote: MBR setting is considered at slave working at TI mode, too (see Section54.5.1: TI\nmode).\n"
              },
              {
                "range": "27:23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22",
                "field": "CRCEN",
                "description": "hardware CRC computation enable\n0: CRC calculation disabled\n1: CRC calculation Enabled\n"
              },
              {
                "range": "21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20:16",
                "field": "CRCSIZE[4:0]",
                "description": "length of CRC frame to be transacted and compared\nMost significant bits are taken into account from polynomial calculation when CRC result is\ntransacted or compared. The length of the polynomial is not affected by this setting.\n00000: reserved\n00001: reserved\n00010: reserved\n00011: 4-bits\n00100: 5-bits\n00101: 6-bits\n00110: 7-bits\n00111: 8-bits\n.....\n11101: 30-bits\n11110: 31-bits\n11111: 32-bits\nThe value must be set equal or multiply of data size (DSIZE[4:0]). Its maximum size cannot\nexceed the DSIZE maximum at the instance.\nNote: If CRC calculation is disabled by CRCEN=0, the CRCSIZE field must be kept at its\ndefault setting.\nNote: The most significant bit at CRCSIZE bit field is reserved at the peripheral instances\nwhere the data size is limited to 16-bit.\n"
              },
              {
                "range": "15",
                "field": "TXDMAEN",
                "description": "Tx DMA stream enable\n0: Tx DMA disabled\n1: Tx DMA enabled\n"
              },
              {
                "range": "14",
                "field": "RXDMAEN",
                "description": "Rx DMA stream enable\n0: Rx-DMA disabled\n1: Rx-DMA enabled\n"
              },
              {
                "range": "13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n2726/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "12:11",
                "field": "UDRDET[1:0]",
                "description": "detection of underrun condition at slave transmitter\n00: underrun is detected at begin of data frame (no protection of 1-st bit)\n01: underrun is detected at end of last data frame\n10: underrun is detected by begin of active SS signal\n11: reserved\nFor more details see Figure624: Optional configurations of slave behavior at detection of\nunderrun condition.\n"
              },
              {
                "range": "10:9",
                "field": "UDRCFG[1:0]",
                "description": "behavior of slave transmitter at underrun condition\n00: slave sends a constant pattern defined by the user at SPI_UDRDR register\n01: slave repeats lastly received data frame from master\n10: slave repeats its lastly transmitted data frame\n11: reserved\nWhen slave is configured at transmit only mode (COMM[1:0]=01), slave repeats all zeros\npattern at UDRCFG[1:0]=01 setting.\nFor more details see Figure624: Optional configurations of slave behavior at detection of\nunderrun condition.\n"
              },
              {
                "range": "8:5",
                "field": "FTHLV[3:0]",
                "description": "FIFO threshold level\nDefines number of data frames at single data packet. The size of the packet must not exceed\n1/2 of FIFO space.\n0000: 1-data\n0001: 2-data\n0010: 3-data\n0011: 4-data\n0100: 5-data\n0101: 6-data\n0110: 7-data\n0111: 8-data\n1000: 9-data\n1001: 10-data\n1010: 11-data\n1011: 12-data\n1100: 13-data\n1101: 14-data\n1110: 15-data\n1111: 16-data\nSPI interface is more efficient if configured packet sizes are aligned with data register access\nparallelism:\nâ€“ If SPI data register is accessed as a 16-bit register and DSIZEâ‰¤8 bits, better to select\nFTHLV=2, 4, 6 ..,\nâ€“ If SPI data register is accessed as a 32-bit register and DSIZE>8bit, better to select\nFTHLV=2, 4, 6 .., while if DSIZEâ‰¤8 bits, better to select FTHLV=4, 8, 12 ..\nRM0436 Rev 7 2727/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "4:0",
                "field": "DSIZE[4:0]",
                "description": "number of bits in at single SPI data frame\n00000: not used\n00001: not used\n00010: not used\n00011: 4-bits\n00100: 5-bits\n00101: 6-bits\n00110: 7-bits\n00111: 8-bits\n.....\n11101: 30-bits\n11110: 31-bits\n11111: 32-bits\nNote: The most significant bit at DSIZE bit field is reserved at the peripheral instances where\ndata size is limited to 16-bit.\n"
              }
            ]
          },
          {
            "registername": "SPI_CFG2",
            "offset": "0x0C",
            "page": 2728,
            "chapter": "54.11.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "AFCNTR",
                "description": "alternate function GPIOs control\nThis bit is taken into account when SPE=0 only\n0: the peripheral takes no control of GPIOs while it is disabled\n1: the peripheral keeps always control of all associated GPIOs\nWhen SPI master has to be disabled temporary for a specific configuration reason (e.g. CRC\nreset, CPHA or HDDIR change) setting this bit prevents any glitches on the associated\noutputs configured at alternate function mode by keeping them forced at state corresponding\nthe current SPI configuration. This bit must be never used at slave mode as any slave\ntransmitter must not force its MISO output once the SPI is disabled.\nNote: This bit can be also used in PCM and I2S modes.\n"
              },
              {
                "range": "30",
                "field": "SSOM",
                "description": "SS output management in master mode\nThis bit is taken into account in master mode when SSOE is enabled. It allows to configure SS\noutput between two consecutive data transfers.\n0: SS is kept at active level till data transfer is completed, it becomes inactive with EOT flag\n1: SPI data frames are interleaved with SS non active pulses when MIDI[3:0]>1\n2728/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "29",
                "field": "SSOE",
                "description": "SS output enable\nThis bit is taken into account at master mode only\n0: SS output is disabled and the SPI can work in multimaster configuration\n1: SS output is enabled. The SPI cannot work in a multimaster environment. It forces the SS\npin at inactive level after the transfer is completed or SPI is disabled with respect to SSOM,\nMIDI, MSSI, SSIOP bits setting\n"
              },
              {
                "range": "28",
                "field": "SSIOP",
                "description": "SS input/output polarity\n0: low level is active for SS signal\n1: high level is active for SS signal\n"
              },
              {
                "range": "27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26",
                "field": "SSM",
                "description": "software management of SS signal input\n0: SS input value is determined by the SS PAD\n1: SS input value is determined by the SSI bit\nWhen master uses hardware SS output (SSM=0 and SSOE=1), the SS signal input is forced\nto non active state internally to prevent master mode fault error.\n"
              },
              {
                "range": "25",
                "field": "CPOL",
                "description": "clock polarity\n0: SCK signal is at 0 when idle\n1: SCK signal is at 1 when idle\n"
              },
              {
                "range": "24",
                "field": "CPHA",
                "description": "clock phase\n0: the first clock transition is the first data capture edge\n1: the second clock transition is the first data capture edge\n"
              },
              {
                "range": "23",
                "field": "LSBFRST",
                "description": "data frame format\n0: MSB transmitted first\n1: LSB transmitted first\nNote: This bit can be also used in PCM and I2S modes.\n"
              },
              {
                "range": "22",
                "field": "MASTER",
                "description": "SPI master\n0: SPI Slave\n1: SPI Master\n"
              },
              {
                "range": "21:19",
                "field": "SP[2:0]",
                "description": "Serial protocol\n000: SPI Motorola\n001: SPI TI\nothers: Reserved, must not be used\n"
              },
              {
                "range": "18:17",
                "field": "COMM[1:0]",
                "description": "SPI communication mode\n00: full-duplex\n01: simplex transmitter\n10: simplex receiver\n11: half-duplex\n"
              },
              {
                "range": "16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "IOSWP",
                "description": "swap functionality of MISO and MOSI pins\n0: no swap\n1: MOSI and MISO are swapped\nWhen this bit is set, the function of MISO and MOSI pins alternate functions are inverted.\nOriginal MISO pin becomes MOSI and original MOSI pin becomes MISO.\nNote: This bit can be also used in PCM and I2S modes.\n"
              },
              {
                "range": "14:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2729/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "7:4",
                "field": "MIDI[3:0]",
                "description": "master Inter-Data Idleness\nSpecifies minimum time delay (expressed in SPI clock cycles periods) inserted between two\nconsecutive data frames in master mode.\n0000: no delay\n0001: 1 clock cycle period delay\n...\n1111: 15 clock cycle periods delay\nNote: This feature is not supported in TI mode.\n"
              },
              {
                "range": "3:0",
                "field": "MSSI[3:0]",
                "description": "master SS idleness\nSpecifies an extra delay, expressed in number of SPI clock cycle periods, inserted\nadditionally between active edge of SS and first data of a session start in master mode when\nSSOE is enabled.\n0000: no extra delay\n0001: 1 clock cycle period delay added\n...\n1111: 15 clock cycle periods delay added\nNote: This feature is not supported in TI mode.\n"
              }
            ]
          },
          {
            "registername": "SPI_IER",
            "offset": "0x10",
            "page": 2730,
            "chapter": "54.11.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10",
                "field": "TSERFIE",
                "description": "additional number of transactions reload interrupt enable\n0: TSERF interrupt disabled\n1: TSERF interrupt enabled\n"
              },
              {
                "range": "9",
                "field": "MODFIE",
                "description": "mode fault interrupt enable\n0: MODF interrupt disabled\n1: MODF interrupt enabled\n"
              },
              {
                "range": "8",
                "field": "TIFREIE",
                "description": "TIFRE interrupt enable\n0: TIFRE interrupt disabled\n1: TIFRE interrupt enabled\n"
              },
              {
                "range": "7",
                "field": "CRCEIE",
                "description": "CRC error interrupt enable\n0: CRC interrupt disabled\n1: CRC interrupt enabled\n"
              },
              {
                "range": "6",
                "field": "OVRIE",
                "description": "OVR interrupt enable\n0: OVR interrupt disabled\n1: OVR interrupt enabled\n2730/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "5",
                "field": "UDRIE",
                "description": "UDR interrupt enable\n0: UDR interrupt disabled\n1: UDR interrupt enabled\n"
              },
              {
                "range": "4",
                "field": "TXTFIE",
                "description": "TXTFIE interrupt enable\n0: TXTF interrupt disabled\n1: TXTF interrupt enabled\n"
              },
              {
                "range": "3",
                "field": "EOTIE",
                "description": "EOT, SUSP and TXC interrupt enable\n0: EOT/SUSP/TXC interrupt disabled\n1: EOT/SUSP/TXC interrupt enabled\n"
              },
              {
                "range": "2",
                "field": "DXPIE",
                "description": "DXP interrupt enabled\nDXPIE is set by software and cleared by TXTF flag set event.\n0: DXP interrupt disabled\n1: DXP interrupt enabled\n"
              },
              {
                "range": "1",
                "field": "TXPIE",
                "description": "TXP interrupt enable\nTXPIE is set by software and cleared by TXTF flag set event.\n0: TXP interrupt disabled\n1: TXP interrupt enabled\n"
              },
              {
                "range": "0",
                "field": "RXPIE",
                "description": "RXP Interrupt Enable\n0: RXP interrupt disabled\n1: RXP interrupt enabled\n"
              }
            ]
          },
          {
            "registername": "SPI_SR",
            "offset": "0x14",
            "page": 2731,
            "chapter": "54.11.6",
            "resetvalue": "0x00001002",
            "bits": [
              {
                "range": "31:16",
                "field": "CTSIZE[15:0]",
                "description": "number of data frames remaining in current TSIZE session\nThe value is not quite reliable when traffic is ongoing on bus and at LP mode too.\n"
              },
              {
                "range": "15",
                "field": "RXWNE",
                "description": "RxFIFO word not empty\n0: less than four bytes of RxFIFO space is occupied by data\n1: at least four bytes of RxFIFO space is occupied by data\nNote: This bit value does not depend on DSIZE setting and keeps together with RXPLVL[1:0]\ninformation about RxFIFO occupancy by residual data.\nRM0436 Rev 7 2731/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "14:13",
                "field": "RXPLVL[1:0]",
                "description": "RxFIFO packing level\nWhen RXWNE=0 and data size is set up to 16-bit, the value gives number of remaining data\nframes persisting at RxFIFO.\n00: no next frame is available at RxFIFO\n01: 1 frame is available\n10: 2 frames are available*\n11: 3 frames are available*\n(*) optional count when the data size is set up to 8-bit.\nWhen the frame size is greater than 16-bit, these bits read as 00. In consequence, the single\ndata frame received at the FIFO cannot be detected neither by RWNE nor by RXPLVL bits if\ndata size is set from 17 to 24 bits. The user then must apply other methods like TSIZE>0 or\nFTHLV=0.\n"
              },
              {
                "range": "12",
                "field": "TXC",
                "description": "TxFIFO transmission complete\nThe flag behavior depends on TSIZE setting.\nWhen TSIZE=0 the TXC is changed by hardware exclusively and it raises each time the\nTxFIFO becomes empty and there is no activity on the bus.\nIf TSIZE <>0 there is no specific reason to monitor TXC as it just copies the EOT flag value\nincluding its software clearing. The TXC generates an interrupt when EOTIE is set.\n0: Current data transaction is still ongoing, data is available in TxFIFO or last frame\ntransmission is on going.\n1: Last TxFIFO frame transmission completed\n"
              },
              {
                "range": "11",
                "field": "SUSP",
                "description": "suspension status\nIn Master mode, SUSP is set by hardware when a CSUSP request is done, either as soon as\nthe current frame is completed after CSUSP request is done or at master automatic suspend\nreceive mode (MASRX bit is set at SPI_CR1 register) on RxFIFO full condition.\nSUSP generates an interrupt when EOTIE is set.\nThis bit has to be cleared prior SPI is disabled by write 1 to SUSPC bit at SPI_IFCR\n0: SPI not suspended (master mode active or other mode).\n1: Master mode is suspended (current frame completed)\n"
              },
              {
                "range": "10",
                "field": "TSERF",
                "description": "additional number of SPI data to be transacted was reload\nThis bit is cleared by write 1 to TSERFC bit at SPI_IFCR or by writing the TSER[15:0]\n(SPI_CR2) register\n0: no acceptation\n1: additional number of data accepted, current transaction continues\n"
              },
              {
                "range": "9",
                "field": "MODF",
                "description": "mode fault\n0: no mode fault\n1: mode fault detected\nThis bit is cleared by write 1 to MODFC bit at SPI_IFCR. When MODF is set, the SPE and\nIOLOCK bits at the SPI_CR1 register are reset and their setting is blocked.\n"
              },
              {
                "range": "8",
                "field": "TIFRE",
                "description": "TI frame format error\n0: no TI Frame Error\n1: TI Frame Error detected\nThis bit is cleared by write 1 to TIFREC bit at SPI_IFCR\n"
              },
              {
                "range": "7",
                "field": "CRCE",
                "description": "CRC error\n0: no CRC error\n1: CRC error detected\nThis bit is cleared by write 1 to CRCEC bit at SPI_IFCR\n2732/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "6",
                "field": "OVR",
                "description": "overrun\n0: no overrun\n1: overrun detected\nThis bit is cleared by write 1 to OVRC bit at SPI_IFCR\n"
              },
              {
                "range": "5",
                "field": "UDR",
                "description": "underrun\n0: no underrun\n1: underrun detected\nThis bit is cleared by write 1 to UDRC bit at SPI_IFCR\nNote: In SPI mode, the UDR flag applies to Slave mode only. In I2S/PCM mode, (when\navailable) this flag applies to Master and Slave mode.\n"
              },
              {
                "range": "4",
                "field": "TXTF",
                "description": "transmission transfer filled\n0: upload of TxFIFO is on-going or not started\n1: TxFIFO upload is finished\nTXTF is set by hardware as soon as all of the data packets in a transfer have been submitted\nfor transmission by application software or DMA, that is when TSIZE number of data have\nbeen pushed into the TxFIFO.\nThis bit is cleared by software write 1 to TXTFC bit at SPI_IFCR\nTXTF flag triggers an interrupt if TXTFIE bit is set.\nTXTF setting clears the TXIE and DXPIE masks so to off-load application software from\ncalculating when to disable TXP and DXP interrupts.\n"
              },
              {
                "range": "3",
                "field": "EOT",
                "description": "end of transfer\nEOT is set by hardware as soon as a full transfer is complete, that is when TSIZE number of\ndata have been transmitted and/or received on the SPI. EOT is cleared by software write 1 to\nEOTC bit at SPI_IFCR.\nEOT flag triggers an interrupt if EOTIE bit is set.\nIf DXP flag is used until TXTF flag is set and DXPIE is cleared, EOT can be used to\ndownload the last packets contained into RxFIFO in one-shot.\n0: transfer is on-going or not started\n1: transfer complete\nIn master, EOT event terminates the data transaction and handles SS output optionally. When\nCRC is applied, the EOT event is extended over the CRC frame transaction.\n"
              },
              {
                "range": "2",
                "field": "DXP",
                "description": "duplex packet\n0: TxFIFO is Full and/or RxFIFO is Empty\n1: Both TxFIFO has space for write and RxFIFO contains for read a single packet at least\nThe DXP flag is set whenever both TXP and RXP flags are set regardless the SPI mode.\n"
              },
              {
                "range": "1",
                "field": "TXP",
                "description": "Tx-packet space available\n0: there is not enough space to locate next data packet at TxFIFO\n1: TxFIFO has enough free location to host 1 data packet\nTXP flag is changed by hardware. It monitors overall space currently available at TxFIFO if\nSPI is enabled. It has to be checked once a complete data packet is stored at TxFIFO.\n"
              },
              {
                "range": "0",
                "field": "RXP",
                "description": "Rx-packet available\n0: RxFIFO is empty or a not complete data packet is received\n1: RxFIFO contains at least 1 data packet\nRXP flag is changed by hardware. It monitors number of overall data currently available at\nRxFIFO if SPI is enabled. It has to be checked once a data packet is completely read out\nfrom RxFIFO.\nRM0436 Rev 7 2733/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              }
            ]
          },
          {
            "registername": "SPI_IFCR",
            "offset": "0x18",
            "page": 2734,
            "chapter": "54.11.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11",
                "field": "SUSPC",
                "description": "SUSPend flag clear\nWriting a 1 into this bit clears SUSP flag in the SPI_SR register\n"
              },
              {
                "range": "10",
                "field": "TSERFC",
                "description": "TSERFC flag clear\nWriting a 1 into this bit clears TSERF flag in the SPI_SR register\nNote: TSERF is also reset by writing the TSER[15:0] (SPI_CR2) register\n"
              },
              {
                "range": "9",
                "field": "MODFC",
                "description": "mode fault flag clear\nWriting a 1 into this bit clears MODF flag in the SPI_SR register\n"
              },
              {
                "range": "8",
                "field": "TIFREC",
                "description": "TI frame format error flag clear\nWriting a 1 into this bit clears TIFRE flag in the SPI_SR register\n"
              },
              {
                "range": "7",
                "field": "CRCEC",
                "description": "CRC error flag clear\nWriting a 1 into this bit clears CRCE flag in the SPI_SR register\n"
              },
              {
                "range": "6",
                "field": "OVRC",
                "description": "overrun flag clear\nWriting a 1 into this bit clears OVR flag in the SPI_SR register\n"
              },
              {
                "range": "5",
                "field": "UDRC",
                "description": "underrun flag clear\nWriting a 1 into this bit clears UDR flag in the SPI_SR register\n"
              },
              {
                "range": "4",
                "field": "TXTFC",
                "description": "transmission Transfer Filled flag clear\nWriting a 1 into this bit clears TXTF flag in the SPI_SR register\n"
              },
              {
                "range": "3",
                "field": "EOTC",
                "description": "end of transfer flag clear\nWriting a 1 into this bit clears EOT flag in the SPI_SR register\n"
              },
              {
                "range": "2:0",
                "field": "Reserved",
                "description": "must be kept at reset value.\n2734/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              }
            ]
          },
          {
            "registername": "SPI_TXDR",
            "offset": "0x20",
            "page": 2735,
            "chapter": "54.11.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "TXDR[31:0]",
                "description": "transmit data register\nThe register serves as an interface with TxFIFO. A write to it accesses TxFIFO.\nNote: data is always right-aligned. Unused bits are ignored when writing to the register, and\nread as zero when the register is read.\nNote: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is written\nby single access.\nhalfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be\nwritten by single access.\nword-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data\ncan be written by single access.\nWrite access of this register less than the configured data size is forbidden.\n"
              }
            ]
          },
          {
            "registername": "SPI_RXDR",
            "offset": "0x30",
            "page": 2735,
            "chapter": "54.11.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "RXDR[31:0]",
                "description": "receive data register\nThe register serves as an interface with RxFIFO. When it is read, RxFIFO is accessed.\nNote: Data is always right-aligned. Unused bits are read as zero when the register is read.\nWriting to the register is ignored.\nNote: DR can be accessed byte-wise (8-bit access): in this case only one data-byte is read\nby single access.\nhalfword-wise (16 bit access) in this case 2 data-bytes or 1 halfword-data can be read\nby single access\nword-wise (32 bit access). In this case 4 data-bytes or 2 halfword-data or word-data\ncan be read by single access.\nRead access of this register less than the configured data size is forbidden.\nRM0436 Rev 7 2735/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              }
            ]
          },
          {
            "registername": "SPI_CRCPOLY",
            "offset": "0x40",
            "page": 2736,
            "chapter": "54.11.10",
            "resetvalue": "0x00000107",
            "bits": [
              {
                "range": "31:0",
                "field": "CRCPOLY[31:0]",
                "description": "CRC polynomial register\nThis register contains the polynomial for the CRC calculation.\nThe default 9-bit polynomial setting 0x107 corresponds to default 8-bit setting of DSIZE. It is\ncompatible with setting 0x07 used at some other ST products with fixed length of the\npolynomial string where the most significant bit of the string is always kept hidden.\nThe length of the polynomial is given by the most significant bit of the value stored at this\nregister. It has to be set greater than DSIZE. CRC33_17 bit has to be set additionally with\nCRCPOLY register when DSIZE is configured to maximum 32-bit or 16-bit size and CRC is\nenabled (to keep polynomial length greater than data size).\nBits 31-16 are reserved at the peripheral instances with data size limited to 16-bit. There is\nno constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are\nalways read zero while any write to them is ignored.\n"
              }
            ]
          },
          {
            "registername": "SPI_TXCRC",
            "offset": "0x44",
            "page": 2736,
            "chapter": "54.11.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "TXCRC[31:0]",
                "description": "CRC register for transmitter\nWhen CRC calculation is enabled, the TXCRC[31:0] bits contain the computed CRC value\nof the subsequently transmitted bytes. CRC calculation is initialized when the CRCEN bit of\nSPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is\ncalculated serially using the polynomial programmed in the SPI_CRCPOLY register.\nThe number of bits considered at calculation depends on SPI_CRCPOLY register and\nCRCSIZE bits settings at SPI_CFG1 register.\nNote: A read to this register when the communication is ongoing could return an incorrect\nvalue.\nNot used for the I2S mode.\nBits 31-16 are reserved at the peripheral instances with data size limited to 16-bit.\nThere is no constrain when 32-bit access is applied at these addresses. Reserved bits\n31-16 are always read zero while any write to them is ignored.\nNote: The configuration of CRCSIZE bit field is not taken into account when the content of\nthis register is read by software. No masking is applied for unused bits at this case.\n"
              }
            ]
          },
          {
            "registername": "SPI_RXCRC",
            "offset": "0x48",
            "page": 2737,
            "chapter": "54.11.12",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "RXCRC[31:0]",
                "description": "CRC register for receiver\nWhen CRC calculation is enabled, the RXCRC[31:0] bits contain the computed CRC value\nof the subsequently received bytes. CRC calculation is initialized when the CRCEN bit of\nSPI_CR1 is written to 1 or when a data block is transacted completely. The CRC is\ncalculated serially using the polynomial programmed in the SPI_CRCPOLY register.\nThe number of bits considered at calculation depends on SPI_CRCPOLY register and\nCRCSIZE bits settings at SPI_CFG1 register.\nNote: A read to this register when the communication is ongoing could return an incorrect\nvalue.\nNot used for the I2S mode.\nBits 31-16 are reserved at the peripheral instances with data size limited to 16-bit.\nThere is no constrain when 32-bit access is applied at these addresses. Reserved bits\n31-16 are always read zero while any write to them is ignored.\nNote: The configuration of CRCSIZE bit field is not taken into account when the content of\nthis register is read by software. No masking is applied for unused bits at this case.\nRM0436 Rev 7 2737/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              }
            ]
          },
          {
            "registername": "SPI_UDRDR",
            "offset": "0x4C",
            "page": 2738,
            "chapter": "54.11.13",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "UDRDR[31:0]",
                "description": "data at slave underrun condition\nThe register is taken into account at slave mode and at underrun condition only. The\nnumber of bits considered depends on DSIZE bit settings at SPI_CFG1 register. Underrun\ncondition handling depends on setting if UDRDET and UDRCFG bits at SPI_CFG1 register.\nBits 31-16 are reserved at the peripheral instances with data size limited to 16-bit. There is\nno constrain when 32-bit access is applied at these addresses. Reserved bits 31-16 are\nalways read zero while any write to them is ignored.\n"
              }
            ]
          },
          {
            "registername": "SPI_I2SCFGR",
            "offset": "0x50",
            "page": 2738,
            "chapter": "54.11.14",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25",
                "field": "MCKOE",
                "description": "master clock output enable\n0: Master clock output is disabled\n1: Master clock output is enabled\n"
              },
              {
                "range": "24",
                "field": "ODD",
                "description": "odd factor for the prescaler\n0: Real divider value is = I2SDIV *2\n1: Real divider value is = (I2SDIV * 2) + 1\nRefer to Section54.9.9: Clock generator for details\n2738/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "23:16",
                "field": "I2SDIV[7:0]",
                "description": "I2S linear prescaler\nI2SDIV can take any values except the value 1, when ODD is also equal to 1.\nRefer to Section54.9.9: Clock generator for details\n"
              },
              {
                "range": "15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14",
                "field": "DATFMT",
                "description": "data format\n0: the data inside the SPI_RXDR or SPI_TXDR are right aligned\n1: the data inside the SPI_RXDR or SPI_TXDR are left aligned.\n"
              },
              {
                "range": "13",
                "field": "WSINV",
                "description": "Word select inversion\nThis bit is used to invert the default polarity of WS signal.\n0: In I2S Philips standard, the left channel transfer starts one CK cycle after the WS falling edge,\nand the right channel one CK cycle after the WS rising edge.\nIn MSB or LSB justified mode, the left channel is transferred when WS is HIGH, and the right\nchannel when WS is LOW.\nIn PCM mode, the data transfer starts one CK cycle after the rising edge of WS.\n1: In I2S Philips standard, the left channel transfer starts one CK cycle after the WS rising edge,\nand the right channel one CK cycle after the WS falling edge.\nIn MSB or LSB justified mode, the left channel is transfered when WS is LOW, and right channel\nwhen WS is HIGH.\nIn PCM mode, the data transfer starts one CK cycle after the rising edge of WS.\n"
              },
              {
                "range": "12",
                "field": "FIXCH",
                "description": "fixed channel length in slave\n0: the channel length in slave mode is different from 16 or 32 bits (CHLEN not taken into account)\n1: the channel length in slave mode is supposed to be 16 or 32 bits (according to CHLEN)\n"
              },
              {
                "range": "11",
                "field": "CKPOL",
                "description": "serial audio clock polarity\n0: the signals generated by the SPI/I2S (i.e. SDO and WS) are changed on the falling edge of CK\nand the signals received by the SPI/I2S (i.e. SDI and WS) are read of the rising edge of CK.\n1: the signals generated by the SPI/I2S (i.e. SDO and WS) are changed on the rising edge of CK\nand the signals received by the SPI/I2S (i.e. SDI and WS) are read of the falling edge of CK.\n"
              },
              {
                "range": "10",
                "field": "CHLEN",
                "description": "channel length (number of bits per audio channel)\n0: 16-bit wide\n1: 32-bit wide\nThe selected channel length must always be higher or equal to the data length (DATLEN).\n"
              },
              {
                "range": "9:8",
                "field": "DATLEN[1:0]",
                "description": "data length to be transferred\n00: 16-bit data length\n01: 24-bit data length\n10: 32-bit data length\n11: not allowed\nThe selected data length must never be higher than the channel length (CHLEN).\nNote: Data width of 24 and 32 bits are not always supported, (DATLEN = 01 or 10), refer to\nSection54.3: SPI implementation to check the supported data size.\n"
              },
              {
                "range": "7",
                "field": "PCMSYNC",
                "description": "PCM frame synchronization\n0: short frame synchronization\n1: long frame synchronization\n"
              },
              {
                "range": "6",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2739/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              },
              {
                "range": "5:4",
                "field": "I2SSTD[1:0]",
                "description": "I2S standard selection\n00: I2S Philips standard.\n01: MSB justified standard (left justified)\n10: LSB justified standard (right justified)\n11: PCM standard\nFor more details on I2S standards, refer to Section54.9.5: Supported audio protocols\n"
              },
              {
                "range": "3:1",
                "field": "I2SCFG[2:0]",
                "description": "I2S configuration mode\n000: slave - transmit\n001: slave - receive\n010: master - transmit\n011: master - receive\n100: slave - full duplex\n101: master - full duplex\nothers, not used\n"
              },
              {
                "range": "0",
                "field": "I2SMOD",
                "description": "I2S mode selection\n0: SPI mode is selected\n1: I2S/PCM mode is selected\n"
              }
            ]
          },
          {
            "registername": "SPI_I2S_HWCFGR",
            "offset": "0x03F0",
            "page": 2740,
            "chapter": "54.11.15",
            "resetvalue": "0x000xxxxx",
            "bits": [
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:16",
                "field": "DSCFG[3:0]",
                "description": "SPI data size configuration\n0000: data size is configurable from 4-bits to 16-bits\n0001: data size is configurable from 4-bits to 32-bits\nAll the other combinations are reserved.\n"
              },
              {
                "range": "15:12",
                "field": "I2SCFG[3:0]",
                "description": "I2S configuration\n0000: I2S support is not implemented\n0001: I2S support is implemented\nAll the other combinations are reserved.\n2740/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              },
              {
                "range": "11:8",
                "field": "CRCCFG[3:0]",
                "description": "CRC configuration for SPI\n0000: CRC support is not implemented\n0001: CRC support is implemented\nAll the other combinations are reserved.\n"
              },
              {
                "range": "7:4",
                "field": "RXFCFG[3:0]",
                "description": "RxFIFO size\n0002: the FIFO size is 4 bytes\n0003: the FIFO size is 8 bytes\n0004: the FIFO size is 16 bytes\n0005: the FIFO size is 32 bytes\nAll the other combinations are reserved.\n"
              },
              {
                "range": "3:0",
                "field": "TXFCFG[3:0]",
                "description": "TxFIFO size\n0002: the FIFO size is 4 bytes\n0003: the FIFO size is 8 bytes\n0004: the FIFO size is 16 bytes\n0005: the FIFO size is 32 bytes\nAll the other combinations are reserved.\n"
              }
            ]
          },
          {
            "registername": "SPI_VERR",
            "offset": "0x03F4",
            "page": 2741,
            "chapter": "54.11.16",
            "resetvalue": "0x00000011",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "major revision of the IP.\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "minor revision of the IP.\n"
              }
            ]
          },
          {
            "registername": "SPI_IPIDR",
            "offset": "0x03F8",
            "page": 2741,
            "chapter": "54.11.17",
            "resetvalue": "0x00130022",
            "bits": [
              {
                "range": "31:0",
                "field": "ID[31:0]",
                "description": "IP identification\nMCD identification code which identifies the IP.\nRM0436 Rev 7 2741/4054\n2744\nSerial peripheral interface (SPI) RM0436\n"
              }
            ]
          },
          {
            "registername": "SPI_SIDR",
            "offset": "0x03FC",
            "page": 2742,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SID[31:0]",
                "description": "size identification\nBits[31:8]: fixed code 0xA3C5DD0\nBits[7:0]: range of address decoding boundary\n0x01: 1 Kbyte\n0x02: 2 Kbytes\n0x04: 4 Kbytes\n0x08: 8 Kbytes\nAll the other combination are reserved.\n2742/4054 RM0436 Rev 7\nRM0436 Serial peripheral interface (SPI)\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "USART registers",
        "registers": [
          {
            "registername": "USART_CR1",
            "offset": "0x00",
            "page": 2626,
            "chapter": "53.8.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "RXFFIE",
                "description": "RXFIFO full interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when RXFF=1 in the USART_ISR register\n"
              },
              {
                "range": "30",
                "field": "TXFEIE",
                "description": "TXFIFO empty interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when TXFE=1 in the USART_ISR register\n"
              },
              {
                "range": "29",
                "field": "FIFOEN",
                "description": "FIFO mode enable\nThis bit is set and cleared by software.\n0: FIFO mode is disabled.\n1: FIFO mode is enabled.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode\nand in smartcard modes only. It must not be enabled in IrDA and LIN modes.\n2626/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "28",
                "field": "M1",
                "description": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or\ncleared by software.\nM[1:0] = â€˜00â€™: 1 start bit, 8 Data bits, n Stop bit\nM[1:0] = â€˜01â€™: 1 start bit, 9 Data bits, n Stop bit\nM[1:0] = â€˜10â€™: 1 start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In 7-bits data length mode, the smartcard mode, LIN master mode and auto baud rate\n(0x7F and 0x55 frames detection) are not supported.\n"
              },
              {
                "range": "27",
                "field": "EOBIE",
                "description": "End-of-block interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the EOBF flag is set in the USART_ISR register\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "26",
                "field": "RTOIE",
                "description": "Receiver timeout interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the RTOF bit is set in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and\nmust be kept at reset value. Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "25:21",
                "field": "DEAT[4:0]",
                "description": "Driver enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and\nthe beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time,\ndepending on the oversampling rate).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "20:16",
                "field": "DEDT[4:0]",
                "description": "Driver enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted\nmessage, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample\ntime units (1/8 or 1/16 bit time, depending on the oversampling rate).\nIf the USART_TDR register is written during the DEDT time, the new data is transmitted only\nwhen the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "15",
                "field": "OVER8",
                "description": "Oversampling mode\n0: Oversampling by 16\n1: Oversampling by 8\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In LIN, IrDA and smartcard modes, this bit must be kept cleared.\n"
              },
              {
                "range": "14",
                "field": "CMIE",
                "description": "Character match interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the CMF bit is set in the USART_ISR register.\nRM0436 Rev 7 2627/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "13",
                "field": "MME",
                "description": "Mute mode enable\nThis bit enables the USART mute mode function. When set, the USART can switch between\nactive and mute mode, as defined by the WAKE bit. It is set and cleared by software.\n0: Receiver in active mode permanently\n1: Receiver can switch between mute mode and active mode.\n"
              },
              {
                "range": "12",
                "field": "M0",
                "description": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or\ncleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "11",
                "field": "WAKE",
                "description": "Receiver wake-up method\nThis bit determines the USART wake-up method from mute mode. It is set or cleared by\nsoftware.\n0: Idle line\n1: Address mark\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "10",
                "field": "PCE",
                "description": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity\ncontrol is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit\nif M=0) and the parity is checked on the received data. This bit is set and cleared by\nsoftware. Once it is set, PCE is active after the current byte (in reception and in\ntransmission).\n0: Parity control disabled\n1: Parity control enabled\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "9",
                "field": "PS",
                "description": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE\nbit set). It is set and cleared by software. The parity is selected after the current byte.\n0: Even parity\n1: Odd parity\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "8",
                "field": "PEIE",
                "description": "PE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever PE=1 in the USART_ISR register\n"
              },
              {
                "range": "7",
                "field": "TXFNFIE",
                "description": "TXFIFO not-full interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TXFNF =1 in the USART_ISR register\n"
              },
              {
                "range": "6",
                "field": "TCIE",
                "description": "Transmission complete interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TC=1 in the USART_ISR register\n"
              },
              {
                "range": "5",
                "field": "RXFNEIE",
                "description": "RXFIFO not empty interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever ORE=1 or RXFNE=1 in the USART_ISR register\n2628/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "4",
                "field": "IDLEIE",
                "description": "IDLE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever IDLE=1 in the USART_ISR register\n"
              },
              {
                "range": "3",
                "field": "TE",
                "description": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\n0: Transmitter is disabled\n1: Transmitter is enabled\nNote: During transmission, a low pulse on the TE bit (â€˜0â€™ followed by â€˜1â€™) sends a preamble\n(idle line) after the current word, except in smartcard mode. In order to generate an idle\ncharacter, the TE must not be immediately written to â€˜1â€™. To ensure the required duration,\nthe software can poll the TEACK bit in the USART_ISR register.\nIn smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission\nstarts.\n"
              },
              {
                "range": "2",
                "field": "RE",
                "description": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software.\n0: Receiver is disabled\n1: Receiver is enabled and begins searching for a start bit\n"
              },
              {
                "range": "1",
                "field": "UESM",
                "description": "USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\n0: USART not able to wake up the MCU from low-power mode.\n1: USART able to wake up the MCU from low-power mode.\nNote: It is recommended to set the UESM bit just before entering low-power mode and clear it\nwhen exit from low-power mode.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "0",
                "field": "UE",
                "description": "USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all\ncurrent operations are discarded. The USART configuration is kept, but all the USART_ISR\nstatus flags are reset. This bit is set and cleared by software.\n0: USART prescaler and outputs disabled, low-power mode\n1: USART enabled\nNote: To enter low-power mode without generating errors on the line, the TE bit must be\npreviously reset and the software must wait for the TC bit in the USART_ISR to be set\nbefore resetting the UE bit.\nThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled\nbefore resetting the UE bit.\nIn smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1,\nregardless of the UE bit value.\n"
              }
            ]
          },
          {
            "registername": "USART_CR1-alternate",
            "offset": "0x00",
            "page": 2629,
            "chapter": "53.8.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29",
                "field": "FIFOEN",
                "description": "FIFO mode enable\nThis bit is set and cleared by software.\n0: FIFO mode is disabled.\n1: FIFO mode is enabled.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: FIFO mode can be used on standard UART communication, in SPI master/slave mode\nand in smartcard modes only. It must not be enabled in IrDA and LIN modes.\n"
              },
              {
                "range": "28",
                "field": "M1",
                "description": "Word length\nThis bit must be used in conjunction with bit 12 (M0) to determine the word length. It is set or\ncleared by software.\nM[1:0] = â€˜00â€™: 1 start bit, 8 Data bits, n Stop bit\nM[1:0] = â€˜01â€™: 1 start bit, 9 Data bits, n Stop bit\nM[1:0] = â€˜10â€™: 1 start bit, 7 Data bits, n Stop bit\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In 7-bits data length mode, the smartcard mode, LIN master mode and auto baud rate\n(0x7F and 0x55 frames detection) are not supported.\n"
              },
              {
                "range": "27",
                "field": "EOBIE",
                "description": "End of Bbock interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the EOBF flag is set in the USART_ISR register\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "26",
                "field": "RTOIE",
                "description": "Receiver timeout interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the RTOF bit is set in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and\nmust be kept at reset value. Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "25:21",
                "field": "DEAT[4:0]",
                "description": "Driver enable assertion time\nThis 5-bit value defines the time between the activation of the DE (Driver Enable) signal and\nthe beginning of the start bit. It is expressed in sample time units (1/8 or 1/16 bit time,\ndepending on the oversampling rate).\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n2630/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "20:16",
                "field": "DEDT[4:0]",
                "description": "Driver enable deassertion time\nThis 5-bit value defines the time between the end of the last stop bit, in a transmitted\nmessage, and the de-activation of the DE (Driver Enable) signal. It is expressed in sample\ntime units (1/8 or 1/16 bit time, depending on the oversampling rate).\nIf the USART_TDR register is written during the DEDT time, the new data is transmitted only\nwhen the DEDT and DEAT times have both elapsed.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "15",
                "field": "OVER8",
                "description": "Oversampling mode\n0: Oversampling by 16\n1: Oversampling by 8\nThis bit can only be written when the USART is disabled (UE=0).\nNote: In LIN, IrDA and smartcard modes, this bit must be kept cleared.\n"
              },
              {
                "range": "14",
                "field": "CMIE",
                "description": "Character match interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when the CMF bit is set in the USART_ISR register.\n"
              },
              {
                "range": "13",
                "field": "MME",
                "description": "Mute mode enable\nThis bit enables the USART mute mode function. When set, the USART can switch between\nactive and mute mode, as defined by the WAKE bit. It is set and cleared by software.\n0: Receiver in active mode permanently\n1: Receiver can switch between mute mode and active mode.\n"
              },
              {
                "range": "12",
                "field": "M0",
                "description": "Word length\nThis bit is used in conjunction with bit 28 (M1) to determine the word length. It is set or\ncleared by software (refer to bit 28 (M1)description).\nThis bit can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "11",
                "field": "WAKE",
                "description": "Receiver wake-up method\nThis bit determines the USART wake-up method from mute mode. It is set or cleared by\nsoftware.\n0: Idle line\n1: Address mark\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "10",
                "field": "PCE",
                "description": "Parity control enable\nThis bit selects the hardware parity control (generation and detection). When the parity\ncontrol is enabled, the computed parity is inserted at the MSB position (9th bit if M=1; 8th bit\nif M=0) and the parity is checked on the received data. This bit is set and cleared by\nsoftware. Once it is set, PCE is active after the current byte (in reception and in\ntransmission).\n0: Parity control disabled\n1: Parity control enabled\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "9",
                "field": "PS",
                "description": "Parity selection\nThis bit selects the odd or even parity when the parity generation/detection is enabled (PCE\nbit set). It is set and cleared by software. The parity is selected after the current byte.\n0: Even parity\n1: Odd parity\nThis bitfield can only be written when the USART is disabled (UE=0).\nRM0436 Rev 7 2631/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "8",
                "field": "PEIE",
                "description": "PE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever PE=1 in the USART_ISR register\n"
              },
              {
                "range": "7",
                "field": "TXEIE",
                "description": "Transmit data register empty\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TXE =1 in the USART_ISR register\n"
              },
              {
                "range": "6",
                "field": "TCIE",
                "description": "Transmission complete interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TC=1 in the USART_ISR register\n"
              },
              {
                "range": "5",
                "field": "RXNEIE",
                "description": "Receive data register not empty\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever ORE=1 or RXNE=1 in the USART_ISR register\n"
              },
              {
                "range": "4",
                "field": "IDLEIE",
                "description": "IDLE interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever IDLE=1 in the USART_ISR register\n"
              },
              {
                "range": "3",
                "field": "TE",
                "description": "Transmitter enable\nThis bit enables the transmitter. It is set and cleared by software.\n0: Transmitter is disabled\n1: Transmitter is enabled\nNote: During transmission, a low pulse on the TE bit (â€˜0â€™ followed by â€˜1â€™) sends a preamble\n(idle line) after the current word, except in smartcard mode. In order to generate an idle\ncharacter, the TE must not be immediately written to â€˜1â€™. To ensure the required duration,\nthe software can poll the TEACK bit in the USART_ISR register.\nIn smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission\nstarts.\n"
              },
              {
                "range": "2",
                "field": "RE",
                "description": "Receiver enable\nThis bit enables the receiver. It is set and cleared by software.\n0: Receiver is disabled\n1: Receiver is enabled and begins searching for a start bit\n"
              },
              {
                "range": "1",
                "field": "UESM",
                "description": "USART enable in low-power mode\nWhen this bit is cleared, the USART cannot wake up the MCU from low-power mode.\nWhen this bit is set, the USART can wake up the MCU from low-power mode.\nThis bit is set and cleared by software.\n0: USART not able to wake up the MCU from low-power mode.\n1: USART able to wake up the MCU from low-power mode.\nNote: It is recommended to set the UESM bit just before entering low-power mode and clear it\nwhen exit from low-power mode.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n2632/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "0",
                "field": "UE",
                "description": "USART enable\nWhen this bit is cleared, the USART prescalers and outputs are stopped immediately, and all\ncurrent operations are discarded. The USART configuration is kept, but all the USART_ISR\nstatus flags are reset. This bit is set and cleared by software.\n0: USART prescaler and outputs disabled, low-power mode\n1: USART enabled\nNote: To enter low-power mode without generating errors on the line, the TE bit must be\npreviously reset and the software must wait for the TC bit in the USART_ISR to be set\nbefore resetting the UE bit.\nThe DMA requests are also reset when UE = 0 so the DMA channel must be disabled\nbefore resetting the UE bit.\nIn smartcard mode, (SCEN = 1), the CK pin is always available when CLKEN = 1,\nregardless of the UE bit value.\n"
              }
            ]
          },
          {
            "registername": "USART_CR2",
            "offset": "0x04",
            "page": 2633,
            "chapter": "53.8.3",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:24",
                "field": "ADD[7:0]",
                "description": "Address of the USART node\nThese bits give the address of the USART node in mute mode or a character code to be recognized\nin low-power or Run mode:\nâ€“ In mute mode: they are used in multiprocessor communication to wake up from mute mode\nwith 4-bit/7-bit address mark detection. The MSB of the character sent by the transmitter\nshould be equal to 1. In 4-bit address mark detection, only ADD[3:0] bits are used.\nâ€“ In low-power mode: they are used for wake up from low-power mode on character match.\nWhen WUS[1:0] is programmed to 0b00 (WUF active on address match), the wake-up\nfrom low-power mode is performed when the received character corresponds to the\ncharacter programmed through ADD[6:0] or ADD[3:0] bitfield (depending on ADDM7 bit),\nand WUF interrupt is enabled by setting WUFIE bit. The MSB of the character sent by\ntransmitter should be equal to 1.\nâ€“ In Run mode with mute mode inactive (for example, end-of-block detection in ModBus\nprotocol): the whole received character (8 bits) is compared to ADD[7:0] value and CMF\nflag is set on match. An interrupt is generated if the CMIE bit is set.\nThese bits can only be written when the reception is disabled (RE=0) or when the USART is\ndisabled (UE=0).\nRM0436 Rev 7 2633/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "23",
                "field": "RTOEN",
                "description": "Receiver timeout enable\nThis bit is set and cleared by software.\n0: Receiver timeout feature disabled.\n1: Receiver timeout feature enabled.\nWhen this feature is enabled, the RTOF flag in the USART_ISR register is set if the RX line is idle\n(no reception) for the duration programmed in the RTOR (receiver timeout register).\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "22:21",
                "field": "ABRMOD[1:0]",
                "description": "Auto baud rate mode\nThese bits are set and cleared by software.\n00: Measurement of the start bit is used to detect the baud rate.\n01: Falling edge to falling edge measurement (the received frame must start with a single bit = 1\nand Frame = Start10xxxxxx)\n10: 0x7F frame detection.\n11: 0x55 frame detection\nThis bitfield can only be written when ABREN = 0 or the USART is disabled (UE=0).\nNote: If DATAINV=1 and/or MSBFIRST=1 the patterns must be the same on the line, for example\n0xAA for MSBFIRST)\nIf the USART does not support the auto baud rate feature, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "20",
                "field": "ABREN",
                "description": "Auto baud rate enable\nThis bit is set and cleared by software.\n0: Auto baud rate detection is disabled.\n1: Auto baud rate detection is enabled.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "19",
                "field": "MSBFIRST",
                "description": "Most significant bit first\nThis bit is set and cleared by software.\n0: data is transmitted/received with data bit 0 first, following the start bit.\n1: data is transmitted/received with the MSB (bit 7/8) first, following the start bit.\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "18",
                "field": "DATAINV",
                "description": "Binary data inversion\nThis bit is set and cleared by software.\n0: Logical data from the data register are send/received in positive/direct logic. (1=H, 0=L)\n1: Logical data from the data register are send/received in negative/inverse logic. (1=L, 0=H).\nThe parity bit is also inverted.\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "17",
                "field": "TXINV",
                "description": "TX pin active level inversion\nThis bit is set and cleared by software.\n0: TX pin signal works using the standard logic levels (V =1/idle, Gnd=0/mark)\nDD\n1: TX pin signal values are inverted (V =0/mark, Gnd=1/idle).\nDD\nThis enables the use of an external inverter on the TX line.\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "16",
                "field": "RXINV",
                "description": "RX pin active level inversion\nThis bit is set and cleared by software.\n0: RX pin signal works using the standard logic levels (V =1/idle, Gnd=0/mark)\nDD\n1: RX pin signal values are inverted (V =0/mark, Gnd=1/idle).\nDD\nThis enables the use of an external inverter on the RX line.\nThis bitfield can only be written when the USART is disabled (UE=0).\n2634/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "15",
                "field": "SWAP",
                "description": "Swap TX/RX pins\nThis bit is set and cleared by software.\n0: TX/RX pins are used as defined in standard pinout\n1: The TX and RX pins functions are swapped. This enables to work in the case of a cross-wired\nconnection to another UART.\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "14",
                "field": "LINEN",
                "description": "LIN mode enable\nThis bit is set and cleared by software.\n0: LIN mode disabled\n1: LIN mode enabled\nThe LIN mode enables the capability to send LIN synchronous breaks (13 low bits) using the\nSBKRQ bit in the USART_CR1 register, and to detect LIN Sync breaks.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "13:12",
                "field": "STOP[1:0]",
                "description": "Stop bits\nThese bits are used for programming the stop bits.\n00: 1 stop bit\n01: 0.5 stop bit.\n10: 2 stop bits\n11: 1.5 stop bits\nThis bitfield can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "11",
                "field": "CLKEN",
                "description": "Clock enable\nThis bit enables the user to enable the CK pin.\n0: CK pin disabled\n1: CK pin enabled\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If neither synchronous mode nor smartcard mode is supported, this bit is reserved and must\nbe kept at reset value. Refer to Section53.4: USART implementation on page2577.\nIn smartcard mode, in order to provide correctly the CK clock to the smartcard, the steps below\nmust be respected:\nUE = 0\nSCEN = 1\nGTPR configuration\nCLKEN= 1\nUE = 1\n"
              },
              {
                "range": "10",
                "field": "CPOL",
                "description": "Clock polarity\nThis bit enables the user to select the polarity of the clock output on the CK pin in synchronous\nmode. It works in conjunction with the CPHA bit to produce the desired clock/data relationship\n0: Steady low value on CK pin outside transmission window\n1: Steady high value on CK pin outside transmission window\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If synchronous mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\nRM0436 Rev 7 2635/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "9",
                "field": "CPHA",
                "description": "Clock phase\nThis bit is used to select the phase of the clock output on the CK pin in synchronous mode. It works\nin conjunction with the CPOL bit to produce the desired clock/data relationship (see Figure589 and\nFigure590)\n0: The first clock transition is the first data capture edge\n1: The second clock transition is the first data capture edge\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If synchronous mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "8",
                "field": "LBCL",
                "description": "Last bit clock pulse\nThis bit is used to select whether the clock pulse associated with the last data bit transmitted (MSB)\nhas to be output on the CK pin in synchronous mode.\n0: The clock pulse of the last data bit is not output to the CK pin\n1: The clock pulse of the last data bit is output to the CK pin\nCaution: The last bit is the 7th or 8th or 9th data bit transmitted depending on the 7 or 8 or 9 bit\nformat selected by the M bit in the USART_CR1 register.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If synchronous mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "LBDIE",
                "description": "LIN break detection interrupt enable\nBreak interrupt mask (break detection using break delimiter).\n0: Interrupt is inhibited\n1: An interrupt is generated whenever LBDF=1 in the USART_ISR register\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to\nSection53.4: USART implementation on page2577.\n"
              },
              {
                "range": "5",
                "field": "LBDL",
                "description": "LIN break detection length\nThis bit is for selection between 11 bit or 10 bit break detection.\n0: 10-bit break detection\n1: 11-bit break detection\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to\nSection53.4: USART implementation on page2577.\n"
              },
              {
                "range": "4",
                "field": "ADDM7",
                "description": "7-bit address detection/4-bit address detection\nThis bit is for selection between 4-bit address detection or 7-bit address detection.\n0: 4-bit address detection\n1: 7-bit address detection (in 8-bit data mode)\nThis bit can only be written when the USART is disabled (UE=0)\nNote: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address\n(ADD[5:0] and ADD[7:0]) respectively.\n"
              },
              {
                "range": "3",
                "field": "DIS_NSS",
                "description": "NSS pin enable\nWhen the DIS_NSS bit is set, the NSS pin input is ignored.\n0: SPI slave selection depends on NSS input pin.\n1: SPI slave is always selected and NSS input pin is ignored.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "2:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n2636/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "0",
                "field": "SLVEN",
                "description": "Synchronous slave mode enable\nWhen the SLVEN bit is set, the synchronous slave mode is enabled.\n0: Slave mode disabled.\n1: Slave mode enabled.\nNote: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\nNote: The CPOL, CPHA and LBCL bits should not be written while the transmitter is enabled.\n"
              }
            ]
          },
          {
            "registername": "USART_CR3",
            "offset": "0x08",
            "page": 2637,
            "chapter": "53.8.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:29",
                "field": "TXFTCFG[2:0]",
                "description": "TXFIFO threshold configuration\n000:TXFIFO reaches 1/8 of its depth\n001:TXFIFO reaches 1/4 of its depth\n010:TXFIFO reaches 1/2 of its depth\n011:TXFIFO reaches 3/4 of its depth\n100:TXFIFO reaches 7/8 of its depth\n101:TXFIFO becomes empty\nRemaining combinations: Reserved\n"
              },
              {
                "range": "28",
                "field": "RXFTIE",
                "description": "RXFIFO threshold interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when Receive FIFO reaches the threshold programmed in\nRXFTCFG.\n"
              },
              {
                "range": "27:25",
                "field": "RXFTCFG[2:0]",
                "description": "Receive FIFO threshold configuration\n000:Receive FIFO reaches 1/8 of its depth\n001:Receive FIFO reaches 1/4 of its depth\n010:Receive FIFO reaches 1/2 of its depth\n011:Receive FIFO reaches 3/4 of its depth\n100:Receive FIFO reaches 7/8 of its depth\n101:Receive FIFO becomes full\nRemaining combinations: Reserved\n"
              },
              {
                "range": "24",
                "field": "TCBGTIE",
                "description": "Transmission complete before guard time, interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever TCBGT=1 in the USART_ISR register\nNote: If the USART does not support the smartcard mode, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\nRM0436 Rev 7 2637/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "23",
                "field": "TXFTIE",
                "description": "TXFIFO threshold interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated when TXFIFO reaches the threshold programmed in\nTXFTCFG.\n"
              },
              {
                "range": "22",
                "field": "WUFIE",
                "description": "Wake-up from low-power mode interrupt enable\nThis bit is set and cleared by software.\n0: Interrupt inhibited\n1: USART interrupt generated whenever WUF=1 in the USART_ISR register\nNote: WUFIE must be set before entering in low-power mode.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "21:20",
                "field": "WUS[1:0]",
                "description": "Wake-up from low-power mode interrupt flag selection\nThis bitfield specifies the event which activates the WUF (wake-up from low-power mode\nflag).\n00: WUF active on address match (as defined by ADD[7:0] and ADDM7)\n01: Reserved.\n10: WUF active on start bit detection\n11: WUF active on RXNE/RXFNE.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "19:17",
                "field": "SCARCNT[2:0]",
                "description": "Smartcard auto-retry count\nThis bitfield specifies the number of retries for transmission and reception in smartcard\nmode.\nIn transmission mode, it specifies the number of automatic retransmission retries, before\ngenerating a transmission error (FE bit set).\nIn reception mode, it specifies the number or erroneous reception trials, before generating a\nreception error (RXNE/RXFNE and PE bits set).\nThis bitfield must be programmed only when the USART is disabled (UE=0).\nWhen the USART is enabled (UE=1), this bitfield may only be written to 0x0, in order to\nstop retransmission.\n0x0: retransmission disabled - No automatic retransmission in transmit mode.\n0x1 to 0x7: number of automatic retransmission attempts (before signaling error)\nNote: If smartcard mode is not supported, this bit is reserved and must be kept at reset\nvalue. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "DEP",
                "description": "Driver enable polarity selection\n0: DE signal is active high.\n1: DE signal is active low.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n2638/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "14",
                "field": "DEM",
                "description": "Driver enable mode\nThis bit enables the user to activate the external transceiver control, through the DE signal.\n0: DE function is disabled.\n1: DE function is enabled. The DE signal is output on the RTS pin.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the Driver Enable feature is not supported, this bit is reserved and must be kept at\nreset value. Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "13",
                "field": "DDRE",
                "description": "DMA Disable on reception error\n0: DMA is not disabled in case of reception error. The corresponding error flag is set but\nRXNE is kept 0 preventing from overrun. As a consequence, the DMA request is not\nasserted, so the erroneous data is not transferred (no DMA request), but next correct\nreceived data is transferred (used for smartcard mode).\n1: DMA is disabled following a reception error. The corresponding error flag is set, as well\nas RXNE. The DMA request is masked until the error flag is cleared. This means that the\nsoftware must first disable the DMA request (DMAR = 0) or clear RXNE/RXFNE is case\nFIFO mode is enabled) before clearing the error flag.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: The reception errors are: parity error, framing error or noise error.\n"
              },
              {
                "range": "12",
                "field": "OVRDIS",
                "description": "Overrun disable\nThis bit is used to disable the receive overrun detection.\n0: Overrun Error Flag, ORE, is set when received data is not read before receiving new\ndata.\n1: Overrun functionality is disabled. If new data is received while the RXNE flag is still set\nthe ORE flag is not set and the new received data overwrites the previous content of the\nUSART_RDR register. When FIFO mode is enabled, the RXFIFO is bypassed and data is\nwritten directly in USART_RDR register. Even when FIFO management is enabled, the\nRXNE flag is to be used.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: This control bit enables checking the communication flow w/o reading the data\n"
              },
              {
                "range": "11",
                "field": "ONEBIT",
                "description": "One sample bit method enable\nThis bit enables the user to select the sample method. When the one sample bit method is\nselected the noise detection flag (NE) is disabled.\n0: Three sample bit method\n1: One sample bit method\nThis bit can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "10",
                "field": "CTSIE",
                "description": "CTS interrupt enable\n0: Interrupt is inhibited\n1: An interrupt is generated whenever CTSIF=1 in the USART_ISR register\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "9",
                "field": "CTSE",
                "description": "CTS enable\n0: CTS hardware flow control disabled\n1: CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0).\nIf the CTS input is asserted while data is being transmitted, then the transmission is\ncompleted before stopping. If data is written into the data register while CTS is asserted, the\ntransmission is postponed until CTS is deasserted.\nThis bit can only be written when the USART is disabled (UE=0)\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\nRM0436 Rev 7 2639/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "8",
                "field": "RTSE",
                "description": "RTS enable\n0: RTS hardware flow control disabled\n1: RTS output enabled, data is only requested when there is space in the receive buffer. The\ntransmission of data is expected to cease after the current character has been transmitted.\nThe RTS output is deasserted (pulled to 0) when data can be received.\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "DMAT",
                "description": "DMA enable transmitter\nThis bit is set/reset by software\n1: DMA mode is enabled for transmission\n0: DMA mode is disabled for transmission\n"
              },
              {
                "range": "6",
                "field": "DMAR",
                "description": "DMA enable receiver\nThis bit is set/reset by software\n1: DMA mode is enabled for reception\n0: DMA mode is disabled for reception\n"
              },
              {
                "range": "5",
                "field": "SCEN",
                "description": "Smartcard mode enable\nThis bit is used for enabling smartcard mode.\n0: Smartcard mode disabled\n1: Smartcard mode enabled\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "4",
                "field": "NACK",
                "description": "Smartcard NACK enable\n0: NACK transmission in case of parity error is disabled\n1: NACK transmission during parity error is enabled\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "3",
                "field": "HDSEL",
                "description": "Half-duplex selection\nSelection of single-wire half-duplex mode\n0: Half duplex mode is not selected\n1: Half duplex mode is selected\nThis bit can only be written when the USART is disabled (UE=0).\n"
              },
              {
                "range": "2",
                "field": "IRLP",
                "description": "IrDA low-power\nThis bit is used for selecting between normal and low-power IrDA modes\n0: Normal mode\n1: Low-power mode\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "1",
                "field": "IREN",
                "description": "IrDA mode enable\nThis bit is set and cleared by software.\n0: IrDA disabled\n1: IrDA enabled\nThis bit can only be written when the USART is disabled (UE=0).\nNote: If IrDA mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n2640/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "0",
                "field": "EIE",
                "description": "Error interrupt enable\nError Interrupt Enable Bit is required to enable interrupt generation in case of a framing\nerror, overrun error noise flag or SPI slave underrun error (FE=1 or ORE=1 or NE=1 or\nUDR = 1 in the USART_ISR register).\n0: Interrupt inhibited\n1: interrupt generated when FE=1 or ORE=1 or NE=1 or UDR = 1 (in SPI slave mode) in\nthe USART_ISR register.\n"
              }
            ]
          },
          {
            "registername": "USART_BRR",
            "offset": "0x0C",
            "page": 2641,
            "chapter": "53.8.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "BRR[15:0]",
                "description": "USART baud rate\nBRR[15:4]\nBRR[15:4] = USARTDIV[15:4]\nBRR[3:0]\nWhen OVER8 = 0, BRR[3:0] = USARTDIV[3:0].\nWhen OVER8 = 1:\nBRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.\nBRR[3] must be kept cleared.\n"
              }
            ]
          },
          {
            "registername": "USART_GTPR",
            "offset": "0x10",
            "page": 2641,
            "chapter": "53.8.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2641/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "15:8",
                "field": "GT[7:0]",
                "description": "Guard time value\nThis bitfield is used to program the Guard time value in terms of number of baud clock\nperiods.\nThis is used in smartcard mode. The Transmission Complete flag is set after this guard time\nvalue.\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: If smartcard mode is not supported, this bit is reserved and must be kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7:0",
                "field": "PSC[7:0]",
                "description": "Prescaler value\nIn IrDA low-power and normal IrDA mode:\nPSC[7:0] = IrDA normal and low-power baud rate\nPSC[7:0] is used to program the prescaler for dividing the USART source clock to achieve\nthe low-power frequency: the source clock is divided by the value given in the register (8\nsignificant bits):\nIn smartcard mode:\nPSC[4:0]=Prescaler value\nPSC[4:0] is used to program the prescaler for dividing the USART source clock to provide\nthe smartcard clock. The value given in the register (5 significant bits) is multiplied by 2 to\ngive the division factor of the source clock frequency:\n00000: Reserved - do not program this value\n00001: Divides the source clock by 1 (IrDA mode) / by 2 (smartcard mode)\n00010: Divides the source clock by 2 (IrDA mode) / by 4 (smartcard mode)\n00011: Divides the source clock by 3 (IrDA mode) / by 6 (smartcard mode)\n...\n11111: Divides the source clock by 31 (IrDA mode) / by 62 (smartcard mode)\n00100000: Divides the source clock by 32 (IrDA mode)\n...\n11111111: Divides the source clock by 255 (IrDA mode)\nThis bitfield can only be written when the USART is disabled (UE=0).\nNote: Bits [7:5] must be kept cleared if smartcard mode is used.\nThis bitfield is reserved and forced by hardware to â€˜0â€™ when the smartcard and IrDA\nmodes are not supported. Refer to Section53.4: USART implementation on page2577.\n"
              }
            ]
          },
          {
            "registername": "USART_RTOR",
            "offset": "0x14",
            "page": 2642,
            "chapter": "53.8.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:24",
                "field": "BLEN[7:0]",
                "description": "Block length\nThis bitfield gives the Block length in smartcard T=1 Reception. Its value equals the number\nof information characters + the length of the Epilogue Field (1-LEC/2-CRC) - 1.\nExamples:\nBLEN = 0: 0 information characters + LEC\nBLEN = 1: 0 information characters + CRC\nBLEN = 255: 254 information characters + CRC (total 256 characters))\nIn smartcard mode, the Block length counter is reset when TXE=0 (TXFE = 0 in case FIFO\nmode is enabled).\nThis bitfield can be used also in other modes. In this case, the Block length counter is reset\nwhen RE=0 (receiver disabled) and/or when the EOBCF bit is written to 1.\nNote: This value can be programmed after the start of the block reception (using the data\nfrom the LEN character in the Prologue Field). It must be programmed only once per\nreceived block.\n"
              },
              {
                "range": "23:0",
                "field": "RTO[23:0]",
                "description": "Receiver timeout value\nThis bitfield gives the Receiver timeout value in terms of number of bits during which there is\nno activity on the RX line.\nIn standard mode, the RTOF flag is set if, after the last received character, no new start bit is\ndetected for more than the RTO value.\nIn smartcard mode, this value is used to implement the CWT and BWT. See smartcard\nchapter for more details. In the standard, the CWT/BWT measurement is done starting from\nthe start bit of the last received character.\nNote: This value must only be programmed once per received character.\nNote: RTOR can be written on-the-fly. If the new value is lower than or equal to the counter, the\nRTOF flag is set.\nThis register is reserved and forced by hardware to â€œ0x00000000â€ when the Receiver\ntimeout feature is not supported. Refer to Section53.4: USART implementation on page2577.\n"
              }
            ]
          },
          {
            "registername": "USART_RQR",
            "offset": "0x18",
            "page": 2643,
            "chapter": "53.8.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 2643/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "4",
                "field": "TXFRQ",
                "description": "Transmit data flush request\nWhen FIFO mode is disabled, writing â€˜1â€™ to this bit sets the TXE flag. This enables to discard\nthe transmit data. This bit must be used only in smartcard mode, when data have not been\nsent due to errors (NACK) and the FE flag is active in the USART_ISR register. If the\nUSART does not support smartcard mode, this bit is reserved and must be kept at reset\nvalue.\nWhen FIFO is enabled, TXFRQ bit is set to flush the whole FIFO. This sets the TXFE flag\n(Transmit FIFO empty, bit 23 in the USART_ISR register). Flushing the Transmit FIFO is\nsupported in both UART and smartcard modes.\nNote: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in\norder to ensure that no data are written in the data register.\n"
              },
              {
                "range": "3",
                "field": "RXFRQ",
                "description": "Receive data flush request\nWriting 1 to this bit empties the entire receive FIFO i.e. clears the bit RXFNE.\nThis enables to discard the received data without reading them, and avoid an overrun\ncondition.\n"
              },
              {
                "range": "2",
                "field": "MMRQ",
                "description": "Mute mode request\nWriting 1 to this bit puts the USART in mute mode and resets the RWU flag.\n"
              },
              {
                "range": "1",
                "field": "SBKRQ",
                "description": "Send break request\nWriting 1 to this bit sets the SBKF flag and request to send a BREAK on the line, as soon as\nthe transmit machine is available.\nNote: When the application needs to send the break character following all previously\ninserted data, including the ones not yet transmitted, the software should wait for the\nTXE flag assertion before setting the SBKRQ bit.\n"
              },
              {
                "range": "0",
                "field": "ABRRQ",
                "description": "Auto baud rate request\nWriting 1 to this bit resets the ABRF and ABRE flags in the USART_ISR and requests an\nautomatic baud rate measurement on the next received data frame.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and must\nbe kept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              }
            ]
          },
          {
            "registername": "USART_ISR",
            "offset": "0x1C",
            "page": 2644,
            "chapter": "53.8.9",
            "resetvalue": "0x0x8000c0",
            "bits": [
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27",
                "field": "TXFT",
                "description": "TXFIFO threshold flag\nThis bit is set by hardware when the TXFIFO reaches the threshold programmed in\nTXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An\ninterrupt is generated if the TXFTIE bit =1 (bit 31) in the USART_CR3 register.\n0: TXFIFO does not reach the programmed threshold.\n1: TXFIFO reached the programmed threshold.\n"
              },
              {
                "range": "26",
                "field": "RXFT",
                "description": "RXFIFO threshold flag\nThis bit is set by hardware when the threshold programmed in RXFTCFG in USART_CR3\nregister is reached. This means that there are (RXFTCFG - 1) data in the Receive FIFO and\none data in the USART_RDR register. An interrupt is generated if the RXFTIE bit =1 (bit\n27) in the USART_CR3 register.\n0: Receive FIFO does not reach the programmed threshold.\n1: Receive FIFO reached the programmed threshold.\nNote: When the RXFTCFG threshold is configured to â€˜101â€™, RXFT flag is set if 16 data are\navailable i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the\n17th received data does not cause an overrun error. The overrun error occurs after\nreceiving the 18th data.\n"
              },
              {
                "range": "25",
                "field": "TCBGT",
                "description": "Transmission complete before guard time flag\nThis bit is set when the last data written in the USART_TDR has been transmitted correctly\nout of the shift register.\nIt is set by hardware in smartcard mode, if the transmission of a frame containing data is\ncomplete and if the smartcard did not send back any NACK. An interrupt is generated if\nTCBGTIE=1 in the USART_CR3 register.\nThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or\nby a write to the USART_TDR register.\n0: Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is\nreceived from the card)\n1: Transmission is complete successfully (before Guard time completion and there is no\nNACK from the smart card).\nNote: If the USART does not support the smartcard mode, this bit is reserved and kept at\nreset value. If the USART supports the smartcard mode and the smartcard mode is\nenabled, the TCBGT reset value is â€˜1â€™. Refer to Section53.4: USART implementation\non page2577.\n"
              },
              {
                "range": "24",
                "field": "RXFF",
                "description": "RXFIFO full\nThis bit is set by hardware when the number of received data corresponds to\nRXFIFOsize+1 (RXFIFO full + 1 data in the USART_RDR register.\nAn interrupt is generated if the RXFFIE bit =1 in the USART_CR1 register.\n0: RXFIFO not full.\n1: RXFIFO Full.\n"
              },
              {
                "range": "23",
                "field": "TXFE",
                "description": "TXFIFO empty\nThis bit is set by hardware when TXFIFO is empty. When the TXFIFO contains at least one\ndata, this flag is cleared. The TXFE flag can also be set by writing 1 to the bit TXFRQ (bit 4)\nin the USART_RQR register.\nAn interrupt is generated if the TXFEIE bit =1 (bit 30) in the USART_CR1 register.\n0: TXFIFO not empty.\n1: TXFIFO empty.\nRM0436 Rev 7 2645/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "22",
                "field": "REACK",
                "description": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by\nthe USART.\nIt can be used to verify that the USART is ready for reception before entering low-power\nmode.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "21",
                "field": "TEACK",
                "description": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by\nthe USART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by\nTE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period.\n"
              },
              {
                "range": "20",
                "field": "WUF",
                "description": "Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the\nWUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE=1 in the USART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "19",
                "field": "RWU",
                "description": "Receiver wake-up from mute mode\nThis bit indicates if the USART is in mute mode. It is cleared/set by hardware when a wake-\nup/mute sequence is recognized. The mute mode control sequence (address or IDLE) is\nselected by the WAKE bit in the USART_CR1 register.\nWhen wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to\nthe MMRQ bit in the USART_RQR register.\n0: Receiver in active mode\n1: Receiver in mute mode\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "18",
                "field": "SBKF",
                "description": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing\n1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during\nthe stop bit of break transmission.\n0: Break character transmitted\n1: Break character requested by setting SBKRQ bit in USART_RQR register\n"
              },
              {
                "range": "17",
                "field": "CMF",
                "description": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is\ncleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE=1in the USART_CR1 register.\n0: No Character match detected\n1: Character Match detected\n"
              },
              {
                "range": "16",
                "field": "BUSY",
                "description": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the\nRX line (successful start bit detected). It is reset at the end of the reception (successful or\nnot).\n0: USART is idle (no reception)\n1: Reception on going\n2646/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "15",
                "field": "ABRF",
                "description": "Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXFNE is also set,\ngenerating an interrupt if RXFNEIE = 1) or when the auto baud rate operation was\ncompleted without success (ABRE=1) (ABRE, RXFNE and FE are also set in this case)\nIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to\nthe ABRRQ in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept\nat reset value.\n"
              },
              {
                "range": "14",
                "field": "ABRE",
                "description": "Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or\ncharacter comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept\nat reset value.\n"
              },
              {
                "range": "13",
                "field": "UDR",
                "description": "SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission\nappears while the software has not yet loaded any value into USART_TDR. This flag is\nreset by setting UDRCF bit in the USART_ICR register.\n0: No underrun error\n1: underrun error\nNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "12",
                "field": "EOBF",
                "description": "End of block flag\nThis bit is set by hardware when a complete block has been received (for example T=1\nsmartcard mode). The detection is done when the number of received bytes (from the start\nof the block, including the prologue) is equal or greater than BLEN + 4.\nAn interrupt is generated if the EOBIE=1 in the USART_CR1 register.\nIt is cleared by software, writing 1 to the EOBCF in the USART_ICR register.\n0: End of Block not reached\n1: End of Block (number of characters) reached\nNote: If smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to\nSection53.4: USART implementation on page2577.\n"
              },
              {
                "range": "11",
                "field": "RTOF",
                "description": "Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has\nlapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in\nthe USART_ICR register.\nAn interrupt is generated if RTOIE=1 in the USART_CR2 register.\nIn smartcard mode, the timeout corresponds to the CWT or BWT timings.\n0: Timeout value not reached\n1: Timeout value reached without any data reception\nNote: If a time equal to the value programmed in RTOR register separates 2 characters,\nRTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8,\ndepending on the oversampling method), RTOF flag is set.\nThe counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has\nalready elapsed when RE is set, then RTOF is set.\nIf the USART does not support the Receiver timeout feature, this bit is reserved and\nkept at reset value.\nRM0436 Rev 7 2647/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "10",
                "field": "CTS",
                "description": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\n0: CTS line set\n1: CTS line reset\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at\nreset value.\n"
              },
              {
                "range": "9",
                "field": "CTSIF",
                "description": "CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by\nsoftware, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE=1 in the USART_CR3 register.\n0: No change occurred on the CTS status line\n1: A change occurred on the CTS status line\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at\nreset value.\n"
              },
              {
                "range": "8",
                "field": "LBDF",
                "description": "LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by\nwriting 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\n0: LIN Break not detected\n1: LIN break detected\nNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "TXFNF",
                "description": "TXFIFO not full\nTXFNF is set by hardware when TXFIFO is not full meaning that data can be written in the\nUSART_TDR. Every write operation to the USART_TDR places the data in the TXFIFO.\nThis flag remains set until the TXFIFO is full. When the TXFIFO is full, this flag is cleared\nindicating that data can not be written into the USART_TDR.\nAn interrupt is generated if the TXFNFIE bit =1 in the USART_CR1 register.\n0: Transmit FIFO is full\n1: Transmit FIFO is not full\nNote: The TXFNF is kept reset during the flush request until TXFIFO is empty. After sending\nthe flush request (by setting TXFRQ bit), the flag TXFNF should be checked prior to\nwriting in TXFIFO (TXFNF and TXFE are set at the same time).\nThis bit is used during single buffer transmission.\n"
              },
              {
                "range": "6",
                "field": "TC",
                "description": "Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of\nthe shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and\nwhen TXFE is set.\nAn interrupt is generated if TCIE=1 in the USART_CR1 register.\nTC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a\nwrite to the USART_TDR register.\n0: Transmission is not complete\n1: Transmission is complete\nNote: If TE bit is reset and no transmission is on going, the TC bit is immediately set.\n2648/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "5",
                "field": "RXFNE",
                "description": "RXFIFO not empty\nRXFNE bit is set by hardware when the RXFIFO is not empty, meaning that data can be\nread from the USART_RDR register. Every read operation from the USART_RDR frees a\nlocation in the RXFIFO.\nRXFNE is cleared when the RXFIFO is empty. The RXFNE flag can also be cleared by\nwriting 1 to the RXFRQ in the USART_RQR register.\nAn interrupt is generated if RXFNEIE=1 in the USART_CR1 register.\n0: Data is not received\n1: Received data is ready to be read.\n"
              },
              {
                "range": "4",
                "field": "IDLE",
                "description": "Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if\nIDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in\nthe USART_ICR register.\n0: No Idle line is detected\n1: Idle line is detected\nNote: The IDLE bit is not set again until the RXFNE bit has been set (i.e. a new idle line\noccurs).\nIf mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0),\nwhatever the mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.\n"
              },
              {
                "range": "3",
                "field": "ORE",
                "description": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXFF = 1. It is cleared by a\nsoftware, writing 1 to the ORECF, in the USART_ICR register.\nAn interrupt is generated if RXFNEIE=1 in the USART_CR1 register, or EIE = 1 in the\nUSART_CR3 register.\n0: No overrun error\n1: Overrun error is detected\nNote: When this bit is set, the USART_RDR register content is not lost but the shift register is\noverwritten. An interrupt is generated if the ORE flag is set during multi buffer\ncommunication if the EIE bit is set.\nThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in\nthe USART_CR3 register.\n"
              },
              {
                "range": "2",
                "field": "NE",
                "description": "Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by\nsoftware, writing 1 to the NECF bit in the USART_ICR register.\n0: No noise is detected\n1: Noise is detected\nNote: This bit does not generate an interrupt as it appears at the same time as the RXFNE bit\nwhich itself generates an interrupt. An interrupt is generated when the NE flag is set\nduring multi buffer communication if the EIE bit is set.\nWhen the line is noise-free, the NE flag can be disabled by programming the ONEBIT\nbit to 1 to increase the USART tolerance to deviations (Refer to Section53.5.8:\nTolerance of the USART receiver to clock deviation on page2594).\nThis error is associated with the character in the USART_RDR.\nRM0436 Rev 7 2649/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "1",
                "field": "FE",
                "description": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character\nis detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in smartcard mode, this bit is set when the maximum number of\ntransmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE=1 in the USART_CR3 register.\n0: No Framing error is detected\n1: Framing error or break character is detected\nNote: This error is associated with the character in the USART_RDR.\n"
              },
              {
                "range": "0",
                "field": "PE",
                "description": "Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by\nsoftware, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\n0: No parity error\n1: Parity error\nNote: This error is associated with the character in the USART_RDR.\n"
              }
            ]
          },
          {
            "registername": "USART_ISR-alternate",
            "offset": "0x1C",
            "page": 2650,
            "chapter": "53.8.10",
            "resetvalue": "0x000000c0",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25",
                "field": "TCBGT",
                "description": "Transmission complete before guard time flag\nThis bit is set when the last data written in the USART_TDR has been transmitted correctly\nout of the shift register.\nIt is set by hardware in smartcard mode, if the transmission of a frame containing data is\ncomplete and if the smartcard did not send back any NACK. An interrupt is generated if\nTCBGTIE=1 in the USART_CR3 register.\nThis bit is cleared by software, by writing 1 to the TCBGTCF in the USART_ICR register or\nby a write to the USART_TDR register.\n0: Transmission is not complete or transmission is complete unsuccessfully (i.e. a NACK is\nreceived from the card)\n1: Transmission is complete successfully (before Guard time completion and there is no\nNACK from the smart card).\nNote: If the USART does not support the smartcard mode, this bit is reserved and kept at\nreset value. If the USART supports the smartcard mode and the smartcard mode is\nenabled, the TCBGT reset value is â€˜1â€™. Refer to Section53.4: USART implementation\non page2577.\n"
              },
              {
                "range": "24:23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22",
                "field": "REACK",
                "description": "Receive enable acknowledge flag\nThis bit is set/reset by hardware, when the Receive Enable value is taken into account by\nthe USART.\nIt can be used to verify that the USART is ready for reception before entering low-power\nmode.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "21",
                "field": "TEACK",
                "description": "Transmit enable acknowledge flag\nThis bit is set/reset by hardware, when the Transmit Enable value is taken into account by\nthe USART.\nIt can be used when an idle frame request is generated by writing TE=0, followed by\nTE=1 in the USART_CR1 register, in order to respect the TE=0 minimum period.\n"
              },
              {
                "range": "20",
                "field": "WUF",
                "description": "Wake-up from low-power mode flag\nThis bit is set by hardware, when a wake-up event is detected. The event is defined by the\nWUS bitfield. It is cleared by software, writing a 1 to the WUCF in the USART_ICR register.\nAn interrupt is generated if WUFIE=1 in the USART_CR3 register.\nNote: When UESM is cleared, WUF flag is also cleared.\nIf the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "19",
                "field": "RWU",
                "description": "Receiver wake-up from mute mode\nThis bit indicates if the USART is in mute mode. It is cleared/set by hardware when a wake-\nup/mute sequence is recognized. The mute mode control sequence (address or IDLE) is\nselected by the WAKE bit in the USART_CR1 register.\nWhen wake-up on IDLE mode is selected, this bit can only be set by software, writing 1 to\nthe MMRQ bit in the USART_RQR register.\n0: Receiver in active mode\n1: Receiver in mute mode\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\nRM0436 Rev 7 2651/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "18",
                "field": "SBKF",
                "description": "Send break flag\nThis bit indicates that a send break character was requested. It is set by software, by writing\n1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during\nthe stop bit of break transmission.\n0: Break character transmitted\n1: Break character requested by setting SBKRQ bit in USART_RQR register\n"
              },
              {
                "range": "17",
                "field": "CMF",
                "description": "Character match flag\nThis bit is set by hardware, when a the character defined by ADD[7:0] is received. It is\ncleared by software, writing 1 to the CMCF in the USART_ICR register.\nAn interrupt is generated if CMIE=1in the USART_CR1 register.\n0: No Character match detected\n1: Character Match detected\n"
              },
              {
                "range": "16",
                "field": "BUSY",
                "description": "Busy flag\nThis bit is set and reset by hardware. It is active when a communication is ongoing on the\nRX line (successful start bit detected). It is reset at the end of the reception (successful or\nnot).\n0: USART is idle (no reception)\n1: Reception on going\n"
              },
              {
                "range": "15",
                "field": "ABRF",
                "description": "Auto baud rate flag\nThis bit is set by hardware when the automatic baud rate has been set (RXNE is also set,\ngenerating an interrupt if RXNEIE = 1) or when the auto baud rate operation was completed\nwithout success (ABRE=1) (ABRE, RXNE and FE are also set in this case)\nIt is cleared by software, in order to request a new auto baud rate detection, by writing 1 to\nthe ABRRQ in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept\nat reset value.\n"
              },
              {
                "range": "14",
                "field": "ABRE",
                "description": "Auto baud rate error\nThis bit is set by hardware if the baud rate measurement failed (baud rate out of range or\ncharacter comparison failed)\nIt is cleared by software, by writing 1 to the ABRRQ bit in the USART_RQR register.\nNote: If the USART does not support the auto baud rate feature, this bit is reserved and kept\nat reset value.\n"
              },
              {
                "range": "13",
                "field": "UDR",
                "description": "SPI slave underrun error flag\nIn slave transmission mode, this flag is set when the first clock pulse for data transmission\nappears while the software has not yet loaded any value into USART_TDR. This flag is\nreset by setting UDRCF bit in the USART_ICR register.\n0: No underrun error\n1: underrun error\nNote: If the USART does not support the SPI slave mode, this bit is reserved and kept at\nreset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "12",
                "field": "EOBF",
                "description": "End of block flag\nThis bit is set by hardware when a complete block has been received (for example T=1\nsmartcard mode). The detection is done when the number of received bytes (from the start\nof the block, including the prologue) is equal or greater than BLEN + 4.\nAn interrupt is generated if the EOBIE=1 in the USART_CR1 register.\nIt is cleared by software, writing 1 to the EOBCF in the USART_ICR register.\n0: End of Block not reached\n1: End of Block (number of characters) reached\nNote: If smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to\nSection53.4: USART implementation on page2577.\n2652/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "11",
                "field": "RTOF",
                "description": "Receiver timeout\nThis bit is set by hardware when the timeout value, programmed in the RTOR register has\nlapsed, without any communication. It is cleared by software, writing 1 to the RTOCF bit in\nthe USART_ICR register.\nAn interrupt is generated if RTOIE=1 in the USART_CR2 register.\nIn smartcard mode, the timeout corresponds to the CWT or BWT timings.\n0: Timeout value not reached\n1: Timeout value reached without any data reception\nNote: If a time equal to the value programmed in RTOR register separates 2 characters,\nRTOF is not set. If this time exceeds this value + 2 sample times (2/16 or 2/8,\ndepending on the oversampling method), RTOF flag is set.\nThe counter counts even if RE = 0 but RTOF is set only when RE = 1. If the timeout has\nalready elapsed when RE is set, then RTOF is set.\nIf the USART does not support the Receiver timeout feature, this bit is reserved and\nkept at reset value.\n"
              },
              {
                "range": "10",
                "field": "CTS",
                "description": "CTS flag\nThis bit is set/reset by hardware. It is an inverted copy of the status of the CTS input pin.\n0: CTS line set\n1: CTS line reset\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at\nreset value.\n"
              },
              {
                "range": "9",
                "field": "CTSIF",
                "description": "CTS interrupt flag\nThis bit is set by hardware when the CTS input toggles, if the CTSE bit is set. It is cleared by\nsoftware, by writing 1 to the CTSCF bit in the USART_ICR register.\nAn interrupt is generated if CTSIE=1 in the USART_CR3 register.\n0: No change occurred on the CTS status line\n1: A change occurred on the CTS status line\nNote: If the hardware flow control feature is not supported, this bit is reserved and kept at\nreset value.\n"
              },
              {
                "range": "8",
                "field": "LBDF",
                "description": "LIN break detection flag\nThis bit is set by hardware when the LIN break is detected. It is cleared by software, by\nwriting 1 to the LBDCF in the USART_ICR.\nAn interrupt is generated if LBDIE = 1 in the USART_CR2 register.\n0: LIN Break not detected\n1: LIN break detected\nNote: If the USART does not support LIN mode, this bit is reserved and kept at reset value.\nRefer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "TXE",
                "description": "Transmit data register empty\nTXE is set by hardware when the content of the USART_TDR register has been transferred\ninto the shift register. It is cleared by writing to the USART_TDR register. The TXE flag can\nalso be set by writing 1 to the TXFRQ in the USART_RQR register, in order to discard the\ndata (only in smartcard T=0 mode, in case of transmission failure).\nAn interrupt is generated if the TXEIE bit =1 in the USART_CR1 register.\n0: Data register full\n1: Data register not full\nRM0436 Rev 7 2653/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "6",
                "field": "TC",
                "description": "Transmission complete\nThis bit indicates that the last data written in the USART_TDR has been transmitted out of\nthe shift register.\nIt is set by hardware when the transmission of a frame containing data is complete and\nwhen TXE is set.\nAn interrupt is generated if TCIE=1 in the USART_CR1 register.\nTC bit is is cleared by software, by writing 1 to the TCCF in the USART_ICR register or by a\nwrite to the USART_TDR register.\n0: Transmission is not complete\n1: Transmission is complete\nNote: If TE bit is reset and no transmission is on going, the TC bit is set immediately.\n"
              },
              {
                "range": "5",
                "field": "RXNE",
                "description": "Read data register not empty\nRXNE bit is set by hardware when the content of the USART_RDR shift register has been\ntransferred to the USART_RDR register. It is cleared by reading from the USART_RDR\nregister. The RXNE flag can also be cleared by writing 1 to the RXFRQ in the USART_RQR\nregister.\nAn interrupt is generated if RXNEIE=1 in the USART_CR1 register.\n0: Data is not received\n1: Received data is ready to be read.\n"
              },
              {
                "range": "4",
                "field": "IDLE",
                "description": "Idle line detected\nThis bit is set by hardware when an Idle Line is detected. An interrupt is generated if\nIDLEIE=1 in the USART_CR1 register. It is cleared by software, writing 1 to the IDLECF in\nthe USART_ICR register.\n0: No Idle line is detected\n1: Idle line is detected\nNote: The IDLE bit is not set again until the RXNE bit has been set (i.e. a new idle line\noccurs).\nIf mute mode is enabled (MME=1), IDLE is set if the USART is not mute (RWU=0),\nwhatever the mute mode selected by the WAKE bit. If RWU=1, IDLE is not set.\n"
              },
              {
                "range": "3",
                "field": "ORE",
                "description": "Overrun error\nThis bit is set by hardware when the data currently being received in the shift register is\nready to be transferred into the USART_RDR register while RXNE=1. It is cleared by a\nsoftware, writing 1 to the ORECF, in the USART_ICR register.\nAn interrupt is generated if RXNEIE=1 or EIE = 1 in the LPUART_CR1 register, or EIE = 1\nin the USART_CR3 register.\n0: No overrun error\n1: Overrun error is detected\nNote: When this bit is set, the USART_RDR register content is not lost but the shift register is\noverwritten. An interrupt is generated if the ORE flag is set during multi buffer\ncommunication if the EIE bit is set.\nThis bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in\nthe USART_CR3 register.\n2654/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              },
              {
                "range": "2",
                "field": "NE",
                "description": "Noise detection flag\nThis bit is set by hardware when noise is detected on a received frame. It is cleared by\nsoftware, writing 1 to the NECF bit in the USART_ICR register.\n0: No noise is detected\n1: Noise is detected\nNote: This bit does not generate an interrupt as it appears at the same time as the RXNE bit\nwhich itself generates an interrupt. An interrupt is generated when the NE flag is set\nduring multi buffer communication if the EIE bit is set.\nWhen the line is noise-free, the NE flag can be disabled by programming the ONEBIT\nbit to 1 to increase the USART tolerance to deviations (Refer to Section53.5.8:\nTolerance of the USART receiver to clock deviation on page2594).\n"
              },
              {
                "range": "1",
                "field": "FE",
                "description": "Framing error\nThis bit is set by hardware when a de-synchronization, excessive noise or a break character\nis detected. It is cleared by software, writing 1 to the FECF bit in the USART_ICR register.\nWhen transmitting data in smartcard mode, this bit is set when the maximum number of\ntransmit attempts is reached without success (the card NACKs the data frame).\nAn interrupt is generated if EIE=1 in the USART_CR3 register.\n0: No Framing error is detected\n1: Framing error or break character is detected\n"
              },
              {
                "range": "0",
                "field": "PE",
                "description": "Parity error\nThis bit is set by hardware when a parity error occurs in receiver mode. It is cleared by\nsoftware, writing 1 to the PECF in the USART_ICR register.\nAn interrupt is generated if PEIE = 1 in the USART_CR1 register.\n0: No parity error\n1: Parity error\n"
              }
            ]
          },
          {
            "registername": "USART_ICR",
            "offset": "0x20",
            "page": 2655,
            "chapter": "53.8.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20",
                "field": "WUCF",
                "description": "Wake-up from low-power mode clear flag\nWriting 1 to this bit clears the WUF flag in the USART_ISR register.\nNote: If the USART does not support the wake-up from Stop feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "19:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17",
                "field": "CMCF",
                "description": "Character match clear flag\nWriting 1 to this bit clears the CMF flag in the USART_ISR register.\nRM0436 Rev 7 2655/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              },
              {
                "range": "16:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13",
                "field": "UDRCF",
                "description": "SPI slave underrun clear flag\nWriting 1 to this bit clears the UDRF flag in the USART_ISR register.\nNote: If the USART does not support SPI slave mode, this bit is reserved and must be kept at\nreset value. Refer to Section53.4: USART implementation on page2577\n"
              },
              {
                "range": "12",
                "field": "EOBCF",
                "description": "End of block clear flag\nWriting 1 to this bit clears the EOBF flag in the USART_ISR register.\nNote: If the USART does not support smartcard mode, this bit is reserved and must be kept\nat reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "11",
                "field": "RTOCF",
                "description": "Receiver timeout clear flag\nWriting 1 to this bit clears the RTOF flag in the USART_ISR register.\nNote: If the USART does not support the Receiver timeout feature, this bit is reserved and\nmust be kept at reset value. Refer to Section53.4: USART implementation on\npage2577.\n"
              },
              {
                "range": "10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9",
                "field": "CTSCF",
                "description": "CTS clear flag\nWriting 1 to this bit clears the CTSIF flag in the USART_ISR register.\nNote: If the hardware flow control feature is not supported, this bit is reserved and must be\nkept at reset value. Refer to Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "8",
                "field": "LBDCF",
                "description": "LIN break detection clear flag\nWriting 1 to this bit clears the LBDF flag in the USART_ISR register.\nNote: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer\nto Section53.4: USART implementation on page2577.\n"
              },
              {
                "range": "7",
                "field": "TCBGTCF",
                "description": "Transmission complete before Guard time clear flag\nWriting 1 to this bit clears the TCBGT flag in the USART_ISR register.\n"
              },
              {
                "range": "6",
                "field": "TCCF",
                "description": "Transmission complete clear flag\nWriting 1 to this bit clears the TC flag in the USART_ISR register.\n"
              },
              {
                "range": "5",
                "field": "TXFECF",
                "description": "TXFIFO empty clear flag\nWriting 1 to this bit clears the TXFE flag in the USART_ISR register.\n"
              },
              {
                "range": "4",
                "field": "IDLECF",
                "description": "Idle line detected clear flag\nWriting 1 to this bit clears the IDLE flag in the USART_ISR register.\n"
              },
              {
                "range": "3",
                "field": "ORECF",
                "description": "Overrun error clear flag\nWriting 1 to this bit clears the ORE flag in the USART_ISR register.\n"
              },
              {
                "range": "2",
                "field": "NECF",
                "description": "Noise detected clear flag\nWriting 1 to this bit clears the NE flag in the USART_ISR register.\n"
              },
              {
                "range": "1",
                "field": "FECF",
                "description": "Framing error clear flag\nWriting 1 to this bit clears the FE flag in the USART_ISR register.\n"
              },
              {
                "range": "0",
                "field": "PECF",
                "description": "Parity error clear flag\nWriting 1 to this bit clears the PE flag in the USART_ISR register.\n2656/4054 RM0436 Rev 7\nRM0436 Universal synchronous/asynchronous receiver transmitter (USART/UART)\n"
              }
            ]
          },
          {
            "registername": "USART_RDR",
            "offset": "0x24",
            "page": 2657,
            "chapter": "53.8.12",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8:0",
                "field": "RDR[8:0]",
                "description": "Receive data value\nContains the received data character.\nThe RDR register provides the parallel interface between the input shift register and the\ninternal bus (see Figure583).\nWhen receiving with the parity enabled, the value read in the MSB bit is the received parity\nbit.\n"
              }
            ]
          },
          {
            "registername": "USART_TDR",
            "offset": "0x28",
            "page": 2657,
            "chapter": "53.8.13",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8:0",
                "field": "TDR[8:0]",
                "description": "Transmit data value\nContains the data character to be transmitted.\nThe USART_TDR register provides the parallel interface between the internal bus and the\noutput shift register (see Figure583).\nWhen transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register),\nthe value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect\nbecause it is replaced by the parity.\nNote: This register must be written only when TXE/TXFNF=1.\nRM0436 Rev 7 2657/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              }
            ]
          },
          {
            "registername": "USART_PRESC",
            "offset": "0x2C",
            "page": 2658,
            "chapter": "53.8.14",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "PRESCALER[3:0]",
                "description": "Clock prescaler\nThe USART input clock can be divided by a prescaler factor:\n0000: input clock not divided\n0001: input clock divided by 2\n0010: input clock divided by 4\n0011: input clock divided by 6\n0100: input clock divided by 8\n0101: input clock divided by 10\n0110: input clock divided by 12\n0111: input clock divided by 16\n1000: input clock divided by 32\n1001: input clock divided by 64\n1010: input clock divided by 128\n1011: input clock divided by 256\nRemaining combinations: Reserved\nNote: When PRESCALER is programmed with a value different of the allowed ones,\nprogrammed prescaler value is 1011 i.e. input clock divided by 256.\nIf the prescaler is not supported, this bitfield is reserved and must be kept at reset\nvalue. Refer to Section53.4: USART implementation on page2577.\n"
              }
            ]
          },
          {
            "registername": "USART_HWCFGR2",
            "offset": "0x3EC",
            "page": 2658,
            "chapter": "53.8.15",
            "resetvalue": "0x00000014",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "CFG2[3:0]",
                "description": "USART hardware configuration 2\nCFG2[3:0] = SPI_SLAVE\n"
              },
              {
                "range": "3:0",
                "field": "CFG1[3:0]",
                "description": "USART hardware configuration 1\nCFG1[3:0] = LOG_FIFO_DEPTH_RX\nRXFIFO size = 2LOG_FIFO_DEPTH_RX\n"
              }
            ]
          },
          {
            "registername": "USART_HWCFGR1",
            "offset": "0x3F0",
            "page": 2659,
            "chapter": "53.8.16",
            "resetvalue": "0x4011x11x",
            "bits": [
              {
                "range": "31:28",
                "field": "CFG8[3:0]",
                "description": "USART hardware configuration 8\nCFG8[3:0] = LOG_FIFO_DEPTH_TX\nTXFIFO size = 2LOG_FIFO_DEPTH_TX\n"
              },
              {
                "range": "27:24",
                "field": "CFG7[3:0]",
                "description": "USART hardware configuration 7\nCFG7[3:0] = BAUDGEN_TYPE\n"
              },
              {
                "range": "23:20",
                "field": "CFG6[3:0]",
                "description": "USART hardware configuration 6\nCFG6[3:0] = DUAL_clock\n"
              },
              {
                "range": "19:16",
                "field": "CFG5[3:0]",
                "description": "USART hardware configuration 5\nCFG5[3:0] = ABR_RTO_SCT1\n"
              },
              {
                "range": "15:12",
                "field": "CFG4[3:0]",
                "description": "USART hardware configuration 4\nCFG4[3:0] = SMARTCARD_SEL\n"
              },
              {
                "range": "11:8",
                "field": "CFG3[3:0]",
                "description": "USART hardware configuration 3\nCFG3[3:0] = IRDA_SEL\n"
              },
              {
                "range": "7:4",
                "field": "CFG2[3:0]",
                "description": "USART hardware configuration 2\nCFG2[3:0] = LIN_MASTER\n"
              },
              {
                "range": "3:0",
                "field": "CFG1[3:0]",
                "description": "USART hardware configuration 1\nCFG1[3:0] = SCLK_EXTRACT\nRM0436 Rev 7 2659/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              }
            ]
          },
          {
            "registername": "USART_VERR",
            "offset": "0x3F4",
            "page": 2660,
            "chapter": "53.8.17",
            "resetvalue": "0x00000023",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "Major revision\nThese bits return the USART major revision.\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "Minor revision\nThese bits return the USART minor revision.\n"
              }
            ]
          },
          {
            "registername": "USART_IPIDR",
            "offset": "0x3F8",
            "page": 2660,
            "chapter": "53.8.18",
            "resetvalue": "0x00130003",
            "bits": [
              {
                "range": "31:0",
                "field": "ID[31:0]",
                "description": "Peripheral identifier\nThese bits return the USART identifier ID[31:0]:\nID[31:0] = 0x00130003\n"
              }
            ]
          },
          {
            "registername": "USART_SIDR",
            "offset": "0x3FC",
            "page": 2660,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SID[31:0]",
                "description": "Size identification\nThese bits return the size of the memory region allocated to USART registers.\nThe size of this memory region is of 1Kbytes.\nSID[31:0] = 0xA3C5DD01\nRM0436 Rev 7 2661/4054\n2663\nUniversal synchronous/asynchronous receiver transmitter (USART/UART) RM0436\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "PUBL registers",
        "registers": [
          {
            "registername": "DDRPHYC_RIDR",
            "offset": "0x000",
            "page": 378,
            "chapter": "7.7.1",
            "resetvalue": "0x00200200",
            "bits": [
              {
                "range": "31:24",
                "field": "UDRID[7:0]",
                "description": "User-defined rev ID\n"
              },
              {
                "range": "23:20",
                "field": "PHYMJR[3:0]",
                "description": "PHY maj rev\n"
              },
              {
                "range": "19:16",
                "field": "PHYMDR[3:0]",
                "description": "PHY moderate rev\n"
              },
              {
                "range": "15:12",
                "field": "PHYMNR[3:0]",
                "description": "PHY minor rev\n"
              },
              {
                "range": "11:8",
                "field": "PUBMJR[3:0]",
                "description": "PUB maj rev\n"
              },
              {
                "range": "7:4",
                "field": "PUBMDR[3:0]",
                "description": "PUB moderate rev\n"
              },
              {
                "range": "3:0",
                "field": "PUBMNR[3:0]",
                "description": "PUB minor rev\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_PIR",
            "offset": "0x004",
            "page": 378,
            "chapter": "7.7.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "INITBYP",
                "description": "Initialization bypass\nBypasses or stops, if set, all initialization routines currently running, including PHY\ninitialization, DRAM initialization, and PHY training.\nInitialization may be triggered manually using INIT and the other relevant bits of the\nDDRPHYC_PIR register. This bit is self-clearing.\n"
              },
              {
                "range": "30",
                "field": "ZCALBYP",
                "description": "zcal bypass\nBypasses or stops, if set, impedance calibration of all ZQ control blocks that automatically\ntriggers after reset.\nImpedance calibration may be triggered manually using INIT and ZCAL bits of the\nDDRPHYC_PIR register. This bit is self-clearing.\n"
              },
              {
                "range": "29",
                "field": "LOCKBYP",
                "description": "DLL lock bypass\nBypasses or stops, if set, the waiting of DLLs to lock. DLL lock wait is automatically triggers\nafter reset.\nDLL lock wait may be triggered manually using INIT and DLLLOCK bits of the\nDDRPHYC_PIR register. This bit is self-clearing.\n"
              },
              {
                "range": "28",
                "field": "CLRSR",
                "description": "clear status register\nWriting 1 to this bits does the following:\nâ€“ Auto-clears itself. This means a following read to bit CLRSR returns 0\nâ€“ Clears the DXnGSR0 bits for DTDONE, DTERR, DTIERR\nâ€“ Clears bit DFTERR in DDRPHYC_PGSR register and bit DFTERR in\nDDRPHYC_DXnGSR1 register\nThis bit is primarily for debug purposes and is typically not needed during normal functional\noperation.\nIt can be used when bit IDONE=1 in PGSR register, to manually clear the PGSR status bits,\nhowever, the PGSR status bits (except for the DFTRR and TQ bits) are automatically cleared\nby starting a new init process.\nThe bit can also be used to manually clear the DXnGSR status bits, however, starting a new\ndata training process automatically clears the DXnGSR status bits.\n"
              },
              {
                "range": "27:19",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "18",
                "field": "CTLDINIT",
                "description": "Controller DRAM initialization\nIndicates if set that DRAM initialization is performed by the controller. Otherwise if not set it\nindicates that DRAM initialization is performed using the built-in initialization sequence or\nusing software through the configuration port.\n"
              },
              {
                "range": "17",
                "field": "DLLBYP",
                "description": "DLL bypass\nA setting of 1 on this bit puts all PHY DLLs in bypass mode. A bypassed DLL is also powered\ndown (disabled).\n"
              },
              {
                "range": "16",
                "field": "ICPC",
                "description": "Initialization complete pin configuration\nSpecifies how the DFI 2.1 initialization complete output pin should be used to indicate the\nstatus of initialization.\n0: Asserted after PHY initialization (DLL locking and impedance calibration) is complete.\n1: Asserted after PHY initialization is complete and the triggered PUBL initialization (DRAM\ninitialization, data training, or initialization trigger with no selected initialization) is complete.\n"
              },
              {
                "range": "15:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 379/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "8",
                "field": "RVTRN",
                "description": "\nit is expected that RVTRN and DQSTRN are run with LPDDR2/3; RVTRN is not required for\nDDR3\nIf RVTRN=1 and bit QSTRN=0, when bit INIT=1 (triggering the init process) the read DQS\ngate training algorithm still runs (as if bit QSTRN in DDRPHYC_PIR register was actually set\nto 1).\nIf it is necessary to run only RV training stand-alone, with no read DQS gate training, you can\nprevent the read DQS gate training from running by setting bit LBGDQS=1 in\nDDRPHYC_PGCR register.\nNote: RV training cannot use multi-purpose register (MPR) and must use the user data\nprogrammed in DTDR0-1.\n"
              },
              {
                "range": "7",
                "field": "QSTRN",
                "description": "Read DQS training\nExecutes a PUBL training routine to determine the optimum position of the read data DQS\nstrobe for maximum system timing margins.\nNote: Read DQS training cannot use multi-purpose register (MPR) and must use the user data\nprogrammed in DTDR0-1.\n"
              },
              {
                "range": "6",
                "field": "DRAMINIT",
                "description": "DRAM initialization\nExecutes the DRAM initialization sequence\n"
              },
              {
                "range": "5",
                "field": "DRAMRST",
                "description": "DRAM reset (DDR3 only)\nIssues a reset to the DRAM (by driving the DRAM reset pin low) and wait 200us.\nThis can be triggered in isolation or with the full DRAM initialization (DRAMINIT). For the\nlatter case, the reset is issued and 200us is waited before starting the full initialization\nsequence.\n"
              },
              {
                "range": "4",
                "field": "ITMSRST",
                "description": "ITM reset\nSoft resets the interface timing modules for the data and data strobes, i.e., it asserts the ITM\nsoft reset (srstb) signal.\n"
              },
              {
                "range": "3",
                "field": "ZCAL",
                "description": "Impedance calibration (Driver and ODT)\nPerforms PHY impedance calibration.\n"
              },
              {
                "range": "2",
                "field": "DLLLOCK",
                "description": "DLL lock\nWaits for the PHY DLLs to lock.\n"
              },
              {
                "range": "1",
                "field": "DLLSRST",
                "description": "DLL soft reset\nSoft resets all PHY DLLs by driving the DLL soft reset pin.\nNote: - Requires that ctl_clk be toggling for the DLL soft reset signal to be output from the DLL.\nIf ctl_clk (AC DLL's cclk_0) is not guaranteed to be toggling, it is recommended to use\nthe manual DLL soft reset bit DLLSRST of DDRPHYC_ACDLLCR, and not bit\nDLLSRST of DDRPHYC_PIR.\n- Ensure that the minimum requirements for DLL bypass and DLL reset are observed\nwhile asserting this bit.\n"
              },
              {
                "range": "0",
                "field": "INIT",
                "description": "Initialization trigger\nA write of '1' to this bit triggers the DDR system initialization, including PHY initialization,\nDRAM initialization, and PHY training.\nThe exact initialization steps to be executes are specified in bits 1 to 6 of this register. A bit\nsetting of 1 means the step is executed as part of the initialization sequence, while a setting\nof â€˜0â€™ means the step is bypassed.\nThe initialization trigger bit is self-clearing.\n380/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_PGCR",
            "offset": "0x008",
            "page": 381,
            "chapter": "7.7.3",
            "resetvalue": "0x01842e04",
            "bits": [
              {
                "range": "31",
                "field": "LBMODE",
                "description": "Loop back mode\nIndicates if set that the PHY/PUB is in loopback mode\n"
              },
              {
                "range": "30",
                "field": "LBGDQS",
                "description": "Loop back DQS gating\nSelects the DQS gating mode that should be used when the PHY is in loopback mode. Valid\nvalues are:\n0: DQS gate training is triggered on the PUB\n1: DQS gate is set manually using software\n"
              },
              {
                "range": "29",
                "field": "LBDQSS",
                "description": "Loop back DQS shift\nSelects how the read DQS is shifted during loopback to ensure that the read DQS is centered\ninto the read data eye. Valid values are:\n0: PUB sets the read DQS delay to 0; DQS is already shifted 90 degrees by write path\n1: The read DQS shift is set manually through software.\n"
              },
              {
                "range": "28:25",
                "field": "RFSHDT[3:0]",
                "description": "Refresh during training\nA non-zero value specifies that a burst of refreshes equal to the number specified in this field\nshould be sent to the SDRAM after training each rank except the last rank.\n"
              },
              {
                "range": "24",
                "field": "PDDISDX",
                "description": "Power down disabled byte\nIndicates if set that the DLL and I/Os of a disabled byte should be powered down.\n"
              },
              {
                "range": "23:22",
                "field": "ZKSEL[1:0]",
                "description": "Impedance clock divider selection\nSelects the divide ratio for the clock used by the impedance control logic. The source clock\nfor\nthe divider is the configuration port clock signal (pclk), depending on which configuration port\ntype used (see â€œImpedance Calibrationâ€ on page tbc).\nValid values are:\n00: Divide by 2\n01: Divide by 8\n10: Divide by 32\n11: Divide by 64\n"
              },
              {
                "range": "21:18",
                "field": "RANKEN[3:0]",
                "description": "Rank enable\nSpecifies the ranks that are enabled for data-training.\nonly Bit 0 is used and controls rank 0.\nSetting the bit to â€˜1â€™ enables the rank, and setting it to â€˜0â€™ disables the rank.\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "17:16",
                "field": "IODDRM[1:0]",
                "description": "I/O DDR mode\nSelects the DDR mode for the I/Os.\n"
              },
              {
                "range": "15",
                "field": "IOLB",
                "description": "I/O loop back select\nSelects where inside the I/O the loop-back of signals happens. Not applicable to D3A I/Os.\nValid values are:\n0: Loopback is after output buffer; output enable must be asserted\n1: Loopback is before output buffer; output enable is donâ€™t care\n"
              },
              {
                "range": "14",
                "field": "CKINV",
                "description": "CK invert\nSpecifies if set that CK/CK# should be inverted. Otherwise CK/CK# toggles with normal\npolarity.\n"
              },
              {
                "range": "13:12",
                "field": "CKDV[1:0]",
                "description": "CK disable value\nSpecifies the static value that should be driven on CK/CK# pair(s) when the pair(s) is\ndisabled. CKDV[0] specifies the value for CK and CKDV[1] specifies the value for CK#.\n"
              },
              {
                "range": "11:9",
                "field": "CKEN[2:0]",
                "description": "CK enable\nControls whether the CK going to the SDRAM is enabled (toggling) or\ndisabled (static value defined by CKDV). One bit for each of the three CK pairs.\n"
              },
              {
                "range": "8:5",
                "field": "DTOSEL[3:0]",
                "description": "Digital test output select\nDigital Test Output Select: Selects the PHY digital test output that should be driven\nonto PHY digital test output (DDR_DTO0) pin: Valid values are:\n0000: DATX8 0 DLL digital test output\n0001: DATX8 1 DLL digital test output\n0010: DATX8 2 DLL digital test output\n0011: DATX8 3 DLL digital test output\n0100: DATX8 4 DLL digital test output\n0101: DATX8 5 DLL digital test output\n0110: DATX8 6 DLL digital test output\n0111: DATX8 7 DLL digital test output\n1000: DATX8 8 DLL digital test output\n1001: AC DLL digital test output\nOther: Reserved\n"
              },
              {
                "range": "4:3",
                "field": "DFTLMT[1:0]",
                "description": "DQS drift limit\nSpecifies the expected limit of drift on read data strobes. A drift of this value or greater is\nreported as a drift error through the host port error flag. Valid values are:\n00: No limit (no error reported)\n01: 90Â° drift\n10: 180Â° drift\n11: 270Â° or more drift\nNote: Although reported through the error flag, this is not an error requiring any action. It is\nsimply an indicator that the drift is greater than expected.\n382/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              },
              {
                "range": "2",
                "field": "DFTCMP",
                "description": "DQS drift compensation\nEnables or disables DQS drift compensation. Valid values are:\n0: Disables data strobe drift compensation\n1: Enables data strobe drift compensation\nBy default, drift compensation is enabled.\nNote: Drift compensation is not supported under any of the following situations:\n- LPDDR2/3 (bit DDRMD set to LPDDR2 in DDRPHYC_DCR register)\n- Burst length 2 (bit BL in DDRPHYC_MR0 register set to burst length of 2)\n- Read DQS gating using passive windowing (bit DQSCFG in DDRPHYC_PGCR\nregister set to passive windowing)\nDrift compensation must be set to disabled if any of the above are set.\n"
              },
              {
                "range": "1",
                "field": "DQSCFG",
                "description": "DQS gating configuration\nSelects one of the two DQS gating schemes:\n0: DQS gating is shut off using the rising edge of DQS_b (active windowing mode)\n1: DQS gating blankets the whole burst (passive windowing mode).\nNote: Passive windowing must be used for LPDDR2/3.\n"
              },
              {
                "range": "0",
                "field": "ITMDMD",
                "description": "ITM DDR mode\nSelects whether ITMS uses DQS and DQS# or it only uses DQS.\nValid values are:\n0: ITMS uses DQS and DQS#\n1: ITMS uses DQS only\nNote: The correct setting is always DQS and DQS#.\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_PGSR",
            "offset": "0x00C",
            "page": 383,
            "chapter": "7.7.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "TQ",
                "description": "Temperature output (LPDDR only) N/A\n"
              },
              {
                "range": "30:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9",
                "field": "RVEIRR",
                "description": "Read valid training intermittent error\nIf set, indicates that there was an intermittent error during read valid training, such as a pass\nwas followed by a fail then followed by another pass.\n"
              },
              {
                "range": "8",
                "field": "RVERR",
                "description": "Read valid training error\nIf set, indicates that a valid read valid placement could not be found during read valid training.\n"
              },
              {
                "range": "7",
                "field": "DFTERR",
                "description": "DQS drift error\nIf set, indicates that at least one of the read data strobes has drifted by more than or equal to\nthe drift limit set in the PHY General Configuration Register (PGCR).\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "6",
                "field": "DTIERR",
                "description": "DQS gate training intermittent error\nIf set, indicates that there was an intermittent error during DQS gate training, such as a pass\nwas followed by a fail then followed by another pass.\n"
              },
              {
                "range": "5",
                "field": "DTERR",
                "description": "DQS gate training error\nIf set, indicates that a valid DQS gating window could not be found during DQS gate training.\n"
              },
              {
                "range": "4",
                "field": "DTDONE",
                "description": "Data training done\nIndicates, if set, that the PHY has finished doing data training.\n"
              },
              {
                "range": "3",
                "field": "DIDONE",
                "description": "DRAM initialization done\nIndicates if set that DRAM initialization has completed.\n"
              },
              {
                "range": "2",
                "field": "ZCDDONE",
                "description": "zcal done\nIndicates if set that impedance calibration has completed.\n"
              },
              {
                "range": "1",
                "field": "DLDONE",
                "description": "DLL lock done\nIndicates if set that DLL locking has completed.\n"
              },
              {
                "range": "0",
                "field": "IDONE",
                "description": "Initialization done\nIndicates if set that the DDR system initialization has completed.\nThis bit is set after all the selected initialization routines in DDRPHYC_PIR register have\ncompleted.\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DLLGCR",
            "offset": "0x010",
            "page": 384,
            "chapter": "7.7.5",
            "resetvalue": "0x03737000",
            "bits": [
              {
                "range": "31:30",
                "field": "DLLRSVD2[1:0]",
                "description": "\nThese bit are connected to the DLL control bus and reserved for future use.\n"
              },
              {
                "range": "29",
                "field": "LOCKDET",
                "description": "Master lock detect enable\nNote: This field is only valid for a few processes. For all other processes this field is reserved.\n"
              },
              {
                "range": "28:27",
                "field": "FDTRMSL[1:0]",
                "description": "Slave bypass fixed delay trim\n00: Nominal delay\n01: Nominal delay â€“ 10%\n10: Nominal delay + 10%\n11: Nominal delay + 20%\n"
              },
              {
                "range": "26:24",
                "field": "SBIAS5_3[2:0]",
                "description": "Slave bias trim\nUsed to trim the bias for the slave DLL.\nRM0436 DDR physical interface control (DDRPHYC)\n"
              },
              {
                "range": "23",
                "field": "BPS200",
                "description": "Bypass mode frequency range\n0: 0 to 100MHz\n1: 0 to 200MHz\n"
              },
              {
                "range": "22:20",
                "field": "SBIAS2_0[2:0]",
                "description": "Slave bias trim\nUsed to trim the bias for the slave DLL.\n"
              },
              {
                "range": "19:12",
                "field": "MBIAS[7:0]",
                "description": "Master bias trim\nUsed to trim the bias for the master DLL.\n"
              },
              {
                "range": "11",
                "field": "TESTSW",
                "description": "Test switch\nSelects the test signals of either the master DLL, set to 0, or the slave DLL, set to 1.\n"
              },
              {
                "range": "10:9",
                "field": "ATC[1:0]",
                "description": "Analog test control\nSelects the analog signal to be output on the DLL analog test output (DDR_ATO) when\nTESTEN is high (Output is Vss when TESTEN is low).\nThe test output either comes from the master DLL or the slave DLL, depending on the setting\nof the test switch (TESTSW).\nBoth master DLL and slave DLL output similar analog test signals. Valid settings for analog\ntest control are:\n00: Replica bias output for PMOS (Vbp)\n01: Replica bias output for NMOS (Vbn)\n10: Filter output (Vc)\n11: V\nDDCORE\n"
              },
              {
                "range": "8:6",
                "field": "DTC[2:0]",
                "description": "Digital test control\nSelects the digital signal to be output on the DLL digital test output (DTO1 pin) when TESTEN\nis high (Output is '0' when TESTEN is low). The DTO0 pin output masters the DLL reference\nclock (clk_0).\nValid settings for master DLL (such as, when TESTSW = '0'):\n- 000: 0 output clock (clk_0)\n- 001: 90 output clock (clk_90)\n- 010: 180 output clock (clk_180)\n- 011: 270 output clock (clk_270)\n- 100: 360 internal clock (clk_360_int)\n- 101: Speed-up pulse (spdup)\n- 110: Slow-down pulse (slwdn)\n- 111: 0 MCTL logic clock (cclk_0)\nValid settings for slave DLL (such as when TESTSW = '1'):\n- 000: Input DQS strobe (dqs)\n- 001: Input clock reference (clk_90_in)\n- 010: Internal feedback clock (clk_0_out)\n- 011: 90 output DQS# strobe (dqsb_90)\n- 100: 90 output DQS strobe (dqs_90)\n- 101: Speed-up pulse (spdup)\n- 110: Slow-down pulse (slwdn)\n- 111: Auto-lock enable signal\nRM0436 Rev 7 385/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "5",
                "field": "TESTEN",
                "description": "Test enable\nEnables digital and analog test outputs selected by DTC and ATC respectively.\n"
              },
              {
                "range": "4:2",
                "field": "IPUMP[2:0]",
                "description": "Charge pump current trim\n000: maximum current\n111: minimum current\n"
              },
              {
                "range": "1:0",
                "field": "DRES[1:0]",
                "description": "Trim reference current versus resistor value variation\n00: Rnom\n01: Rnom - 20%\n1x: Rnom + 20%\nNote: For a few processes this field is reserved and is not used by the DLL.\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_ACDLLCR",
            "offset": "0x014",
            "page": 386,
            "chapter": "7.7.6",
            "resetvalue": "0x40000000",
            "bits": [
              {
                "range": "31",
                "field": "DLLDIS",
                "description": "DLL disable\nA disabled DLL is bypassed. By default DLL is enabled.\nNote: DLL bypass must only be changed when DDRPHYC clock (dphy_ker_ck) is inactive.\n"
              },
              {
                "range": "30",
                "field": "DLLSRST",
                "description": "DLL soft reset\nSoft resets the AC DLL by driving the DLL soft reset pin.\nNote: DLL reset must only be changed to 0 when DDRPHYC clock (dphy_ker_ck) is inactive.\n"
              },
              {
                "range": "29:19",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "18",
                "field": "ATESTEN",
                "description": "Analog test enable\nEnables the analog test signal to be output on the DLL analog test output (ATO pin). The DLL\nanalog test output is tri-stated when this bit is '0'.\n"
              },
              {
                "range": "17:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:9",
                "field": "MFWDLY[2:0]",
                "description": "Master DLL feed-forward delay trim\nUsed to trim the delay in the master DLL feed-forward path:\n000: minimum delay\n111: maximum delay\n"
              },
              {
                "range": "8:6",
                "field": "MFBDLY[2:0]",
                "description": "Master DLL feed-back delay trim\nUsed to trim the delay in the master DLL feed-back path:\n000: minimum delay\n111: maximum delay\n"
              },
              {
                "range": "5:0",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR physical interface control (DDRPHYC)\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_PTR0",
            "offset": "0x018",
            "page": 387,
            "chapter": "7.7.7",
            "resetvalue": "0x0022af9b",
            "bits": [
              {
                "range": "31:22",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "21:18",
                "field": "TITMSRST[3:0]",
                "description": "ITM soft reset\nNumber of configuration clock cycles that the ITM soft reset pin must remain asserted when\nthe soft reset is applied to the ITMs.\nThis must correspond to a value that is equal to or more than 8 controller clock cycles.\nDefault value corresponds to 8 controller clock cycles.\n"
              },
              {
                "range": "17:6",
                "field": "TDLLLOCK[11:0]",
                "description": "DLL lock time\nNumber of configuration clock cycles for the DLL to stabilize and lock, i.e. number of clock\ncycles from when the DLL reset pin is de-asserted to when the DLL has locked and is ready\nfor use.\nDefault value corresponds to 5.12us at 533MHz.\n"
              },
              {
                "range": "5:0",
                "field": "TDLLSRST[5:0]",
                "description": "DLL soft reset\nNumber of configuration clock cycles that the DLL soft reset pin must remain asserted when\nthe soft reset is triggered through the PHY initialization register (DDRPHYC_PIR).\nThis must correspond to a value that is equal to or more than 50ns or 8 controller clock\ncycles, whichever is bigger.\nDefault value corresponds to 50ns at 533MHz.\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_PTR1",
            "offset": "0x01C",
            "page": 387,
            "chapter": "7.7.8",
            "resetvalue": "0x0604111d",
            "bits": [
              {
                "range": "31:27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26:19",
                "field": "TDINIT1[7:0]",
                "description": "tDINIT1\nDRAM initialization time corresponding to the following:\nDDR3 = CKE high time to first command (tRFC +10 ns or 5 tCK, whichever value is larger)\nLPDDR2 = CKE low time with power and clock stable (100 ns)\nLPDDR3 = CKE low time with power and clock stable (100 ns)\nDefault value corresponds to DDR3 360ns at 533MHz.\n"
              },
              {
                "range": "18:0",
                "field": "TDINIT0[18:0]",
                "description": "tDINIT0\nDRAM initialization time corresponding to the following:\nDDR3 = CKE low time with power and clock stable (500 us)\nLPDDR2 = CKE high time to first command (200 us)\nLPDDR3 = CKE high time to first command (200us)\nDefault value corresponds to DDR3 500 us at 533MHz.\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_PTR2",
            "offset": "0x020",
            "page": 388,
            "chapter": "7.7.9",
            "resetvalue": "0x042da072",
            "bits": [
              {
                "range": "31:27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26:17",
                "field": "TDINIT3[9:0]",
                "description": "tDINIT3\nDRAM initialization time corresponding to the following:\nLPDDR2 = Time from ZQ initialization command to first command (1 us)\nLPDDR3 = Time from ZQ initialization command to first command (1us)\nDefault value corresponds to the LPDDR2/3 1 us at 533MHz.\n"
              },
              {
                "range": "16:0",
                "field": "TDINIT2[16:0]",
                "description": "tDINIT2\nDRAM initialization time corresponding to the following:\nDDR3 = Reset low time (200 us on power-up or 100 ns after power-up)\nLPDDR2 = Time from reset command to end of auto initialization (1 us + 10 us = 11us)\nLPDDR3 = Time from reset command to end of auto initialization (11us)\nDefault value corresponds to DDR3 200 us at 533MHz\n388/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_ACIOCR",
            "offset": "0x024",
            "page": 389,
            "chapter": "7.7.10",
            "resetvalue": "0x30400812",
            "bits": [
              {
                "range": "31:30",
                "field": "ACSR[1:0]",
                "description": "AC slew rate\nSelects slew rate of the I/O for all address and command pins.\n"
              },
              {
                "range": "29",
                "field": "RSTIOM",
                "description": "Reset I/O mode\nSelects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for SDRAM\nReset.\n"
              },
              {
                "range": "28",
                "field": "RSTPDR",
                "description": "RST pin power down receiver\nPowers down, when set, the input receiver on the I/O for SDRAM RST# pin.\n"
              },
              {
                "range": "27",
                "field": "RSTPDD",
                "description": "RST pin power down driver\nPowers down, when set, the output driver on the I/O for SDRAM RST# pin.\n"
              },
              {
                "range": "26",
                "field": "RSTODT",
                "description": "RST pin ODT\nEnables, when set, the on-die termination on the I/O for SDRAM RST# pin.\n"
              },
              {
                "range": "25:23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22",
                "field": "RANKPDR",
                "description": "Rank power down receiver\nPowers down, when set, the input receiver on the I/O CKE, ODT, and CS# pins.\nOnly RANKPDR[0] is used for single rank\n"
              },
              {
                "range": "21:19",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "18",
                "field": "CSPDD",
                "description": "CS power down driver\nPowers down, when set, the output driver on the I/O for CS# pins.\nOnly PDD[0] is used for single rank.\nCKE and ODT driver power down is controlled by DSGCR register.\n"
              },
              {
                "range": "17:15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14",
                "field": "RANKODT",
                "description": "Rank ODT\nEnables, when set, the on-die termination on the I/O for CKE, ODT, and CS# pins.\n"
              },
              {
                "range": "13:11",
                "field": "CKPDR[2:0]",
                "description": "CK pin power down receiver\nPowers down, when set, the input receiver on the I/O for CK[0], CK[1], and CK[2] pins,\nrespectively\n"
              },
              {
                "range": "10:8",
                "field": "CKPDD[2:0]",
                "description": "CK pin power down driver\nPowers down, when set, the output driver on the I/O for CK[0], CK[1], and CK[2] pins,\nrespectively.\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "7:5",
                "field": "CKODT[2:0]",
                "description": "CK pin ODT\nEnables, when set, the on-die termination on the I/O for CK[0], CK[1], and CK[2] pins,\nrespectively.\n"
              },
              {
                "range": "4",
                "field": "ACPDR",
                "description": "AC pins power down receivers\nPowers down, when set, the input receiver on the I/O for RAS#, CAS#, WE#, BA[2:0], and\nA[15:0] pins.\n"
              },
              {
                "range": "3",
                "field": "ACPDD",
                "description": "AC pins power down drivers\nPowers down, when set, the output driver on the I/O for RAS#, CAS#, WE#, BA[2:0], and\nA[15:0] pins\n"
              },
              {
                "range": "2",
                "field": "ACODT",
                "description": "AC pins ODT\nEnables, when set, the on-die termination on the I/O for RAS#, CAS#, WE#, BA[2:0], and\nA[15:0] pins\n"
              },
              {
                "range": "1",
                "field": "ACOE",
                "description": "AC pins output enable\nEnables, when set, the output driver on the I/O for all address and command pins\n"
              },
              {
                "range": "0",
                "field": "ACIOM",
                "description": "AC pins I/O mode\nSelects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for all address\nand command pins,\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DXCCR",
            "offset": "0x028",
            "page": 390,
            "chapter": "7.7.11",
            "resetvalue": "0x00000800",
            "bits": [
              {
                "range": "31:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "AWDT",
                "description": "Active window data train\nIndicates if set that data training (DQS gate training and read valid training) should be\nperformed with active DQS gate window.\nThis is just for debug purposes.\nThe default is to perform training with passive windowing.\n"
              },
              {
                "range": "15",
                "field": "RVSEL",
                "description": "ITMD read valid select\nSelects the scheme used for ITMD read valid. Valid values are:\n0: ITMD read valid signal is generated by delayed DFI read enable signal.\n1: ITMD read valid is generated by the ITMD itself using asynchronous crossing.\n"
              },
              {
                "range": "14",
                "field": "DQSNRST",
                "description": "DQS reset\nIndicates, if set, that the ITMS of DQS# should always be put in reset such that its output\nenable is always '1' and its data output is always '0'.\nThis is done by driving the oe_set_b and do_rst_b pins of this ITMS to '0' in order to force the\nunused DQS# PAD to a known state of '0' in applications that don't use DQS#.\nRM0436 DDR physical interface control (DDRPHYC)\n"
              },
              {
                "range": "13:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "DQSNRES[3:0]",
                "description": "DQS# resistor\nSelects the on-die pull-up/pull-down resistor for DQS# pins. Same encoding as DQSRES.\nNote: DQS# resistor must be connected for LPDDR2.\n"
              },
              {
                "range": "7:4",
                "field": "DQSRES[3:0]",
                "description": "DQS resistor\nSelects the on-die pull-down/pull-up resistor for DQS pins.\nDQSRES[3] selects pull-down (when set to 0) or pull-up (when set to 1).\nDQSRES[2:0] selects the resistor value as follows:\n000: Open: On-die resistor disconnected\n001: 688 â„¦\n010: 611 â„¦\n011: 550 â„¦\n100: 500 â„¦\n101: 458 â„¦\n110: 393 â„¦\n111: 344 â„¦\nNote: DQS resistor must be connected for LPDDR2\n"
              },
              {
                "range": "3",
                "field": "DXPDR",
                "description": "Data power down receiver\nPowers down, when set, the input receiver on I/O for DQ, DM, and DQS/DQS# pins of all\nDATX8 macros. It also powers down the PDQSR cell of all DAXT8 macros. This bit is ORed\nwith the PDR and DQSRPD configuration bits of the individual DATX8\n"
              },
              {
                "range": "2",
                "field": "DXPDD",
                "description": "Data power down driver\nPowers down, when set, the output driver on I/O for DQ, DM, and DQS/DQS# pins of all\nDATX8 macros. This bit is ORed with the PDD configuration bit of the individual DATX8.\n"
              },
              {
                "range": "1",
                "field": "DXIOM",
                "description": "Data I/O mode\nSelects SSTL mode (when set to 0) or CMOS mode (when set to 1) of the I/O for DQ, DM,\nand DQS/DQS# pins of all DATX8 macros. This bit is ORed with the IOM configuration bit of\nthe individual DATX8.\n"
              },
              {
                "range": "0",
                "field": "DXODT",
                "description": "Data on die termination\nEnables, when set, the on-die termination on the I/O for DQ, DM, and DQS/DQS# pins of all\nDATX8 macros. This bit is ORed with the ODT configuration bit of the individual DATX8.\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DSGCR",
            "offset": "0x02C",
            "page": 391,
            "chapter": "7.7.12",
            "resetvalue": "0xfa00001f",
            "bits": [
              {
                "range": "31",
                "field": "CKEOE",
                "description": "CKE output enable\nSets the output driver on the I/O for SDRAM CKE pins.\n"
              },
              {
                "range": "30",
                "field": "RSTOE",
                "description": "RST output enable\nEnables, when set, the output driver on the I/O for SDRAM RST# pin\n"
              },
              {
                "range": "29",
                "field": "ODTOE",
                "description": "ODT output enable\nEnables, when set, the output driver on the I/O for SDRAM ODT pins.\n"
              },
              {
                "range": "28",
                "field": "CKOE",
                "description": "CK output enable\nEnables, when set, the output driver on the I/O for SDRAM CK/CK# pins.\n"
              },
              {
                "range": "27",
                "field": "TPDOE",
                "description": "TPD output enable (N/A LPDDR only)\n"
              },
              {
                "range": "26",
                "field": "TPDPD",
                "description": "TPD power down driver (N/A LPDDR only)\n"
              },
              {
                "range": "25",
                "field": "NL2OE",
                "description": "Non LPDDR2 output enable\nEnables, when set, the output driver on the I/O for non-LPDDR2/LPDDR3 (ODT, RAS#,\nCAS#, WE#, and BA) pins.\nThis may be used when a chip that is designed for both LPDDR2/LPDDR3 and other DDR\nmodes is being used in LPDDR2/LPDDR3 mode.\nFor these pins, the I/O output enable signal (OE) is an AND of this bit and the respective\noutput enable bit in ACIOCR or DSGCR registers.\n"
              },
              {
                "range": "24",
                "field": "NL2PD",
                "description": "Non LPDDR2 power down\nPowers down, when set, the output driver and the input receiver on the I/O for non-\nLPDDR2/LPDDR3 (ODT, RAS#, CAS#, WE#, and BA) pins.\nThis may be used when a chip that is designed for both LPDDR2/LPDDR3 and other DDR\nmodes is being used in LPDDR2/LPDDR3 mode.\nFor these pins, the I/O power down signal (PDD or PDR) is an OR of this bit and the\nrespective power-down bit in ACIOCR register.\n"
              },
              {
                "range": "23:21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20",
                "field": "ODTPDD",
                "description": "ODT power down driver\nPowers down, when set, the output driver on the I/O for ODT pin.\n"
              },
              {
                "range": "19:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "CKEPDD",
                "description": "CKE power down driver\nPowers down, when set, the output driver on the I/O for CKE pin.\n"
              },
              {
                "range": "15:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "FXDLAT",
                "description": "Fixed latency\nSpecified whether all reads should be returned to the controller with a fixed read latency.\nEnabling fixed read latency increases the read latency. Valid values are:\n0: Disable fixed read latency\n1: Enable fixed read latency\n"
              },
              {
                "range": "11",
                "field": "NOBUB",
                "description": "No bubble\nSpecified whether reads should be returned to the controller with no bubbles. Enabling no-\nbubble reads increases the read latency. Valid values are:\n0: Bubbles are allowed during reads\n1: Bubbles are not allowed during reads\n392/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              },
              {
                "range": "10:8",
                "field": "DQSGE[2:0]",
                "description": "DQS gate early\nSpecifies the number of clock cycles for which the DQS gating must be enable dearlier than\nits normal position. Only applicable when using PDQSR I/O cell, passive DQS gating and no\ndrift compensation.\nThis field is recommended to be set to zero for all DDR types other than LPDDR2/LPDDR3.\nFor LPDDR2/LPDDR3 it should be set to (tDQSCKmax - tDQSCKmin) divide by clock period\nand rounded up. tDQSCKmax and tDQSCKmin can be found in the LPDDR/LPDDR2 vendor\ndatasheet.\n"
              },
              {
                "range": "7:5",
                "field": "DQSGX[2:0]",
                "description": "DQS gate extension\nSpecifies the number of clock cycles for which the DQS gating must be extended beyond the\nnormal burst length width. Only applicable when using PDQSR I/O cell, passive DQS gating\nand no drift compensation.\nThis field is recommended to be set to zero for all DDR types other than LPDDR2/LPDDR3.\nFor LPDDR2/LPDDR3 it should be set to (tDQSCKmax- tDQSCKmin) divide by clock period\nand rounded up. tDQSCKmax and tDQSCKmin can be found in the LPDDR2 vendor\ndatasheet.\n"
              },
              {
                "range": "4",
                "field": "LPDLLPD",
                "description": "Low power DLL power down\nSpecifies if set that the PHY should respond to the DFI low power opportunity request and\npower down the DLL of the PHY if the wakeup time request satisfies the DLL lock time.\nFor more information on requirements when enabling and disabling the DLL, refer to â€œbypass\nmode register controlâ€\n"
              },
              {
                "range": "3",
                "field": "LPIOPD",
                "description": "Low power I/O power down\nSpecifies if set that the PHY should respond to the DFI low power opportunity request and\npower down the I/Os of the PHY.\n"
              },
              {
                "range": "2",
                "field": "ZUEN",
                "description": "zcal on DFI update request\nSpecifies if set that the PHY should perform impedance calibration (update) whenever there\nis a controller initiated DFI update request. Otherwise the PHY ignores an update request\nfrom the controller.\n"
              },
              {
                "range": "1",
                "field": "BDISEN",
                "description": "Byte disable enable\nSpecifies if set that the PHY should respond to DFI byte disable request. Otherwise the byte\ndisable from the DFI is ignored in which case bytes can only be disabled using the DXnGCR\nregister\n"
              },
              {
                "range": "0",
                "field": "PUREN",
                "description": "PHY update request enable\nSpecifies if set, that the PHY should issue PHY initiated DFI update request when there is\nDQS drift of more than Â¾ of a clock cycle within one continuous (back-to-back) read burst.\nBy default the PHY issues PHY initiated update requests and the controller should respond\notherwise the PHY may return erroneous values.\nThe option to disable it is provided only for silicon evaluation and testing.\nRM0436 Rev 7 393/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DCR",
            "offset": "0x030",
            "page": 394,
            "chapter": "7.7.13",
            "resetvalue": "0x0000000b",
            "bits": [
              {
                "range": "31",
                "field": "TPD",
                "description": "Test power down (N/A LPDDR only)\nIf set it places the DRAM in deep power down mode.\n"
              },
              {
                "range": "30",
                "field": "RDIMM",
                "description": "Registered DIMM\nIndicates if set that a registered DIMM is used. In this case, the PUBL increases the SDRAM\nwrite and read latencies (WL/RL) by 1.\nThis only applies to PUBL internal SDRAM transactions. Transactions generated by the\ncontroller must make its own adjustments to WL/RL when using a registered DIMM\n"
              },
              {
                "range": "29",
                "field": "UDIMM",
                "description": "Unbuffered DIMM\nIndicates if set that there is address mirroring on the second rank of an un-buffered DIMM\n(the rank connected to CS#[1]).\nIn this case, the PUBL re-scrambles the bank and address when sending mode register\ncommands to the second rank.\nThis only applies to PUBL internal SDRAM transactions. Transactions generated by the\ncontroller must make its own adjustments when using an un-buffered DIMM. DCR[NOSRA]\nmust be set if address mirroring is enabled.\n"
              },
              {
                "range": "28",
                "field": "DDR2T",
                "description": "2T timing\nIndicates if set that 2T timing should be used by PUB internally generated SDRAM\ntransactions.\n"
              },
              {
                "range": "27",
                "field": "NOSRA",
                "description": "No simultaneous rank access\nSpecifies if set that simultaneous rank access on the same clock cycle is not allowed. This\nmeans that multiple chip select signals should not be asserted at the same time. This may be\nrequired on some DIMM systems.\n"
              },
              {
                "range": "26:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9:8",
                "field": "DDRTYPE[1:0]",
                "description": "DDR type (LPDDR2 S4)\nSelects the DDR type for the specified LPDDR mode.\nValid values for LPDDR2 are:\n00: LPDDR2-S4\n01: LPDDR2-S2\nOthers: Reserved\nRM0436 DDR physical interface control (DDRPHYC)\n"
              },
              {
                "range": "7",
                "field": "MPRDQ",
                "description": "MPR DQ\nSpecifies the value that is driven on non-primary DQ pins during MPR reads.\nValid values are:\n0: Primary DQ drives out the data from MPR (0-1-0-1); non-primary DQs drive â€˜0â€™\n1: Primary DQ and non-primary DQs all drive the same data from MPR (0-1-0-1)\n"
              },
              {
                "range": "6:4",
                "field": "PDQ[2:0]",
                "description": "Primary DQ(DDR3 Only)\nSpecifies the DQ pin in a byte that is designated as a primary pin for Multi-Purpose Register\n(MPR) reads. Valid values are 0 to 7 for DQ[0] to DQ[7], respectively\n"
              },
              {
                "range": "3",
                "field": "DDR8BNK",
                "description": "DDR 8 banks\nIndicates if set that the SDRAM used has 8 banks. tRPA = tRP+1 and tFAW are used for 8-\nbank DRAMs, other tRPA = tRP and no tFAW is used.\nNote: A setting of 1 for DRAMs that have fewer than 8 banks still results in correct functionality\nbut less tighter DRAM command spacing for the parameters described here.\n"
              },
              {
                "range": "2:0",
                "field": "DDRMD[2:0]",
                "description": "SDRAM DDR mode\n011: DDR3\n100: LPDDR2 (Mobile DDR2)\n101: LPDDR3 (Mobile DDR3)\nOthers: Reserved\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DTPR0",
            "offset": "0x034",
            "page": 395,
            "chapter": "7.7.14",
            "resetvalue": "0x3092666e",
            "bits": [
              {
                "range": "31",
                "field": "TCCD",
                "description": "tCCDRead to read and write to write command delay\n0: BL/2 for DDR2 and 4 for DDR3\n1: BL/2 + 1 for DDR2 and 5 for DDR3\n"
              },
              {
                "range": "30:25",
                "field": "TRC[5:0]",
                "description": "tRC\nActivate to activate command delay (same bank). Valid values are 2 to 42.\n"
              },
              {
                "range": "24:21",
                "field": "TRRD[3:0]",
                "description": "tRRD\nActivate to activate command delay (different banks). Valid values are 1 to 8.\n"
              },
              {
                "range": "20:16",
                "field": "TRAS[4:0]",
                "description": "tRAS\nActivate to precharge command delay. Valid values are 2 to 31.\n"
              },
              {
                "range": "15:12",
                "field": "TRCD[3:0]",
                "description": "tRCD\nActivate to read or write delay. Minimum time from when an activate command is issued to\nwhen a read or write to the activated row can be issued. Valid values are 2 to 11.\nRM0436 Rev 7 395/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "11:8",
                "field": "TRP[3:0]",
                "description": "tRP\nPrecharge command period: The minimum time between a precharge command and any\nother command.\nNote: Note that the controller automatically derives tRPA for 8-bank DDR2 devices by adding\n1 to tRP. Valid values are 2 to 11.\n"
              },
              {
                "range": "7:5",
                "field": "TWTR[2:0]",
                "description": "tWTR\nInternal write to read command delay. Valid values are 1 to 6.\n"
              },
              {
                "range": "4:2",
                "field": "TRTP[2:0]",
                "description": "tRTP\nInternal read to precharge command delay. Valid values are 2 to 6. Note that even though\nRTP does not apply to JEDEC DDR devices, this parameter must still be set to a minimum\nvalue of 2 for DDR because the Controller always uses the DDR2 equation, AL + BL/2 +\nmax(RTP,2) â€“ 2, to compute the read to precharge timing (which is BL/2 for JEDEC DDR).\n"
              },
              {
                "range": "1:0",
                "field": "TMRD[1:0]",
                "description": "tMRD\nLoad mode cycle time: The minimum time between a load mode register command and any\nother command.\nFor DDR3 this is the minimum time between two load mode register commands.\nFor DDR3, the value used for tMRD is 4 plus the value programmed in these bits, i.e. tMRD\nvalue for DDR3 ranges from 4 to 7.\nFor LPDDR3, the value used for tMRD is 8 plus the value programmed in these bits.\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DTPR1",
            "offset": "0x038",
            "page": 396,
            "chapter": "7.7.15",
            "resetvalue": "0x09830090",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:27",
                "field": "TDQSCKMAX[2:0]",
                "description": "tDQSCKmax\nMaximum DQS output access time from CK/CK# (LPDDR2 only).\nThis value is used for implementing read-to-write spacing. Valid values are 1 to 7.\n"
              },
              {
                "range": "26:24",
                "field": "TDQSCKMIN[2:0]",
                "description": "tDQSCKmin\nDQS output access time from CK/CK# (LPDDR2/3 only).\nThis value is used for computing the read latency. Valid values are 0 to 7.\nThis value is derived from the corresponding parameter in the SDRAM datasheet divided by\nthe clock cycle time without rounding up.\nThe fractional remainder is automatically adjusted for by data training in quarter clock cycle\nunits.\nIf data training is not performed then this fractional remainder must be converted to quarter\nclock cycle units and the gating registers (DXnDQSTR) adjusted accordingly.\nRM0436 DDR physical interface control (DDRPHYC)\n"
              },
              {
                "range": "23:16",
                "field": "TRFC[7:0]",
                "description": "tRFC\nRefresh-to-Refresh: Indicates the minimum time, in clock cycles, between two refresh\ncommands or between a refresh and an active command. This is derived from the minimum\nrefresh interval from the datasheet, tRFC(min), divided by the clock cycle time.\nThe default number of clock cycles is for the largest JEDEC tRFC(min parameter value\nsupported.\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11",
                "field": "TRTODT",
                "description": "tRTODT\nRead to ODT delay (DDR3 only). Specifies whether ODT can be enabled immediately after\nthe read post-amble or one clock delay has to be added.\nValid values are:\n0: ODT may be turned on immediately after read post-amble\n1: ODT may not be turned on until one clock after the read post-amble\nIf tRTODT is set to 1, then the read-to-write latency is increased by 1 if ODT is enabled.\n"
              },
              {
                "range": "10:9",
                "field": "TMOD[1:0]",
                "description": "tMOD\nLoad mode update delay (DDR3 only). The minimum time between a load mode register\ncommand and a non-load mode register command.\nValid values are:\n00: 12\n01: 13\n10: 14\n11: 15\n"
              },
              {
                "range": "8:3",
                "field": "TFAW[5:0]",
                "description": "tFAW\n4-bank activate period. No more than 4-bank activate commands may be issued in a given\ntFAW period. Only applies to 8-bank devices.\nValid values are 2 to 31.\n"
              },
              {
                "range": "2",
                "field": "TRTW",
                "description": "tRTW\nRead to Write command delay.\nValid values are:\n0: standard bus turn around delay\n1: add 1 clock to standard bus turn around delay\nThis parameter allows the user to increase the delay between issuing Write commands to the\nSDRAM when preceded by Read commands. This provides an option to increase bus turn-\naround margin for high frequency systems.\n"
              },
              {
                "range": "1:0",
                "field": "TAOND[1:0]",
                "description": "tAOND/tAOFD\nODT turn-on/turn-off delays (DDR2 only). The delays are in clock cycles.\nValid values are:\n00: 2/2.5\n01: 3/3.5\n10: 4/4.5\n11: 5/5.5\nMost DDR2 devices utilize a fixed value of 2/2.5. For non-standard SDRAMs, the\nuser must ensure that the operational Write Latency is always greater than or equal\nto the ODT turn-on delay. For example, a DDR2 SDRAM with CAS latency set to 3\nand CAS additive latency set to 0 has a Write Latency of 2. Thus 2/2.5 can be used,\nbut not 3/3.5 or higher.\nRM0436 Rev 7 397/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DTPR2",
            "offset": "0x03C",
            "page": 398,
            "chapter": "7.7.16",
            "resetvalue": "0x1001a0c8",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:19",
                "field": "TDLLK[9:0]",
                "description": "tDLLK\nDLL locking time. Valid values are 2 to 1023.\n"
              },
              {
                "range": "18:15",
                "field": "TCKE[3:0]",
                "description": "tCKE\nCKE minimum pulse width. Also specifies the minimum time that the SDRAM must remain in\npower down or self refresh mode. For DDR3 this parameter must be set to the value of\ntCKESR which is usually bigger than the value of tCKE. Valid values are 2 to 15.\n"
              },
              {
                "range": "14:10",
                "field": "TXP[4:0]",
                "description": "tXP\nPower down exit delay. The minimum time between a power down exit command and any\nother command. This parameter must be set to the maximum of the various minimum power\ndown exit delay parameters specified in the SDRAM datasheet, i.e. max(tXP, tXARD,\ntXARDS) for DDR2 and max(tXP, tXPDLL) for DDR3. Valid values are 2 to 31.\n"
              },
              {
                "range": "9:0",
                "field": "TXS[9:0]",
                "description": "tXS\nSelf refresh exit delay. The minimum time between a self refresh exit command and any\nother command. This parameter must be set to the maximum of the various minimum self\nrefresh exit delay parameters specified in the SDRAM datasheet, i.e. max(tXSNR, tXSRD)\nfor DDR2 and max(tXS, tXSDLL) for DDR3. Valid values are 2 to 1023.\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DDR3_MR0",
            "offset": "0x040",
            "page": 398,
            "chapter": "7.7.17",
            "resetvalue": "0x00000a52",
            "bits": [
              {
                "range": "15:13",
                "field": "RSVD[2:0]",
                "description": "JEDEC reserved.\n"
              },
              {
                "range": "12",
                "field": "PD",
                "description": "Power-down control\nControls the exit time for power-down modes. Refer to SDRAM datasheet for details on\npower-down modes. Valid values are:\n0: Slow exit (DLL off)\n1: Fast exit (DLL on)\n"
              },
              {
                "range": "11:9",
                "field": "WR[2:0]",
                "description": "Write recovery\nThis is the value of the write recovery in clock cycles. It is calculated by dividing the data\nsheet write recovery time, tWR (ns) by the data sheet clock cycle time, tCK (ns) and rounding\nup a non-integer value to the next integer.\nValid values are:\n001: 5\n010: 6\n011: 7\n100: 8\n101: 10\n110: 12\nAll other settings are reserved and should not be used.\nNote: tWR (ns) is the time from the first SDRAM positive clock edge after the last data-in pair\nof a write command, to when a precharge of the same bank can be issued.\n"
              },
              {
                "range": "8",
                "field": "DR",
                "description": "DLL reset (autoclear)\nWriting a â€˜1â€™ to this bit resets the SDRAM DLL. This bit is self clearing,\ni.e. it returns back to â€˜0â€™ after the DLL reset has been issued.\n"
              },
              {
                "range": "7",
                "field": "TM",
                "description": "Operating mode\nSelects either normal operating mode (0) or test mode (1). Test mode is reserved for the\nmanufacturer and should not be used.\n"
              },
              {
                "range": "3",
                "field": "BT",
                "description": "Burst type\nIndicates whether a burst is sequential (0) or interleaved (1).\nBits 6, 5, 4, 2 CL[3:0]: CAS latency\nThe delay, in clock cycles, between when the SDRAM registers a read command to when\ndata is available.\nValid values for CL[3:0] are:\n0010: 5\n0100: 6\n0110: 7\n1000: 8\n1010: 9\n1100: 10\n1110: 11\nOthers: Reserved\n"
              },
              {
                "range": "1:0",
                "field": "BL[1:0]",
                "description": "Burst length\nDetermines the maximum number of column locations that can be accessed during a given\nread or write command.\nValid values for DDR3 are:\n00: 8 (Fixed)\n01: 4 or 8 (On the fly)\n10: 4 (Fixed)\n11: Reserved\nRM0436 Rev 7 399/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DDR3_MR1",
            "offset": "0x044",
            "page": 400,
            "chapter": "7.7.18",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "15:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "QOFF",
                "description": "Output enable/disable\n0: all outputs function as normal\n1: all SDRAM outputs are disabled removing output buffer current.\nThis feature is intended to be used for IDD characterization of read current and should not be\nused in normal operation.\n"
              },
              {
                "range": "11",
                "field": "TDQS",
                "description": "Termination data strobe\nWhen enabled (â€˜1â€™) TDQS provides additional termination resistance outputs that may be\nuseful in some system configurations. (N/A)\n"
              },
              {
                "range": "10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7",
                "field": "LEVEL",
                "description": "Write leveling enable (N/A)\n"
              },
              {
                "range": "4:3",
                "field": "AL[1:0]",
                "description": "Posted CAS Additive Latency:\nSetting additive latency that allows read and write commands to be issued to the SDRAM\nearlier than normal (refer to SDRAM datasheet for details). Valid values are:\n00: 0 (AL disabled)\n01: CL - 1\n10: CL - 2\n11: Reserved\nRM0436 DDR physical interface control (DDRPHYC)\nBits 9, 6, 2 RTT[2:0]: On die termination\nSelects the effective resistance for SDRAM on die termination.\nValid values for {RTT2,RTT1,RTT0} are:\n000: ODT disabled\n001: RZQ/4\n010: RZQ/2\n011: RZQ/6\n100: RZQ/12\n101: RZQ/8\nOthers: Reserved\nBits 5, 1 DIC[1:0]: Output driver impedance control\nControls the output drive strength.\nValid values for {DIC1,DIC0} are:\n00: RZQ/6\n01: RZQ/7\n10: Reserved\n11: Reserved\n"
              },
              {
                "range": "0",
                "field": "DE",
                "description": "DLL enable/disable\nEnable (0) or disable (1) the DLL.\nDLL must be enabled for normal operation.\n7.7.19 DDRPHYC MR1 register for LPDDR2 [alternate]\n(DDRPHYC_LPDDR2_MR1)\nAddress offset: 0x044\nReset value: 0x0000\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. NWR[2:0] WC BT BL[2:0]\nrw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "15:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:5",
                "field": "NWR[2:0]",
                "description": "Write recovery\n001: nWR=3\n100: nWR=6\n110: nWR=8\n111: nWR=9\nOthers: Reserved\nRM0436 Rev 7 401/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "4",
                "field": "WC",
                "description": "Wrap control\n0: wrap\n1: no wrap\n"
              },
              {
                "range": "3",
                "field": "BT",
                "description": "Burst Type: Indicates whether a burst is sequential (0) or interleaved (1). ,\n"
              },
              {
                "range": "2:0",
                "field": "BL[2:0]",
                "description": "Burst length\nDetermines the maximum number of column locations that can be accessed during a given\nread or write command. Valid values are:\n010: 4\n011: 8\n100: 16\nOthers: Reserved\n7.7.20 DDRPHYC MR1 register for LPDDR3 [alternate]\n(DDRPHYC_LPDDR3_MR1)\nAddress offset: 0x044\nReset value: 0x0000\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. NWR[2:0] Res. Res. BL[2:0]\nrw rw rw rw rw rw\n"
              },
              {
                "range": "15:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:5",
                "field": "NWR[2:0]",
                "description": "Write recovery\nIf nWRE (MR2 [4]) = 0:\n- 001: nWR=3\n- 100: nWR=6\n- 110: nWR=8\n- 111: nWR=9\nIf nWRE (MR2[4]) = 1:\n- 000: nWR=10\n- 001: nWR=11\n- 010: nWR=12\nOthers: Reserved\n"
              },
              {
                "range": "4:3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2:0",
                "field": "BL[2:0]",
                "description": "Burst length\nDetermines the maximum number of column locations that can be accessed during a given\nread or write command.\n011: 8\nOthers: Reserved\n402/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DDR3_MR2",
            "offset": "0x048",
            "page": 403,
            "chapter": "7.7.21",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "15:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:9",
                "field": "RTTWR[1:0]",
                "description": "Dynamic ODT\nSelects RTT for dynamic ODT.\n00: Dynamic ODT off\n01: RZQ/4\n10: RZQ/2\n11: Reserved\n"
              },
              {
                "range": "8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7",
                "field": "SRT",
                "description": "Self-refresh temperature range\nSelects either normal (â€˜0â€™) or extended (â€˜1â€™) operating temperature range during self-refresh.\n"
              },
              {
                "range": "6",
                "field": "ASR",
                "description": "Auto self-refresh\nWhen enabled (â€˜1â€™), SDRAM automatically provides self-refresh power management\nfunctions for all supported operating temperature values.\nOtherwise the SRT bit must be programmed to indicate the temperature range.\n"
              },
              {
                "range": "5:3",
                "field": "CWL[2:0]",
                "description": "CAS write latency\nThe delay, in clock cycles, between when the SDRAM registers a write command to when\nwrite data is available.\n000: 5 (tCK = 2.5ns)\n001: 6 (2.5ns > tCK = 1.875ns)\n010: 7 (1.875ns > tCK = 1.5ns)\n011: 8 (1.5ns > tCK = 1.25ns)\nOthers: Reserved\n"
              },
              {
                "range": "2:0",
                "field": "PASR[2:0]",
                "description": "Partial array self-refresh\nSpecifies that data located in areas of the array beyond the specified location are lost if self\nrefresh is entered.\nValid settings for 8 banks are:\n000: Full Array\n001: Half Array (BA[2:0] = 000, 001, 010 & 011)\n010: Quarter Array (BA[2:0] = 000, 001)\n011: 1/8 Array (BA[2:0] = 000)\n100: 3/4 Array (BA[2:0] = 010, 011, 100, 101, 110 & 111)\n101: Half Array (BA[2:0] = 100, 101, 110 & 111)\n110: Quarter Array (BA[2:0] = 110 & 111)\n111: 1/8 Array (BA[2:0] 111)\nRM0436 Rev 7 403/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n7.7.22 DDRPHYC MR2 register for LPDDR2 [alternate]\n(DDRPHYC_LPDDR2_MR2)\nAddress offset: 0x048\nReset value: 0x0000\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. RLWL[2:0]\nrw rw rw\n"
              },
              {
                "range": "15:3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2:0",
                "field": "RLWL[2:0]",
                "description": "Read and write latency\n001: RL = 3 /WL = 1\n010: RL = 4 / WL = 2\n011: RL = 5 / WL = 2\n100: RL = 6 / WL = 3\n101: RL = 7 / WL = 4\n110: RL = 8 / WL = 4\nOthers: Reserved\n7.7.23 DDRPHYC MR2 register for LPDDR3 [alternate]\n(DDRPHYC_LPDDR3_MR2)\nAddress offset: 0x048\nReset value: 0x0000\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. WR WL Res. NWRE Res. RLWL[2:0]\nrw rw rw rw rw rw\n"
              },
              {
                "range": "15:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7",
                "field": "WR",
                "description": "New for LPDDR3 (not used by this PHY, leave at zero)\n"
              },
              {
                "range": "6",
                "field": "WL",
                "description": "New for LPDDR3 (not used by this PHY, leave at zero)\n"
              },
              {
                "range": "5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "NWRE",
                "description": "New for LPDDR3 (not used by this PHY, leave at zero)\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2:0",
                "field": "RLWL[2:0]",
                "description": "Read and write latency\n001: RL = 3 /WL = 1\n010: RL = 4 / WL = 2\n011: RL = 5 / WL = 2\n100: RL = 6 / WL = 3\n101: RL = 7 / WL = 4\n110: RL = 8 / WL = 4\nOthers: Reserved\n404/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DDR3_MR3",
            "offset": "0x04C",
            "page": 405,
            "chapter": "7.7.24",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "MPR",
                "description": "Multi-purpose register enable\nEnables, if set, that read data should come from the Multi-Purpose Register. Otherwise read\ndata come from the DRAM array.\n"
              },
              {
                "range": "1:0",
                "field": "MPRLOC[1:0]",
                "description": "Multi-purpose register (MPR) location\nSelects MPR data location.\n00: Predefined pattern for system calibration\nOthers: Reserved\n7.7.25 DDRPHYC MR3 register for LPDDR2 [alternate]\n(DDRPHYC_LPDDR2_MR3)\nAddress offset: 0x04C\nReset value: 0x0000 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. DS[3:0]\nrw rw rw rw\n"
              },
              {
                "range": "31:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "DS[3:0]",
                "description": "Drive strength\nValid values are:\n0000: Reserved\n0001: 34.3â„¦ typical\n0010: 40â„¦ typical\n0011: 48â„¦ typical\n0100: 60â„¦ typical\n0101: Reserved\n0110: 80â„¦ typical\n0111: 120â„¦ typical\nOthers: Reserved\nRM0436 Rev 7 405/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n7.7.26 DDRPHYC MR3 register for LPDDR3 [alternate]\n(DDRPHYC_LPDDR3_MR3)\nAddress offset: 0x04C\nReset value: 0x0000 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. PDCTL[1:0] DQ[1:0]\nrw rw rw rw\n"
              },
              {
                "range": "31:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:2",
                "field": "PDCTL[1:0]",
                "description": "Power-down control\n00: ODT disabled by DRAM during power-down\n01: ODT enabled by DRAM during power-down\nOthers: Reserved\n"
              },
              {
                "range": "1:0",
                "field": "DQ[1:0]",
                "description": "ODT on-die termination\n00: Disable (default)\n01: Rzq/4 (see note)\n10: Rzq/2\n11: Rzq/1\nNote: Rzq/4 is optional for LPDDR3-1066 devices.\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_ODTCR",
            "offset": "0x050",
            "page": 406,
            "chapter": "7.7.27",
            "resetvalue": "0x00010000",
            "bits": [
              {
                "range": "31:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "WRODT",
                "description": "\nSpecifies whether ODT should be enabled (â€˜1â€™) or disabled (â€˜0â€™) on write\n"
              },
              {
                "range": "15:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "RDODT",
                "description": "\nSpecifies whether ODT should be enabled (â€˜1â€™) or disabled (â€˜0â€™) on read\n406/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DTAR",
            "offset": "0x054",
            "page": 407,
            "chapter": "7.7.28",
            "resetvalue": "0x00000000",
            "bits": []
          },
          {
            "registername": "DDRPHYC_DTDR0",
            "offset": "0x058",
            "page": 407,
            "chapter": "7.7.29",
            "resetvalue": "0xdd22ee11",
            "bits": [
              {
                "range": "31",
                "field": "DTMPR",
                "description": "Data training using MPR (DDR3 Only):\nSpecifies, if set, that data-training should use the SDRAM Multi-Purpose Register (MPR)\nregister. Otherwise data-training is performed by first writing to some locations in the SDRAM\nand then reading the back.\n"
              },
              {
                "range": "30:28",
                "field": "DTBANK[2:0]",
                "description": "Data training bank address:\nSelects the SDRAM bank address to be used during data training.\n"
              },
              {
                "range": "27:12",
                "field": "DTROW[15:0]",
                "description": "Data training row address:\nSelects the SDRAM row address to be used during data training.\n"
              },
              {
                "range": "11:0",
                "field": "DTCOL[11:0]",
                "description": "Data training column address:\nSelects the SDRAM column address to be used during data training.\nThe lower four bits of this address must always be â€œ0000â€.\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nDTBYTE3[7:0] DTBYTE2[7:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nDTBYTE1[7:0] DTBYTE0[7:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:24",
                "field": "DTBYTE3[7:0]",
                "description": "Data training data\nThe first 4 bytes (e.g. shifted as Byte 0,1,2,3) of data used during data training. This same\ndata byte is used for each Byte Lane.\nDefault sequence is a walking 1 while toggling data every data cycle.\n"
              },
              {
                "range": "23:16",
                "field": "DTBYTE2[7:0]",
                "description": "Data Training Data\n"
              },
              {
                "range": "15:8",
                "field": "DTBYTE1[7:0]",
                "description": "Data Training Data\n"
              },
              {
                "range": "7:0",
                "field": "DTBYTE0[7:0]",
                "description": "Data Training Data\nDDR physical interface control (DDRPHYC) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DTDR1",
            "offset": "0x05C",
            "page": 408,
            "chapter": "7.7.30",
            "resetvalue": "0x7788bb44",
            "bits": [
              {
                "range": "31:24",
                "field": "DTBYTE7[7:0]",
                "description": "Data training data:\nThe second 4 bytes (e.g. shifted as Byte 4,5,6,7) of data used during data training. This same\ndata byte is used for each Byte Lane.\nDefault sequence is a walking 1 while toggling data every data cycle.\n"
              },
              {
                "range": "23:16",
                "field": "DTBYTE6[7:0]",
                "description": "Data Training Data\n"
              },
              {
                "range": "15:8",
                "field": "DTBYTE5[7:0]",
                "description": "Data Training Data\n"
              },
              {
                "range": "7:0",
                "field": "DTBYTE4[7:0]",
                "description": "Data Training Data\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_GPR0",
            "offset": "0x178",
            "page": 408,
            "chapter": "7.7.31",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "GPR0[31:0]",
                "description": "General purpose register 0 bits\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_GPR1",
            "offset": "0x17C",
            "page": 408,
            "chapter": "7.7.32",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "GPR1[31:0]",
                "description": "General purpose register 1 bits\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_ZQ0CR0",
            "offset": "0x180",
            "page": 409,
            "chapter": "7.7.33",
            "resetvalue": "0x0000014a",
            "bits": [
              {
                "range": "31",
                "field": "ZQPD",
                "description": "ZCAL power down\nPowers down, if set, the PZQ cell.\n"
              },
              {
                "range": "30",
                "field": "ZCAL",
                "description": "ZCAL trigger\nImpedance Calibration Trigger: A write of '1' to this bit triggers impedance calibration to be\nperformed by the impedance control logic.\nThe impedance calibration trigger bit is self-clearing and returns back to '0' when the\ncalibration is complete.\nNote: If ZDEN is set, then the ZCAL bit should be set to 0.\n"
              },
              {
                "range": "29",
                "field": "ZCALBYP",
                "description": "Impedance calibration bypass\nImpedance Calibration Bypass: Disables, if set, impedance calibration of this ZQ control\nblock when impedance calibration is triggered globally using the ZCAL bit of DDRPHYC_PIR.\nImpedance calibration of this ZQ block may be triggered manually using ZCAL.\n"
              },
              {
                "range": "28",
                "field": "ZDEN",
                "description": "Impedance override enable\nImpedance Over-ride Enable: When this bit is set, it allows users to directly drive the\nimpedance control using the data programmed in the ZQDATA field. Otherwise, the control is\ngenerated automatically by the impedance control logic.\nNote: If ZDEN is set, then the ZCAL bit should be set to 0.\n"
              },
              {
                "range": "27:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "ZDATA[19:0]",
                "description": "Impedance override\nImpedance Over-Ride Data: Data used to directly drive the impedance control.\nZDATA field mapping for D3R I/Os is as follows:\nZDATA[27:20] is reserved and returns zeros on reads\nZDATA[19:15] is used to select the pull-up on-die termination impedance\nZDATA[14:10] is used to select the pull-down on-die termination impedance\nZDATA[9:5] is used to select the pull-up output impedance\nZDATA[4:0] is used to select the pull-down output impedance\nNote: See mPHY ST40c25 Datasheet for ZDATA encoding, default value is: ODT pulp-\nup/down set to hi-impedance and pull-up/down set to ~44.5â„¦ for DDR3, 48.8â„¦ for\nDDR3L, 55.5â„¦ for LPDDR2 typical corner 25C\nDDR physical interface control (DDRPHYC) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_ZQ0CR1",
            "offset": "0x184",
            "page": 410,
            "chapter": "7.7.34",
            "resetvalue": "0x0000007b",
            "bits": [
              {
                "range": "7:4",
                "field": "ZPROG[7:4]",
                "description": "Impedance divide ratio to ext R\nImpedance divide ratio: selects the external resistor divide ratio to be used to set the output\nimpedance and the on-die termination as follows:\nZPROG[7:4] = On-die termination divide select (with RZQ = 240â„¦ Â±1%)\n- 0x0: Reserved\n- 0x1: 120â„¦\n- 0x2: 96â„¦\n- 0x3: 80â„¦\n- 0x4: 69â„¦\n- 0x5: 60â„¦\n- 0x6: 52â„¦\n- 0x7: 46â„¦\n- 0x8: 40â„¦\n- 0x9: 37â„¦\n- 0xA: 34â„¦\n- 0xB: 32â„¦\n- 0xC: 30â„¦\n- 0xD: 28â„¦\n- 0xE: 26.5â„¦\n- 0xF: 25â„¦\n"
              },
              {
                "range": "3:0",
                "field": "ZPROG[3:0]",
                "description": "Impedance divide ratio to ext R\nImpedance divide ratio: selects the external resistor divide ratio to be used to set the output\nimpedance and the on-die termination as follows:\nZPROG[3:0] = Output impedance divide select (with RZQ = 240â„¦ Â±1%)\n- 0x0 to 0x4: Reserved\n- 0x5: 80â„¦\n- 0x6: 69â„¦\n- 0x7: 60â„¦\n- 0x8: 53â„¦\n- 0x9: 48â„¦\n- 0xA: 44â„¦\n- 0xB: 40â„¦\n- 0xC: 37â„¦\n- 0xD: 34â„¦\n- 0xE: 32â„¦\n- 0xF: 30â„¦\n410/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_ZQ0SR0",
            "offset": "0x188",
            "page": 411,
            "chapter": "7.7.35",
            "resetvalue": "0x0000014a",
            "bits": []
          },
          {
            "registername": "DDRPHYC_ZQ0SR1",
            "offset": "0x18C",
            "page": 411,
            "chapter": "7.7.36",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "ZDONE",
                "description": "Impedance calibration done\nIndicates that impedance calibration has completed.\n"
              },
              {
                "range": "30",
                "field": "ZERR",
                "description": "Impedance calibration error\nIf set, indicates that there was an error during impedance calibration.\n"
              },
              {
                "range": "29:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "ZCTRL[19:0]",
                "description": "Impedance control\nImpedance Control: Current value of impedance control.\nZZCTRL field mapping for D3R I/Os is as follows:\nZCTRL[27:20] is reserved and returns zeros on reads\nZCTRL[19:15] is used to select the pull-up on-die termination impedance\nZCTRL[14:10] is used to select the pull-down on-die termination impedance\nZCTRL[9:5] is used to select the pull-up output impedance\nZCTRL[4:0] is used to select the pull-down output impedance\n7 6 5 4 3 2 1 0\nOPU[1:0] OPD[1:0] ZPU[1:0] ZPD[1:0]\nr r r r r r r r\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "7:6",
                "field": "OPU[1:0]",
                "description": "opu calibration status\nOn-Die termination (ODT) pull-up calibration status.\n00: Completed with no errors\n01: Overflow error\n10: Underflow error\n11: Calibration in progress\n"
              },
              {
                "range": "5:4",
                "field": "OPD[1:0]",
                "description": "opd calibration status\nOn-Die termination (ODT) pull-down calibration status.\n00: Completed with no errors\n01: Overflow error\n10: Underflow error\n11: Calibration in progress\n"
              },
              {
                "range": "3:2",
                "field": "ZPU[1:0]",
                "description": "zpu calibration status\nOutput impedance pull-up calibration status. Valid status encodings are:\n00: Completed with no errors\n01: Overflow error\n10: Underflow error\n11: Calibration in progress\n"
              },
              {
                "range": "1:0",
                "field": "ZPD[1:0]",
                "description": "zpd calibration status\nOutput impedance pull-down calibration status. Valid status encodings are:\n00: Completed with no errors\n01: Overflow error\n10: Underflow error\n11: Calibration in progress\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DXnGCR",
            "offset": "0x1C0",
            "page": 412,
            "chapter": "7.7.37",
            "resetvalue": "0x00010e81",
            "bits": [
              {
                "range": "31:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16:14",
                "field": "R0RVSL[2:0]",
                "description": "Read valid system latency in steps\nUsed to specify the read valid system latency relative to the ideal placement of the ITMD read\nvalid signal when bit RVSEL in DDRPHYC_DXCCR register is set to 0.\nPower-up default is 011 (i.e. ideal placement of the read valid signal).\nThe RVSL fields are initially set by the PUB during automatic read valid training but these\nvalues can be overwritten by a direct write to this register.\nValid values are:\n000: read valid system latency = ideal placement - 3\n001: read valid system latency = ideal placement - 2\n010: read valid system latency = ideal placement - 1\n011: read valid system latency = ideal placement\n100: read valid system latency = ideal placement + 1\n101: read valid system latency = ideal placement + 2\n110: read valid system latency = ideal placement + 3\nOthers: Reserved\n"
              },
              {
                "range": "13",
                "field": "RTTOAL",
                "description": "RTT ON additive latency\nIndicates when the ODT control of DQ/DQS SSTL I/Os is set to the value in\nDQODT/DQSODT during read cycles.\nValid values are:\n0: ODT control is set to DQSODT/DQODT almost two cycles before read data preamble\n1: ODT control is set to DQSODT/DQODT almost one cycle before read data preamble\n"
              },
              {
                "range": "12:11",
                "field": "RTTOH[1:0]",
                "description": "RTT output hold\nIndicates the number of clock cycles (from 0 to 3) after the read data postamble for which\nODT control should remain set to DQSODT for DQS or DQODT for DQ/DM before disabling\nit (setting it to â€˜0â€™) when using dynamic ODT control.\nODT is disabled almost RTTOH clock cycles after the read postamble\n"
              },
              {
                "range": "10",
                "field": "DQRTT",
                "description": "DQ dynamic RTT control\nIndicates, if set, that the ODT control of DQ/DM SSTL I/Os be dynamically controlled by\nsetting it to the value in DQODT during reads and disabling it (setting it to â€˜0â€™) during any\nother cycle.\nIf this bit is not set, then the ODT control of DQ SSTL I/Os is always set to the value in\nDQODT.\nSince dynamic ODT is on by default, when using LPDDR2/LPDDR3 this bit must be set to 0\nsince LPDDR2/LPDDR3 does not require ODT to be on.`\n"
              },
              {
                "range": "9",
                "field": "DQSRTT",
                "description": "DQS dynamic RTT control\nIndicates, if set, that the ODT control of DQS SSTL I/Os be dynamically controlled by setting\nit to the value in DQSODT during reads and disabling it (setting it to â€˜0â€™) during any other\ncycle.\nIf this bit is not set, then the ODT control of DQS SSTL I/Os is always set to the value in\nDQSODT field.\nSince dynamic ODT is on by default, when using LPDDR2/LPDDR3 this bit must be set to 0\nsince LPDDR2/LPDDR3 does not require ODT to be on.\nRM0436 Rev 7 413/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "8:7",
                "field": "DSEN[1:0]",
                "description": "Write DQS enable\nControls whether the write DQS going to the SDRAM is enabled (toggling) or disabled (static\nvalue) and whether the DQS is inverted.\nDQS# is always the inversion of DQS.\nThese values are valid only when DQS/DQS# output enable is on, otherwise the DQS/DQS#\nis tristated.\nValid settings are:\n00: DQS disabled (Driven to constant 0)\n01: DQS toggling with normal polarity (This should be the default setting)\n10: DQS toggling with inverted polarity\n11: DQS disabled (Driven to constant 1)\n"
              },
              {
                "range": "6",
                "field": "DQSRPD",
                "description": "DQSR power-down\nPowers down, if set, the PDQSR cell.\nThis bit is ORed with the common PDR configuration bit\n"
              },
              {
                "range": "5",
                "field": "DXPDR",
                "description": "Data power-down receiver\nPowers down, when set, the input receiver on I/O for DQ, DM, and DQS/DQS# pins of the\nbyte. This bit is ORed with the common PDR configuration bit\n"
              },
              {
                "range": "4",
                "field": "DXPDD",
                "description": "Data power-down driver\nPowers down, when set, the output driver on I/O for DQ, DM, and DQS/DQS# pins of the\nbyte. This bit is ORed with the common PDD configuration bit\n"
              },
              {
                "range": "3",
                "field": "DXIOM",
                "description": "Data I/O mode\nSelects SSTL mode (when set to 0) or CMOS mode (when set to 1) for the I/O for DQ, DM,\nand DQS/DQS# pins of the byte.\nThis bit is ORed with the IOM configuration bit of the individual DATX8\n"
              },
              {
                "range": "2",
                "field": "DQODT",
                "description": "DQ ODT enable\nEnables, when set, the on-die termination on the I/O for DQ and DM pins of the byte.\nThis bit is ORed with the common DATX8 ODT configuration bit\n"
              },
              {
                "range": "1",
                "field": "DQSODT",
                "description": "DQS ODT enable\nEnables, when set, the on-die termination on the I/O for DQS/DQS# pin of the byte.\nThis bit is ORed with the common DATX8 ODT configuration bit\n"
              },
              {
                "range": "0",
                "field": "DXEN",
                "description": "DATA byte enable\nEnables, if set, the DATX8 and SSTL I/Os used on the data byte.\nSetting this bit to â€˜0â€™ disables the byte, i.e. the byte SSTL I/Os are put in power-down mode\nand the DLL in the DATX8 is put in bypass mode.\nAfter changing a Byte Lane from disabled to enabled, the DLL for that Byte Lane must be\nreset and re-locked.\nSoftware can use bits DLLSRST and DLLLOCK of DDRPHYC_PIR register to accomplish\nthis (reset and re-locks all DLLs in the DDR PHY).\n414/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DXnGSR0",
            "offset": "0x1C4",
            "page": 415,
            "chapter": "7.7.38",
            "resetvalue": "0x00000000",
            "bits": []
          },
          {
            "registername": "DDRPHYC_DXnGSR1",
            "offset": "0x1C8",
            "page": 415,
            "chapter": "7.7.39",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "15:13",
                "field": "DTPASS[2:0]",
                "description": "DQS training pass count\nThe number of passing configurations during DQS gate training.\n"
              },
              {
                "range": "12:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8",
                "field": "DTIERR",
                "description": "DQS gate training intermittent error\nIf set, indicates that there was an intermittent error during DQS gate training of the byte, such\nas a pass was followed by a fail then followed by another pass.\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "DTERR",
                "description": "DQS gate training error\nIf set, indicates that a valid DQS gating window could not be found during DQS gate training\nof the byte.\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "DTDONE",
                "description": "Data training done\nIndicates, if set, that the byte has finished doing data training.\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. RVPASS[2:0] Res. Res. Res.\nRREIVR\nr r r r\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res.\nRREVR\nRes. Res. Res. Res. Res. Res. DQSDFT[1:0] Res. Res. Res.\nRRETFD\nr r r r\n"
              },
              {
                "range": "31:23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22:20",
                "field": "RVPASS[2:0]",
                "description": "Read valid training pass count\nThe number of passing configurations during read valid training.\n"
              },
              {
                "range": "19:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "16",
                "field": "RVIERR",
                "description": "RV intermittent error for rank\nIf set, indicates that there was an intermittent error during read valid training of the byte, such\nas a pass was followed by a fail then followed by another pass.\n"
              },
              {
                "range": "15:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "RVERR",
                "description": "RV training error\nIf set, indicates that a valid read valid placement could not be found during read valid training\nof the byte\n"
              },
              {
                "range": "11:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5:4",
                "field": "DQSDFT[1:0]",
                "description": "DQS drift value\nUsed to report the drift on the read data strobe of the data byte.\nValid settings are:\n00: No drift\n01: 90Â° drift\n10: 180Â° drift\n11: 270Â° drift or more\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "DFTERR",
                "description": "DQS drift error\nIf set, indicates that the byte read data strobe has drifted by more than or equal to the drift\nlimit set in the PHY General Configuration Register (PGCR).\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DXnDLLCR",
            "offset": "0x1CC",
            "page": 416,
            "chapter": "7.7.40",
            "resetvalue": "0x40000000",
            "bits": [
              {
                "range": "31",
                "field": "DLLDIS",
                "description": "DLL bypass\nA disabled DLL is bypassed. Default ('0') is DLL enabled.\nNote: DLL bypass must only be changed when DDRPHYC clock (dphy_ker_ck) is inactive.\n"
              },
              {
                "range": "30",
                "field": "DLLSRST",
                "description": "DLL reset\nSoft resets the byte DLL by driving the DLL soft reset pin.\nNote: DLL reset must only be changed to 0 when DDRPHYC clock (dphy_ker_ck) is inactive.\n"
              },
              {
                "range": "29:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19",
                "field": "SDLBMODE",
                "description": "Bypass slave DLL during loopback\nIf this bit is set, the slave DLL is put in loopback mode in which there is no 90 degrees phase\nshift on read DQS/DQS#. This bit must be set when operating the byte PHYs in loopback\nmode.\nRM0436 DDR physical interface control (DDRPHYC)\n"
              },
              {
                "range": "18",
                "field": "ATESTEN",
                "description": "Enable path to pin 'ATO'\nEnables the analog test signal to be output on the DLL analog test output (DDR_ATO).\nThe DLL analog test output is tri-stated when this bit is '0'.\n"
              },
              {
                "range": "17:14",
                "field": "SDPHASE[3:0]",
                "description": "Slave DLL phase\nSelects the phase difference between the input clock and\nthe corresponding output clock of the slave DLL. Valid settings:\n0000: 90\n0001: 72\n0010: 54\n0011: 36\n0100: 108\n0101: 90\n0110: 72\n0111: 54\n1000: 126\n1001: 108\n1010: 90\n1011: 72\n1100: 144\n1101: 126\n1110: 108\n1111: 90\n"
              },
              {
                "range": "13:12",
                "field": "SSTART[1:0]",
                "description": "Slave DLL autostart\nUsed to control how the slave DLL starts up relative to the\nmaster DLL locking:\n0X: Slave DLL automatically starts up once the master DLL has achieved lock.\n10: The automatic startup of the slave DLL is disabled; the phase detector is\ndisabled.\n11: The automatic startup of the slave DLL is disabled; the phase detector is\nenabled.\n"
              },
              {
                "range": "11:9",
                "field": "MFWDLY[2:0]",
                "description": "Master DLL feed-forward trim\nUsed to trim the delay in the master DLL feedforward path:\n000: minimum delay\n...\n111: maximum delay\nRM0436 Rev 7 417/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "8:6",
                "field": "MFBDLY[2:0]",
                "description": "Master DLL feed-back trim\nUsed to trim the delay in the master DLL feedback path:\n000: minimum delay\n...\n111: maximum delay\n"
              },
              {
                "range": "5:3",
                "field": "SFWDLY[2:0]",
                "description": "Slave DLL feed-forward trim\nSlave Feed-Forward Delay Trim: Used to trim the delay in the slave DLL feedforward path:\n000: minimum delay\n...\n111: maximum delay\n"
              },
              {
                "range": "2:0",
                "field": "SFBDLY[2:0]",
                "description": "Slave DLL feed-back trim\nSlave Feed-Back Delay Trim: Used to trim the delay in the slave DLL feedback path:\n000: minimum delay\n...\n111: maximum delay\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DXnDQTR",
            "offset": "0x1D0",
            "page": 418,
            "chapter": "7.7.41",
            "resetvalue": "0xffffffff",
            "bits": [
              {
                "range": "31:28",
                "field": "DQDLY7[3:0]",
                "description": "DQ delay for bit 7\nUsed to adjust the delay of the data relative to the nominal delay that is matched to the delay\nof the data strobes through the slave DLL and clock tree.\nThe lower two bits of the DQDLY for each DQ bit controls the delay for the data clocked by\nDQS, while the higher two bits control the delay for the data clocked by DQS_b.\nValid settings for each 2-bit control field are:\n00: nominal delay\n01: nominal delay + 1 step\n10: nominal delay + 2 steps\n11: nominal delay + 3 steps\n"
              },
              {
                "range": "27:24",
                "field": "DQDLY6[3:0]",
                "description": "DQ delay for bit 6\nidem\n"
              },
              {
                "range": "23:20",
                "field": "DQDLY5[3:0]",
                "description": "DQ delay for bit 5\nIdem\n"
              },
              {
                "range": "19:16",
                "field": "DQDLY4[3:0]",
                "description": "DQ delay for bit 4\nIdem\n"
              },
              {
                "range": "15:12",
                "field": "DQDLY3[3:0]",
                "description": "DQ delay for bit 3\nIdem\n418/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              },
              {
                "range": "11:8",
                "field": "DQDLY2[3:0]",
                "description": "DQ delay for bit 2\nIdem\n"
              },
              {
                "range": "7:4",
                "field": "DQDLY1[3:0]",
                "description": "DQ delay for bit 1\nIdem\n"
              },
              {
                "range": "3:0",
                "field": "DQDLY0[3:0]",
                "description": "DQ delay for bit 0\nIdem\n"
              }
            ]
          },
          {
            "registername": "DDRPHYC_DXnDQSTR",
            "offset": "0x1D4",
            "page": 419,
            "resetvalue": "0x3db02000",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:26",
                "field": "DMDLY[3:0]",
                "description": "DM delay\nUsed to adjust the delay of the data relative to the nominal delay that is matched to the delay\nof the data strobes through the slave DLL and clock tree.\nThe lower two bits of the DQDLY for each DQ bit controls the delay for the data clocked by\nDQS, while the higher two bits control the delay for the data clocked by DQS_b.\nValid settings for each 2-bit control field are:\n00: nominal delay\n01: nominal delay + 1 step\n10: nominal delay + 2 steps\n11: nominal delay + 3 steps\n"
              },
              {
                "range": "25:23",
                "field": "DQSNDLY[2:0]",
                "description": "DQS# delay\nUsed to adjust the delay of the data strobes relative to the nominal delay that is matched to\nthe delay of the data bit through the slave DLL and clock tree.\nValid values are:\n000: nominal delay - 3 steps\n001: nominal delay - 2 steps\n010: nominal delay - 1 step\n011: nominal delay\n100: nominal delay + 1 step\n101: nominal delay + 2 steps\n110: nominal delay + 3 steps\n111: nominal delay + 4 steps\nNote: - After changing this value, an ITM soft reset must be issued: bit ITMSRST=1 and bit\nINIT=1 in DDRPHYC_PIR register.\nRM0436 Rev 7 419/4054\n426\nDDR physical interface control (DDRPHYC) RM0436\n"
              },
              {
                "range": "22:20",
                "field": "DQSDLY[2:0]",
                "description": "DQS delay\nUsed to adjust the delay of the data strobes relative to the nominal delay that is matched to\nthe delay of the data bit through the slave DLL and clock tree.\nValid values are:\n000: nominal delay - 3 steps\n001: nominal delay - 2 steps\n010: nominal delay - 1 step\n011: nominal delay\n100: nominal delay + 1 step\n101: nominal delay + 2 steps\n110: nominal delay + 3 steps\n111: nominal delay + 4 steps\nNote: - After changing this value, an ITM soft reset (bit ITMSRST=1 and bit INIT=1 in\nDDRPHYC_PIR register) must be issued.\n"
              },
              {
                "range": "19:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13:12",
                "field": "R0DGPS[1:0]",
                "description": "Rank 0 DQS gating phase select\nSelects the clock used to enable the data strobes during read so that the value of the data\nstrobes before and after the preamble/postamble are filtered out.\nR0DGPS is initially set by the PUBL during automatic DQS data training and subsequently\nupdated during data strobe drift compensation. However, these values can be overwritten by\na direct write to this register, and the automatic update during DQS drift compensation can be\ndisabled using the PHY General Configuration Register (PGCR).\nValid values are:\n00: 180 clock (clk180)\n01: 270 clock (clk270)\n10: 360 clock (clk0)\n11: 450 clock (next clk90)\n"
              },
              {
                "range": "11:3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2:0",
                "field": "R0DGSL[2:0]",
                "description": "Rank 0 DQS gating system latency\nUsed to increase the number of clock cycles needed to expect valid DDR read data by up to\nfive extra clock cycles.\nThis is used to compensate for board delays and other system delays.\nPower-up default is 000 (i.e. no extra clock cycles required).\nThe SL fields are initially set by the PUBL during automatic DQS data training but these\nvalues can be overwritten by a direct write to this register.\nValid values are:\n000: No extra clock cycles\n001: 1 extra clock cycle\n010: 2 extra clock cycles\n011: 3 extra clock cycles\n100: 4 extra clock cycles\n101: 5 extra clock cycles\nOthers: Reserved\n420/4054 RM0436 Rev 7\nRM0436 DDR physical interface control (DDRPHYC)\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "DDRCTRL registers",
        "registers": [
          {
            "registername": "DDRCTRL_MSTR",
            "offset": "0x000",
            "page": 219,
            "chapter": "5.7.1",
            "resetvalue": "0x00040001",
            "bits": [
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "19:16",
                "field": "BURST_RDWR[3:0]",
                "description": "SDRAM burst length used:\n- 0001 - Burst length of 2 (only supported for mDDR)\n- 0010 - Burst length of 4\n- 0100 - Burst length of 8\n- 1000 - Burst length of 16 (only supported for mDDR, LPDDR2, and LPDDR4)\nAll other values are reserved.\nThis controls the burst size used to access the SDRAM. This must match the burst length mode\nregister setting in the SDRAM. (For BC4/8 on-the-fly mode of DDR3 and DDR4, set this field to\n0x0100) The burst length of 2 is not supported with the AXI ports when\nMEMC_BURST_LENGTH is 8.\nThe burst length of 2 is only supported when the controller is operating in 1:1 frequency mode.\nFor DDR3, DDR4 and LPDDR3, this must be set to 0x0100 (BL8).\nFor LPDDR4, this must be set to 0x1000 (BL16).\nProgramming mode: Static\n"
              },
              {
                "range": "15",
                "field": "DLL_OFF_MODE",
                "description": "Set to 1 when the DDRCTRL and DRAM has to be put in DLL-off mode for\nlow frequency operation.\nSet to 0 to put DDRCTRL and DRAM in DLL-on mode for normal frequency operation.\nIf DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), dll_off_mode\nis not supported, and this bit must be set to '0'.\nProgramming mode: Quasi-dynamic Group 2\n"
              },
              {
                "range": "14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13:12",
                "field": "DATA_BUS_WIDTH[1:0]",
                "description": "Selects proportion of DQ bus width that is used by the SDRAM\n- 00 - Full DQ bus width to SDRAM\n- 01 - Half DQ bus width to SDRAM\n- 10 - Reserved\n- 11 - Reserved\nProgramming mode: Static\n"
              },
              {
                "range": "11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10",
                "field": "EN_2T_TIMING_MODE",
                "description": "If 1, then the DDRCTRL uses 2T timing. Otherwise, uses 1T timing. In\n2T timing, all command signals (except chip select) are held for 2 clocks on the SDRAM bus.\nThe chip select is asserted on the second cycle of the command\nNote: 2T timing is not supported in LPDDR2/LPDDR3/LPDDR4 mode\nNote: 2T timing is not supported if the configuration parameter MEMC_CMD_RTN2IDLE is set\nNote: 2T timing is not supported in DDR4 geardown mode.\nNote: 2T timing is not supported in Shared-AC dual channel mode and the register value is\ndon't care.\nProgramming mode: Static\n"
              },
              {
                "range": "9",
                "field": "BURSTCHOP",
                "description": "When set, enable burst-chop (BC4 or 8 on-the-fly) in DDR3/DDR4. The burst-\nchop for Reads is exercised only in HIF configurations (UMCTL2_INCL_ARB not set) and if in\nfull bus width mode (MSTR.data_bus_width = 00) and if MEMC_BURST_LENGTH=8 or 16.\nThe burst-chop for writes is exercised only if partial writes enabled (UMCTL2_PARTIAL_WR=1)\nand if CRC is disabled (CRCPARCTL1.crc_enable = 0).\nThe BC4 (fixed) mode is not supported.\nProgramming mode: Static\n"
              },
              {
                "range": "8:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n220/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "3",
                "field": "LPDDR3",
                "description": "Selects LPDDR3 SDRAM\n- 1 - LPDDR3 SDRAM device in use.\n- 0 - non-LPDDR3 device in use\nPresent only in designs configured to support LPDDR3.\nProgramming mode: Static\n"
              },
              {
                "range": "2",
                "field": "LPDDR2",
                "description": "Selects LPDDR2 SDRAM\n- 1 - LPDDR2 SDRAM device in use.\n- 0 - non-LPDDR2 device in use\nPresent only in designs configured to support LPDDR2.\nProgramming mode: Static\n"
              },
              {
                "range": "1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "DDR3",
                "description": "Selects DDR3 SDRAM\n- 1 - DDR3 SDRAM device in use\n- 0 - non-DDR3 SDRAM device in use\nOnly present in designs that support DDR3.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_STAT",
            "offset": "0x004",
            "page": 221,
            "chapter": "5.7.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "SELFREF_CAM_NOT_EMPTY",
                "description": "Self refresh with CAMs not empty. Set to 1 when Self Refresh\nis entered but CAMs are not drained. Cleared after exiting Self Refresh.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "11:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "5:4",
                "field": "SELFREF_TYPE[1:0]",
                "description": "Flags if Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4) is\nentered and if it was under Automatic Self Refresh control only or not.\n- 00 - SDRAM is not in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4). If retry is\nenabled by CRCPARCTRL1.crc_parity_retry_enable, this also indicates SRE command is still\nin parity error window or retry is in-progress.\n- 11 - SDRAM is in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4), which was\ncaused by Automatic Self Refresh only. If retry is enabled, this guarantees SRE command is\nexecuted correctly without parity error.\n- 10 - SDRAM is in Self Refresh (except LPDDR4) or SR-Powerdown (LPDDR4), which was\nnot caused solely under Automatic Self Refresh control. It could have been caused by\nHardware Low-power Interface and/or Software (PWRCTL.selfref_sw). If retry is enabled, this\nguarantees SRE command is executed correctly without parity error.\n- 01 - SDRAM is in Self Refresh, which was caused by PHY Master Request.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2:0",
                "field": "OPERATING_MODE[2:0]",
                "description": "Operating mode. This is 3-bits wide in configurations with\nmDDR/LPDDR2/LPDDR3/LPDDR4/DDR4 support and 2-bits in all other configurations.\nCondition non-mDDR/LPDDR2/LPDDR3/LPDDR4 and non-DDR4 designs:\n- 000 - Init\n- 001 - Normal\n- 010 - Power-down\n- 011 - Self refresh\nCondition mDDR/LPDDR2/LPDDR3 or DDR4 designs:\n- 000 - Init\n- 001 - Normal\n- 010 - Power-down\n- 011 - Self refresh\n- 1XX - Deep power-down / Maximum Power Saving Mode\nCondition LPDDR4 designs:\n- 000 - Init\n- 001 - Normal\n- 010 - Power-down\n- 011 - Self refresh / Self refresh power-down\nProgramming mode: Dynamic\n222/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n5.7.3 DDRCTRL mode register read/write control register 0\n(DDRCTRL_MRCTRL0)\nAddress offset: 0x010\nReset value: 0x0000 0010\nMode Register Read/Write Control Register 0.\nNote: Do not enable more than one of the following fields simultaneously:\nâ€¢ sw_init_int\nâ€¢ pda_en\nâ€¢ mpr_en\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRM0436 Rev 7 223/4054\n318\nRW_RM\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\nrs\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nMR_ADDR[3:0] Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\nEPYT_RM\nrw rw rw rw rw\n"
              },
              {
                "range": "31",
                "field": "MR_WR",
                "description": "Setting this register bit to 1 triggers a mode register read or write operation. When the\nMR operation is complete, the DDRCTRL automatically clears this bit. The other register fields\nof this register must be written in a separate APB transaction, before setting this mr_wr bit. It is\nrecommended NOT to set this signal if in Init, Deep power-down or MPSM operating modes.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "30:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:12",
                "field": "MR_ADDR[3:0]",
                "description": "Address of the mode register that is to be written to.\n- 0000 - MR0\n- 0001 - MR1\n- 0010 - MR2\n- 0011 - MR3\n- 0100 - MR4\n- 0101 - MR5\n- 0110 - MR6\n- 0111 - MR7\nDon't Care for LPDDR2/LPDDR3/LPDDR4 (see MRCTRL1.mr_data for mode register\naddressing in LPDDR2/LPDDR3/LPDDR4)\nThis signal is also used for writing to control words of the register chip on RDIMMs/LRDIMMs.\nIn that case, it corresponds to the bank address bits sent to the RDIMM/LRDIMM\nIn case of DDR4, the bit[3:2] corresponds to the bank group bits. Therefore, the bit[3] as well as\nthe bit[2:0] must be set to an appropriate value which is considered both the Address Mirroring\nof UDIMMs/RDIMMs/LRDIMMs and the Output Inversion of RDIMMs/LRDIMMs.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "11:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "0",
                "field": "MR_TYPE",
                "description": "Indicates whether the mode register operation is read or write. Only used for\nLPDDR2/LPDDR3/LPDDR4/DDR4.\n- 0 - Write, MRCTRL register does not support MR read for LPDDR2/3\n- 1 - Reserved\nProgramming mode: Dynamic\n5.7.4 DDRCTRL mode register read/write control register 1\n(DDRCTRL_MRCTRL1)\nAddress offset: 0x014\nReset value: 0x0000 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nMR_DATA[15:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "MR_DATA[15:0]",
                "description": "Mode register write data for all non-LPDDR2/non-LPDDR3/non-LPDDR4\nmodes.\nFor LPDDR2/LPDDR3/LPDDR4, MRCTRL1[15:0] are interpreted as\n[15:8] MR Address\n[7:0] MR data for writes, don't care for reads. This is 18-bits wide in configurations with DDR4\nsupport and 16-bits in all other configurations.\nProgramming mode: Dynamic\n224/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n5.7.5 DDRCTRL mode register read/write status register\n(DDRCTRL_MRSTAT)\nAddress offset: 0x018\nReset value: 0x0000 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n5.7.6 DDRCTRL temperature derate enable register\n(DDRCTRL_DERATEEN)\nAddress offset: 0x020\nReset value: 0x0000 0000\nRM0436 Rev 7 225/4054\n318\nYSUB_RW_RM\nr\n"
              },
              {
                "range": "31:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "MR_WR_BUSY",
                "description": "The SoC core may initiate a MR write operation only if this signal is low. This\nsignal goes high in the clock after the DDRCTRL accepts the MRW/MRR request. It goes low\nwhen the MRW/MRR command is issued to the SDRAM. It is recommended not to perform\nMRW/MRR commands when 'MRSTAT.mr_wr_busy' is high.\n- 0 - Indicates that the SoC core can initiate a mode register write operation\n- 1 - Indicates that mode register write operation is in progress\nProgramming mode: Dynamic\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. DERATE_BYTE[3:0] Res.\n]0:1[EULAV_ETARED\nELBANE_ETARED\nrw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "7:4",
                "field": "DERATE_BYTE[3:0]",
                "description": "Derate byte\nPresent only in designs configured to support LPDDR2/LPDDR3/LPDDR4\nIndicates which byte of the MRR data is used for derating. The maximum valid value depends\non MEMC_DRAM_TOTAL_DATA_WIDTH.\nProgramming mode: Static\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2:1",
                "field": "DERATE_VALUE[1:0]",
                "description": "Derate value\n- 0 - Derating uses +1.\n- 1 - Derating uses +2.\nPresent only in designs configured to support LPDDR2/LPDDR3/LPDDR4\nSet to 0 for all LPDDR2 speed grades as derating value of +1.875 ns is less than a\ncore_ddrc_core_clk period.\nFor LPDDR3/4, if the period of core_ddrc_core_clk is less than 1.875ns, this register field\nshould be set to 1; otherwise it should be set to 0.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "0",
                "field": "DERATE_ENABLE",
                "description": "Enables derating\n- 0 - Timing parameter derating is disabled\n- 1 - Timing parameter derating is enabled using MR4 read value.\nPresent only in designs configured to support LPDDR2/LPDDR3/LPDDR4\nThis field must be set to '0' for non-LPDDR2/LPDDR3/LPDDR4 mode.\nProgramming mode: Dynamic\n5.7.7 DDRCTRL temperature derate interval register\n(DDRCTRL_DERATEINT)\nAddress offset: 0x024\nReset value: 0x0080 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nMR4_READ_INTERVAL[31:16]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nMR4_READ_INTERVAL[15:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:0",
                "field": "MR4_READ_INTERVAL[31:0]",
                "description": "Interval between two MR4 reads, used to derate the timing\nparameters.\nPresent only in designs configured to support LPDDR2/LPDDR3/LPDDR4. This register must\nnot be set to zero.\nUnit: DFI clock cycle.\nProgramming mode: Static\n226/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_PWRCTL",
            "offset": "0x030",
            "page": 227,
            "chapter": "5.7.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7",
                "field": "DIS_CAM_DRAIN_SELFREF",
                "description": "Indicates whether skipping CAM draining is allowed when\nentering Self-Refresh.\nThis register field cannot be modified while PWRCTL.selfref_sw==1.\n- 0 - CAMs must be empty before entering SR\n- 1 - CAMs are not emptied before entering SR (unsupported)\nNote, PWRCTL.dis_cam_drain_selfref=1 is unsupported in this release.\nPWRCTL.dis_cam_drain_selfref=0 is required.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "SELFREF_SW",
                "description": "A value of 1 to this register causes system to move to Self Refresh state\nimmediately, as long as it is not in INIT or DPD/MPSM operating_mode. This is referred to as\nSoftware Entry/Exit to Self Refresh.\n- 1 - Software Entry to Self Refresh\n- 0 - Software Exit from Self Refresh\nProgramming mode: Dynamic\n"
              },
              {
                "range": "4",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "3",
                "field": "EN_DFI_DRAM_CLK_DISABLE",
                "description": "Enable the assertion of dfi_dram_clk_disable whenever a\nclock is not required by the SDRAM.\nIf set to 0, dfi_dram_clk_disable is never asserted.\nAssertion of dfi_dram_clk_disable is as follows:\nIn DDR2/DDR3, can only be asserted in Self Refresh.\nIn DDR4, can be asserted in following:\n- in Self Refresh.\n- in Maximum Power Saving Mode\nIn mDDR/LPDDR2/LPDDR3, can be asserted in following:\n- in Self Refresh\n- in Power Down\n- in Deep Power Down\n- during Normal operation (Clock Stop)\nIn LPDDR4, can be asserted in following:\n- in Self Refresh Power Down\n- in Power Down\n- during Normal operation (Clock Stop)\nProgramming mode: Dynamic\n"
              },
              {
                "range": "2",
                "field": "DEEPPOWERDOWN_EN",
                "description": "When this is 1, DDRCTRL puts the SDRAM into deep power-down\nmode when the transaction store is empty.\nThis register must be reset to '0' to bring DDRCTRL out of deep power-down mode. Controller\nperforms automatic SDRAM initialization on deep power-down exit.\nPresent only in designs configured to support mDDR or LPDDR2 or LPDDR3. For non-\nmDDR/non-LPDDR2/non-LPDDR3, this register should not be set to 1.\nFor performance only\nProgramming mode: Dynamic\n"
              },
              {
                "range": "1",
                "field": "POWERDOWN_EN",
                "description": "If true then the DDRCTRL goes into power-down after a programmable\nnumber of cycles \"maximum idle clocks before power down\" (PWRTMG.powerdown_to_x32).\nThis register bit may be re-programmed during the course of normal operation.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "0",
                "field": "SELFREF_EN",
                "description": "If true then the DDRCTRL puts the SDRAM into Self Refresh after a\nprogrammable number of cycles \"maximum idle clocks before Self Refresh\n(PWRTMG.selfref_to_x32)\". This register bit may be re-programmed during the course of\nnormal operation.\nProgramming mode: Dynamic\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_PWRTMG",
            "offset": "0x034",
            "page": 228,
            "chapter": "5.7.9",
            "resetvalue": "0x00402010",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:16",
                "field": "SELFREF_TO_X32[7:0]",
                "description": "After this many clocks of the DDRC command channel being idle the\nDDRCTRL automatically puts the SDRAM into Self Refresh. The DDRC command channel is\nconsidered idle when there are no HIF commands outstanding. This must be enabled in the\nPWRCTL.selfref_en.\nUnit: Multiples of 32 DFI clocks.\nFor performance only.\nProgramming mode: Quasi-dynamic Group 4\n"
              },
              {
                "range": "15:8",
                "field": "T_DPD_X4096[7:0]",
                "description": "Minimum deep power-down time.\nFor mDDR, value from the JEDEC specification is 0 as mDDR exits from deep power-down\nmode immediately after PWRCTL.deeppowerdown_en is de-asserted.\nFor LPDDR2/LPDDR3, value from the JEDEC specification is 500us.\nUnit: Multiples of 4096 DFI clocks.\nPresent only in designs configured to support mDDR, LPDDR2 or LPDDR3.\nFor performance only.\nProgramming mode: Quasi-dynamic Group 4\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "POWERDOWN_TO_X32[4:0]",
                "description": "After this many clocks of the DDRC command channel being\nidle the DDRCTRL automatically puts the SDRAM into power-down. The DDRC command\nchannel is considered idle when there are no HIF commands outstanding. This must be\nenabled in the PWRCTL.powerdown_en.\nUnit: Multiples of 32 DFI clocks\nFor performance only.\nProgramming mode: Quasi-dynamic Group 4\n5.7.10 DDRCTRL hardware low power control register\n(DDRCTRL_HWLPCTL)\nAddress offset: 0x038\nReset value: 0x0000 0003\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. HW_LP_IDLE_X32[11:0]\nrw rw rw rw rw rw rw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\nRM0436 Rev 7 229/4054\n318\nNE_ELDI_TIXE_PL_WH\nNE_PL_WH\nrw rw\n"
              },
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "27:16",
                "field": "HW_LP_IDLE_X32[11:0]",
                "description": "Hardware idle period. The cactive_ddrc output is driven low if the\nDDRC command channel is idle for hw_lp_idle * 32 cycles if not in INIT or DPD/MPSM\noperating_mode. The DDRC command channel is considered idle when there are no HIF\ncommands outstanding. The hardware idle function is disabled when hw_lp_idle_x32=0.\nUnit: Multiples of 32 DFI clocks.\nFor performance only.\nProgramming mode: Static\n"
              },
              {
                "range": "15:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "HW_LP_EXIT_IDLE_EN",
                "description": "When this bit is programmed to 1 the cactive_in_ddrc pin of the\nDDRC can be used to exit from the automatic clock stop, automatic power down or automatic\nself-refresh modes. Note, it does not cause exit of Self-Refresh that is caused by Hardware\nLow power interface and/or software (PWRCTL.selfref_sw).\nProgramming mode: Static\n"
              },
              {
                "range": "0",
                "field": "HW_LP_EN",
                "description": "Enable for hardware low power interface.\nProgramming mode: Quasi-dynamic Group 3\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_RFSHCTL0",
            "offset": "0x050",
            "page": 230,
            "chapter": "5.7.11",
            "resetvalue": "0x00210000",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:20",
                "field": "REFRESH_MARGIN[3:0]",
                "description": "Threshold value in number of DFI clock cycles before the critical\nrefresh or page timer expires. A critical refresh is to be issued before this threshold is reached.\nIt is recommended that this not be changed from the default value, currently shown as 0x2. It\nmust always be less than internally used t_rfc_nom/32. Note that internally used t_rfc_nom is\nequal to RFSHTMG.t_rfc_nom_x1_x32 * 32 if RFSHTMG.t_rfc_nom_x1_sel=0. If\nRFSHTMG.t_rfc_nom_x1_sel=1 (for LPDDR2/LPDDR3/LPDDR4 per-bank refresh only),\ninternally used t_rfc_nom is equal to RFSHTMG.t_rfc_nom_x1_x32. Note that, in\nLPDDR2/LPDDR3/LPDDR4, internally used t_rfc_nom may be divided by four if derating is\nenabled (DERATEEN.derate_enable=1).\nUnit: Multiples of 32 DFI clocks.\nProgramming mode: Dynamic - Refresh Related\n"
              },
              {
                "range": "19:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "16:12",
                "field": "REFRESH_TO_X32[4:0]",
                "description": "If the refresh timer (tRFCnom, also known as tREFI) has expired at\nleast once, but it has not expired (RFSHCTL0.refresh_burst+1) times yet, then a speculative\nrefresh may be performed. A speculative refresh is a refresh performed at a time when refresh\nwould be useful, but before it is absolutely required. When the SDRAM bus is idle for a period\nof time determined by this RFSHCTL0.refresh_to_x32 and the refresh timer has expired at\nleast once since the last refresh, then a speculative refresh is performed. Speculative refreshes\ncontinues successively until there are no refreshes pending or until new reads or writes are\nissued to the DDRCTRL.\nFor performance only.\nUnit: Multiples of 32 DFI clocks.\nProgramming mode: Dynamic - Refresh Related\n"
              },
              {
                "range": "11:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8:4",
                "field": "REFRESH_BURST[4:0]",
                "description": "The programmed value + 1 is the number of refresh timeouts that is\nallowed to accumulate before traffic is blocked and the refreshes are forced to execute. Closing\npages to perform a refresh is a one-time penalty that must be paid for each group of refreshes.\nTherefore, performing refreshes in a burst reduces the per-refresh penalty of these page\nclosings. Higher numbers for RFSHCTL.refresh_burst slightly increases utilization; lower\nnumbers decreases the worst-case latency associated with refreshes.\n- 0 - single refresh\n- 1 - burst-of-2 refresh\n- 7 - burst-of-8 refresh\nFor information on burst refresh feature refer to section 3.9 of DDR2 JEDEC specification -\nJESD79-2F.pdf.\nFor DDR2/3, the refresh is always per-rank and not per-bank. The rank refresh can be\naccumulated over 8*tREFI cycles using the burst refresh feature.\nIn DDR4 mode, according to Fine Granularity feature, 8 refreshes can be postponed in 1X\nmode, 16 refreshes in 2X mode and 32 refreshes in 4X mode. If using PHY-initiated updates,\ncare must be taken in the setting of RFSHCTL0.refresh_burst, to ensure that tRFCmax is not\nviolated due to a PHY-initiated update occurring shortly before a refresh burst was due. In this\nsituation, the refresh burst is delayed until the PHY-initiated update is complete.\nProgramming mode: dynamic - refresh related\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "PER_BANK_REFRESH",
                "description": "\n- 1 - Per bank refresh;\n- 0 - All bank refresh.\nPer bank refresh allows traffic to flow to other banks. Per bank refresh is not supported by all\nLPDDR2 devices but should be supported by all LPDDR3/LPDDR4 devices. Present only in\ndesigns configured to support LPDDR2/LPDDR3/LPDDR4\nProgramming mode: Static\n"
              },
              {
                "range": "1:0",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 231/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_RFSHCTL3",
            "offset": "0x060",
            "page": 232,
            "chapter": "5.7.12",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "REFRESH_UPDATE_LEVEL",
                "description": "Toggles this signal (either from 0 to 1 or from 1 to 0) to indicate\nthat the refresh register(s) have been updated.\nrefresh_update_level must not be toggled when the DDRC is in reset (core_ddrc_rstn = 0).\nThe refresh register(s) are automatically updated when exiting reset.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "0",
                "field": "DIS_AUTO_REFRESH",
                "description": "When '1', disable auto-refresh generated by the DDRCTRL. When\nauto-refresh is disabled, the SoC core must generate refreshes using the registers\nDBGCMD.rankn_refresh.\nWhen dis_auto_refresh transitions from 0 to 1, any pending refreshes are immediately\nscheduled by the DDRCTRL.\nIf DDR4 CRC/parity retry is enabled (CRCPARCTL1.crc_parity_retry_enable = 1), disable auto-\nrefresh is not supported, and this bit must be set to '0'.\n(DDR4 only) If FGR mode is enabled (RFSHCTL3.refresh_mode > 0), disable auto-refresh is\nnot supported, and this bit must be set to '0'.\nThis register field is changeable on the fly.\nProgramming mode: Dynamic - Refresh Related\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_RFSHTMG",
            "offset": "0x064",
            "page": 233,
            "chapter": "5.7.13",
            "resetvalue": "0x0062008c",
            "bits": [
              {
                "range": "31",
                "field": "T_RFC_NOM_X1_SEL",
                "description": "Specifies whether the t_rfc_nom_x1_x32 register value is x1 or x32.\nProgramming mode: Dynamic - Refresh Related\n"
              },
              {
                "range": "30:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27:16",
                "field": "T_RFC_NOM_X1_X32[11:0]",
                "description": "tREFI: Average time interval between refreshes per rank\n(Specification: 7.8us for DDR2, DDR3 and DDR4. See JEDEC specification for mDDR,\nLPDDR2, LPDDR3 and LPDDR4).\nFor LPDDR2/LPDDR3/LPDDR4:\n- If using all-bank refreshes (RFSHCTL0.per_bank_refresh = 0), this register should be set to\ntREFIab\n- If using per-bank refreshes (RFSHCTL0.per_bank_refresh = 1), this register should be set to\ntREFIpb\nWhen the controller is operating in 1:2 frequency ratio mode, program this to (tREFI/2), no\nrounding up.\nIn DDR4 mode, tREFI value is different depending on the refresh mode. The user should\nprogram the appropriate value from the spec based on the value programmed in the refresh\nmode register.\nNote that if RFSHTMG.t_rfc_nom_x1_sel == 1, RFSHTMG.t_rfc_nom_x1_x32 must be greater\nthan RFSHTMG.t_rfc_min; if RFSHTMG.t_rfc_nom_x1_sel == 0, RFSHTMG.t_rfc_nom_x1_x32\n* 32 must be greater than RFSHTMG.t_rfc_min; RFSHTMG.t_rfc_nom_x1_x32 must be greater\nthan 0x1.\n- Non-DDR4 or DDR4 Fixed 1x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or\nequal to 0xFFE.\n- DDR4 Fixed 2x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x7FF.\n- DDR4 Fixed 4x mode: RFSHTMG.t_rfc_nom_x1_x32 must be less than or equal to 0x3FF.\nUnit: Clocks or multiples of 32 clocks, depending on RFSHTMG.t_rfc_nom_x1_sel.\nProgramming mode: Dynamic - Refresh Related\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "15",
                "field": "LPDDR3_TREFBW_EN",
                "description": "Used only when LPDDR3 memory type is connected. Should only be\nchanged when DDRCTRL is in reset. Specifies whether to use the tREFBW parameter\n(required by some LPDDR3 devices which comply with earlier versions of the LPDDR3 JEDEC\nspecification) or not:\n- 0 - tREFBW parameter not used\n- 1 - tREFBW parameter used\nProgramming mode: Static\n"
              },
              {
                "range": "14:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9:0",
                "field": "T_RFC_MIN[9:0]",
                "description": "tRFC (min): Minimum time from refresh to refresh or activate.\nWhen the controller is operating in 1:1 mode, t_rfc_min should be set to\nRoundUp(tRFCmin/tCK).\nWhen the controller is operating in 1:2 mode, t_rfc_min should be set to\nRoundUp(RoundUp(tRFCmin/tCK)/2).\nIn LPDDR2/LPDDR3/LPDDR4 mode:\n- If using all-bank refreshes, the tRFCmin value in the above equations is equal to tRFCab\n- If using per-bank refreshes, the tRFCmin value in the above equations is equal to tRFCpb\nIn DDR4 mode, the tRFCmin value in the above equations is different depending on the refresh\nmode (fixed 1X,2X,4X) and the device density. The user should program the appropriate value\nfrom the spec based on the 'refresh_mode' and the device density that is used.\nUnit: Clocks.\nProgramming mode: Dynamic - Refresh Related\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_CRCPARCTL0",
            "offset": "0x0C0",
            "page": 234,
            "chapter": "5.7.14",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "DFI_ALERT_ERR_CNT_CLR",
                "description": "DFI alert error count clear. Clear bit for DFI alert error counter.\nAsserting this bit, clears the DFI alert error counter, CRCPARSTAT.dfi_alert_err_cnt. When the\nclear operation is complete, the DDRCTRL automatically clears this bit.\nProgramming mode: Dynamic\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "1",
                "field": "DFI_ALERT_ERR_INT_CLR",
                "description": "Interrupt clear bit for DFI alert error. If this bit is set, the alert\nerror interrupt on CRCPARSTAT.dfi_alert_err_int is cleared. When the clear operation is\ncomplete, the DDRCTRL automatically clears this bit.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "0",
                "field": "DFI_ALERT_ERR_INT_EN",
                "description": "Interrupt enable bit for DFI alert error. If this bit is set, any\nparity/CRC error detected on the dfi_alert_n input results in an interrupt being set on\nCRCPARSTAT.dfi_alert_err_int.\nProgramming mode: Dynamic\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_CRCPARSTAT",
            "offset": "0x0CC",
            "page": 235,
            "chapter": "5.7.15",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "DFI_ALERT_ERR_INT",
                "description": "DFI alert error interrupt.\nIf a parity/CRC error is detected on dfi_alert_n, and the interrupt is enabled by\nCRCPARCTL0.dfi_alert_err_int_en, this interrupt bit is set. It remains set until cleared by\nCRCPARCTL0.dfi_alert_err_int_clr\nProgramming mode: Static\n"
              },
              {
                "range": "15:0",
                "field": "DFI_ALERT_ERR_CNT[15:0]",
                "description": "DFI alert error count.\nIf a parity/CRC error is detected on dfi_alert_n, this counter be incremented. This is\nindependent of the setting of CRCPARCTL0.dfi_alert_err_int_en. It saturates at 0xFFFF, and\ncan be cleared by asserting CRCPARCTL0.dfi_alert_err_cnt_clr.\nProgramming mode: Static\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_INIT0",
            "offset": "0x0D0",
            "page": 236,
            "chapter": "5.7.16",
            "resetvalue": "0x0002004e",
            "bits": [
              {
                "range": "31:30",
                "field": "SKIP_DRAM_INIT[1:0]",
                "description": "If lower bit is enabled the SDRAM initialization routine is skipped. The\nupper bit decides what state the controller starts up in when reset is removed\n- 00 - SDRAM Initialization routine is run after power-up\n- 01 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Normal\nMode\n- 11 - SDRAM Initialization routine is skipped after power-up. Controller starts up in Self-refresh\nMode\n- 10 - Reserved.\nProgramming mode: Quasi-dynamic Group 2\n"
              },
              {
                "range": "29:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:16",
                "field": "POST_CKE_X1024[9:0]",
                "description": "Cycles to wait after driving CKE high to start the SDRAM initialization\nsequence.\nUnit: 1024 DFI clock cycles.\nDDR2 typically requires a 400 ns delay, requiring this value to be programmed to 2 at all clock\nspeeds.\nLPDDR2/LPDDR3 typically requires this to be programmed for a delay of 200 us.\nLPDDR4 typically requires this to be programmed for a delay of 2 us.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec\nvalue divided by 2, and round it up to the next integer value.\nProgramming mode: Static\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:0",
                "field": "PRE_CKE_X1024[11:0]",
                "description": "Cycles to wait after reset before driving CKE high to start the SDRAM\ninitialization sequence.\nUnit: 1024 DFI clock cycles.\nDDR2 specifications typically require this to be programmed for a delay of >= 200 us.\nLPDDR2/LPDDR3: tINIT1 of 100 ns (min)\nLPDDR4: tINIT3 of 2 ms (min)\nWhen the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec\nvalue divided by 2, and round it up to the next integer value.\nFor DDR3/DDR4 RDIMMs, this should include the time needed to satisfy tSTAB\nProgramming mode: Static\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_INIT1",
            "offset": "0x0D4",
            "page": 237,
            "chapter": "5.7.17",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:25",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "24:16",
                "field": "DRAM_RSTN_X1024[8:0]",
                "description": "Number of cycles to assert SDRAM reset signal during init\nsequence.\nThis is only present for designs supporting DDR3, DDR4 or LPDDR4 devices. For use with a\nDDR PHY, this should be set to a minimum of 1.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec\nvalue divided by 2, and round it up to the next integer value.\nUnit: 1024 DFI clock cycles.\nProgramming mode: Static\n"
              },
              {
                "range": "15:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "PRE_OCD_X32[3:0]",
                "description": "Wait period before driving the OCD complete command to SDRAM.\nUnit: Counts of a global timer that pulses every 32 DFI clock cycles.\nThere is no known specific requirement for this; it may be set to zero.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_INIT2",
            "offset": "0x0D8",
            "page": 237,
            "chapter": "5.7.18",
            "resetvalue": "0x00000d05",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "15:8",
                "field": "IDLE_AFTER_RESET_X32[7:0]",
                "description": "Idle time after the reset command, tINIT4. Present only in\ndesigns configured to support LPDDR2.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec\nvalue divided by 2, and round it up to the next integer value.\nUnit: 32 DFI clock cycles.\nProgramming mode: Static\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "MIN_STABLE_CLOCK_X1[3:0]",
                "description": "Time to wait after the first CKE high, tINIT2. Present only in\ndesigns configured to support LPDDR2/LPDDR3.\nLPDDR2/LPDDR3 typically requires 5 x tCK delay.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec\nvalue divided by 2, and round it up to the next integer value.\nUnit: DFI clock cycles.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_INIT3",
            "offset": "0x0DC",
            "page": 238,
            "chapter": "5.7.19",
            "resetvalue": "0x00000510",
            "bits": [
              {
                "range": "31:16",
                "field": "MR[15:0]",
                "description": "DDR2: Value to write to MR register. Bit 8 is for DLL and the setting here is ignored.\nThe DDRCTRL sets this bit appropriately.\nDDR3/DDR4: Value loaded into MR0 register.\nmDDR: Value to write to MR register.\nLPDDR2/LPDDR3/LPDDR4 - Value to write to MR1 register\nProgramming mode: Quasi-dynamic Group 1 and Group 4\n"
              },
              {
                "range": "15:0",
                "field": "EMR[15:0]",
                "description": "DDR2: Value to write to EMR register. Bits 9:7 are for OCD and the setting in this\nregister is ignored. The DDRCTRL sets those bits appropriately.\nDDR3/DDR4: Value to write to MR1 register Set bit 7 to 0. If PHY-evaluation mode training is\nenabled, this bit is set appropriately by the DDRCTRL during write leveling.\nmDDR: Value to write to EMR register.\nLPDDR2/LPDDR3/LPDDR4 - Value to write to MR2 register\nProgramming mode: Quasi-dynamic Group 4\n238/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_INIT4",
            "offset": "0x0E0",
            "page": 239,
            "chapter": "5.7.20",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "EMR2[15:0]",
                "description": "DDR2: Value to write to EMR2 register.\nDDR3/DDR4: Value to write to MR2 register\nLPDDR2/LPDDR3/LPDDR4: Value to write to MR3 register\nmDDR: Unused\nProgramming mode: Quasi-dynamic Group 4\n"
              },
              {
                "range": "15:0",
                "field": "EMR3[15:0]",
                "description": "DDR2: Value to write to EMR3 register.\nDDR3/DDR4: Value to write to MR3 register\nmDDR/LPDDR2/LPDDR3: Unused\nLPDDR4: Value to write to MR13 register\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_INIT5",
            "offset": "0x0E4",
            "page": 239,
            "chapter": "5.7.21",
            "resetvalue": "0x00100004",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:16",
                "field": "DEV_ZQINIT_X32[7:0]",
                "description": "ZQ initial calibration, tZQINIT. Present only in designs configured to\nsupport DDR3 or DDR4 or LPDDR2/LPDDR3.\nDDR3 typically requires 512 SDRAM clock cycles.\nDDR4 requires 1024 SDRAM clock cycles.\nLPDDR2/LPDDR3 requires 1 us.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to JEDEC spec\nvalue divided by 2, and round it up to the next integer value.\nUnit: 32 DFI clock cycles.\nProgramming mode: Static\n"
              },
              {
                "range": "15:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 239/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "9:0",
                "field": "MAX_AUTO_INIT_X1024[9:0]",
                "description": "Maximum duration of the auto initialization, tINIT5. Present\nonly in designs configured to support LPDDR2/LPDDR3.\nLPDDR2/LPDDR3 typically requires 10 us.\nUnit: 1024 DFI clock cycles.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DIMMCTL",
            "offset": "0x0F0",
            "page": 240,
            "chapter": "5.7.22",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "DIMM_ADDR_MIRR_EN",
                "description": "Address Mirroring Enable (for multi-rank UDIMM implementations\nand multi-rank DDR4 RDIMM/LRDIMM implementations).\nSome UDIMMs and DDR4 RDIMMs/LRDIMMs implement address mirroring for odd ranks,\nwhich means that the following address, bank address and bank group bits are swapped: (A3,\nA4), (A5, A6), (A7, A8), (BA0, BA1) and also (A11, A13), (BG0, BG1) for the DDR4. Setting this\nbit ensures that, for mode register accesses during the automatic initialization routine, these\nbits are swapped within the DDRCTRL to compensate for this UDIMM/RDIMM/LRDIMM\nswapping. In addition to the automatic initialization routine, in case of DDR4\nUDIMM/RDIMM/LRDIMM, they are swapped during the automatic MRS access to\nenable/disable of a particular DDR4 feature.\nNote: This has no effect on the address of any other memory accesses, or of software-driven\nmode register accesses.\nThis is not supported for mDDR, LPDDR2, LPDDR3 or LPDDR4 SDRAMs.\nNote: In case of x16 DDR4 DIMMs, BG1 output of MRS for the odd ranks is same as BG0\nbecause BG1 is invalid, hence dimm_dis_bg_mirroring register must be set to 1.\n- 1 - For odd ranks, implement address mirroring for MRS commands to during initialization\nand for any automatic DDR4 MRS commands (to be used if UDIMM/RDIMM/LRDIMM\nimplements address mirroring)\n- 0 - Do not implement address mirroring\nProgramming mode: Static\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "0",
                "field": "DIMM_STAGGER_CS_EN",
                "description": "Staggering enable for multi-rank accesses (for multi-rank UDIMM,\nRDIMM and LRDIMM implementations only). This is not supported for mDDR, LPDDR2,\nLPDDR3 or LPDDR4 SDRAMs.\nNote: Even if this bit is set it does not take care of software driven MR commands (via\nMRCTRL0/MRCTRL1), where software is responsible to send them to separate ranks as\nappropriate.\n- 1 - (DDR4) Send MRS commands to each ranks separately\n- 1 - (non-DDR4) Send all commands to even and odd ranks separately\n- 0 - Do not stagger accesses\nProgramming mode: Static.\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG0",
            "offset": "0x100",
            "page": 241,
            "chapter": "5.7.23",
            "resetvalue": "0x0f101b0f",
            "bits": [
              {
                "range": "31",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "30:24",
                "field": "WR2PRE[6:0]",
                "description": "\nMinimum time between write and precharge to same bank.\nUnit: Clocks\nSpecifications: WL + BL/2 + tWR = approximately 8 cycles + 15 ns = 14 clocks @400MHz and\nless for lower frequencies\nwhere:\n- WL = write latency\n- BL = burst length. This must match the value programmed in the BL bit of the mode register\nto the SDRAM. BST (burst terminate) is not supported at present.\n- tWR = Write recovery time. This comes directly from the SDRAM specification.\nAdd one extra cycle for LPDDR2/LPDDR3/LPDDR4 for this parameter.\nWhen the controller is operating in 1:2 frequency ratio mode, 1T mode, divide the above value\nby 2. No rounding up.\nWhen the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode,\ndivide the above value by 2 and round it up to the next integer value.\nNote that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of\nthis parameter to compensate for the extra cycle of latency through the LRDIMM.\nProgramming mode: Quasi-dynamic Group 1 and Group 2 and Group 4.\n"
              },
              {
                "range": "23:22",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 241/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "21:16",
                "field": "T_FAW[5:0]",
                "description": "tFAW Valid only when 8 or more banks(or banks x bank groups) are present.\nIn 8-bank design, at most 4 banks must be activated in a rolling window of tFAW cycles.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to (tFAW/2) and\nround up to next integer value.\nIn a 4-bank design, set this register to 0x1 independent of the 1:1/1:2 frequency mode.\nUnit: Clocks\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\n"
              },
              {
                "range": "15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14:8",
                "field": "T_RAS_MAX[6:0]",
                "description": "tRAS(max): Maximum time between activate and precharge to same bank.\nThis is the maximum time that a page can be kept open\nMinimum value of this register is 1. Zero is invalid.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to (tRAS(max)-1)/2.\nNo rounding up.\nUnit: Multiples of 1024 clocks.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5:0",
                "field": "T_RAS_MIN[5:0]",
                "description": "tRAS(min): Minimum time between activate and precharge to the same\nbank.\nWhen the controller is operating in 1:2 frequency mode, 1T mode, program this to tRAS(min)/2.\nNo rounding up.\nWhen the controller is operating in 1:2 frequency ratio mode, 2T mode or LPDDR4 mode,\nprogram this to (tRAS(min)/2) and round it up to the next integer value.\nUnit: Clocks.\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG1",
            "offset": "0x104",
            "page": 242,
            "chapter": "5.7.24",
            "resetvalue": "0x00080414",
            "bits": [
              {
                "range": "31:21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20:16",
                "field": "T_XP[4:0]",
                "description": "tXP: Minimum time after power-down exit to any operation. For DDR3, this should\nbe programmed to tXPDLL if slow powerdown exit is selected in MR0[12].\nIf C/A parity for DDR4 is used, set to (tXP+PL) instead.\nIf LPDDR4 is selected and its spec has tCKELPD parameter, set to the larger of tXP and\ntCKELPD instead.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to (tXP/2) and round\nit up to the next integer value.\nUnits: Clocks.\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\n242/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "15:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13:8",
                "field": "RD2PRE[5:0]",
                "description": "tRTP: Minimum time from read to precharge of same bank.\n- DDR2: tAL + BL/2 + max(tRTP, 2) - 2\n- DDR3: tAL + max (tRTP, 4)\n- DDR4: Max of following two equations:\ntAL + max (tRTP, 4) or,\nRL + BL/2 - tRP (*).\n- mDDR: BL/2\n- LPDDR2: Depends on if it's LPDDR2-S2 or LPDDR2-S4:\nLPDDR2-S2: BL/2 + tRTP - 1.\nLPDDR2-S4: BL/2 + max(tRTP,2) - 2.\n- LPDDR3: BL/2 + max(tRTP,4) - 4\n- LPDDR4: BL/2 + max(tRTP,8) - 8\n(*) When both DDR4 SDRAM and ST-MRAM are used simultaneously, use SDRAM's tRP\nvalue for calculation.\nWhen the controller is operating in 1:2 mode, 1T mode, divide the above value by 2. No\nrounding up.\nWhen the controller is operating in 1:2 mode, 2T mode or LPDDR4 mode, divide the above\nvalue by 2 and round it up to the next integer value.\nUnit: Clocks.\nProgramming mode: Quasi-dynamic Group 1 and Group 2 and Group 4\n"
              },
              {
                "range": "7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6:0",
                "field": "T_RC[6:0]",
                "description": "tRC: Minimum time between activates to same bank.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to (tRC/2) and round\nup to next integer value.\nUnit: Clocks.\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG2",
            "offset": "0x108",
            "page": 243,
            "chapter": "5.7.25",
            "resetvalue": "0x0305060d",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 243/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "29:24",
                "field": "WRITE_LATENCY[5:0]",
                "description": "Set to WL\nThe time from write command to write data on SDRAM interface. This must be set to WL.\nFor mDDR, it should normally be set to 1.\nNote that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the\nvalue of WL to compensate for the extra cycle of latency through the RDIMM/LRDIMM.\nWhen the controller is operating in 1:2 frequency ratio mode, divide the value calculated using\nthe above equation by 2, and round it up to next integer.\nThis register field is not required for DDR2 and DDR3 (except if MEMC_TRAINING is set), as\nthe DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those\nprotocols.\nUnit: clocks.\nProgramming mode: Quasi-dynamic Group 1 and Group 2 and Group 4.\n"
              },
              {
                "range": "23:22",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "21:16",
                "field": "READ_LATENCY[5:0]",
                "description": "Set to RL\nThe time from read command to read data on SDRAM interface. This must be set to RL.\nNote that, depending on the PHY, if using RDIMM/LRDIMM, it may be necessary to adjust the\nvalue of RL to compensate for the extra cycle of latency through the RDIMM/LRDIMM.\nWhen the controller is operating in 1:2 frequency ratio mode, divide the value calculated using\nthe above equation by 2, and round it up to next integer.\nThis register field is not required for DDR2 and DDR3 (except if MEMC_TRAINING is set), as\nthe DFI read and write latencies defined in DFITMG0 and DFITMG1 are sufficient for those\nprotocols.\nUnit: clocks.\nProgramming mode: Quasi-dynamic Group 1 and Group 2 and Group 4.\n"
              },
              {
                "range": "15:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n244/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "13:8",
                "field": "RD2WR[5:0]",
                "description": "\nDDR2/3/mDDR: RL + BL/2 + 2 - WL\nDDR4: RL + BL/2 + 1 + WR_PREAMBLE - WL\nLPDDR2/LPDDR3: RL + BL/2 + RU(tDQSCKmax/tCK) + 1 - WL\nLPDDR4(DQ ODT is Disabled): RL + BL/2 + RU(tDQSCKmax/tCK) + WR_PREAMBLE +\nRD_POSTAMBLE - WL\nLPDDR4(DQ ODT is Enabled) : RL + BL/2 + RU(tDQSCKmax/tCK) + RD_POSTAMBLE -\nODTLon - RU(tODTon(min)/tCK)\nMinimum time from read command to write command. Include time for bus turnaround and all\nper-bank, per-rank, and global constraints. Please see the relevant PHY databook for details of\nwhat should be included here.\nUnit: Clocks.\nWhere:\n- WL = write latency\n- BL = burst length. This must match the value programmed in the BL bit of the mode register\nto the SDRAM\n- RL = read latency = CAS latency\n- WR_PREAMBLE = write preamble. This is unique to DDR4 and LPDDR4.\n- RD_POSTAMBLE = read postamble. This is unique to LPDDR4.\nFor LPDDR2/LPDDR3/LPDDR4, if derating is enabled (DERATEEN.derate_enable=1), derated\ntDQSCKmax should be used.\nWhen the controller is operating in 1:2 frequency ratio mode, divide the value calculated using\nthe above equation by 2, and round it up to next integer.\nNote that, depending on the PHY, if using LRDIMM, it may be necessary to adjust the value of\nthis parameter to compensate for the extra cycle of latency through the LRDIMM.\nProgramming mode: Quasi-dynamic Group 1 and Group 2 and Group 4\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5:0",
                "field": "WR2RD[5:0]",
                "description": "\nDDR4: CWL + PL + BL/2 + tWTR_L\nLPDDR2/3/4: WL + BL/2 + tWTR + 1\nOthers: CWL + BL/2 + tWTR\nIn DDR4, minimum time from write command to read command for same bank group. In others,\nminimum time from write command to read command. Includes time for bus turnaround,\nrecovery times, and all per-bank, per-rank, and global constraints.\nUnit: Clocks.\nWhere:\n- CWL = CAS write latency\n- WL = Write latency\n- PL = Parity latency\n- BL = burst length. This must match the value programmed in the BL bit of the mode register\nto the SDRAM\n- tWTR_L = internal write to read command delay for same bank group. This comes directly\nfrom the SDRAM specification.\n- tWTR = internal write to read command delay. This comes directly from the SDRAM\nspecification.\nAdd one extra cycle for LPDDR2/LPDDR3/LPDDR4 operation.\nWhen the controller is operating in 1:2 mode, divide the value calculated using the above\nequation by 2, and round it up to next integer.\nProgramming mode: Quasi-dynamic Group 1 and Group 2 and Group 4\nRM0436 Rev 7 245/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG3",
            "offset": "0x10C",
            "page": 246,
            "chapter": "5.7.26",
            "resetvalue": "0x0050400c",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:20",
                "field": "T_MRW[9:0]",
                "description": "Time to wait after a mode register write or read (MRW or MRR).\nPresent only in designs configured to support LPDDR2, LPDDR3 or LPDDR4.\nLPDDR2 typically requires value of 5.\nLPDDR3 typically requires value of 10.\nLPDDR4: Set this to the larger of tMRW and tMRWCKEL.\nFor LPDDR2, this register is used for the time from a MRW/MRR to all other commands.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to the above values\ndivided by 2 and round it up to the next integer value.\nFor LDPDR3, this register is used for the time from a MRW/MRR to a MRW/MRR.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "19:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17:12",
                "field": "T_MRD[5:0]",
                "description": "tMRD: Cycles to wait after a mode register write or read. Depending on the\nconnected SDRAM, tMRD represents:\nDDR2/mDDR: Time from MRS to any command\nDDR3/4: Time from MRS to MRS command\nLPDDR2: not used\nLPDDR3/4: Time from MRS to non-MRS command.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to (tMRD/2) and\nround it up to the next integer value.\nIf C/A parity for DDR4 is used, set to tMRD_PAR(tMOD+PL) instead.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "11:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n246/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "9:0",
                "field": "T_MOD[9:0]",
                "description": "tMOD: Parameter used only in DDR3 and DDR4. Cycles between load mode\ncommand and following non-load mode command.\nIf C/A parity for DDR4 is used, set to tMOD_PAR(tMOD+PL) instead.\nIf MPR writes for DDR4 are used, set to tMOD + AL (or tMPD_PAR + AL if C/A parity is also\nused).\nSet to tMOD if controller is operating in 1:1 frequency ratio mode, or tMOD/2 (rounded up to\nnext integer) if controller is operating in 1:2 frequency ratio mode. Note that if using\nRDIMM/LRDIMM, depending on the PHY, it may be necessary to adjust the value of this\nparameter to compensate for the extra cycle of latency applied to mode register writes by the\nRDIMM/LRDIMM chip.\nAlso note that if using LRDIMM, the minimum value of this register is tMRD_L2 if controller is\noperating in 1:1 frequency ratio mode, or tMRD_L2/2 (rounded up to next integer) if controller is\noperating in 1:2 frequency ratio mode.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG4",
            "offset": "0x110",
            "page": 247,
            "chapter": "5.7.27",
            "resetvalue": "0x05040405",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:24",
                "field": "T_RCD[4:0]",
                "description": "tRCD - tAL: Minimum time from activate to read or write command to same bank.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to ((tRCD - tAL)/2)\nand round it up to the next integer value.\nMinimum value allowed for this register is 1, which implies minimum (tRCD - tAL) value to be 2\nwhen the controller is operating in 1:2 frequency ratio mode.\nUnit: Clocks.\nProgramming mode: Quasi-dynamic Group 1 and Group 2 and Group 4\n"
              },
              {
                "range": "23:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:16",
                "field": "T_CCD[3:0]",
                "description": "DDR4: tCCD_L: This is the minimum time between two reads or two writes for\nsame bank group.\nOthers: tCCD: This is the minimum time between two reads or two writes.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to (tCCD_L/2 or\ntCCD/2) and round it up to the next integer value.\nUnit: clocks.\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 247/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "11:8",
                "field": "T_RRD[3:0]",
                "description": "DDR4: tRRD_L: Minimum time between activates from bank \"a\" to bank \"b\" for\nsame bank group.\nOthers: tRRD: Minimum time between activates from bank \"a\" to bank \"b\"\nWhen the controller is operating in 1:2 frequency ratio mode, program this to (tRRD_L/2 or\ntRRD/2) and round it up to the next integer value.\nUnit: Clocks.\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "T_RP[4:0]",
                "description": "tRP: Minimum time from precharge to activate of same bank.\nWhen the controller is operating in 1:1 frequency ratio mode, t_rp should be set to\nRoundUp(tRP/tCK).\nWhen the controller is operating in 1:2 frequency ratio mode, t_rp should be set to\nRoundDown(RoundUp(tRP/tCK)/2) + 1.\nWhen the controller is operating in 1:2 frequency ratio mode in LPDDR4, t_rp should be set\nto RoundUp(RoundUp(tRP/tCK)/2).\nUnit: Clocks.\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG5",
            "offset": "0x114",
            "page": 248,
            "chapter": "5.7.28",
            "resetvalue": "0x05050403",
            "bits": [
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27:24",
                "field": "T_CKSRX[3:0]",
                "description": "This is the time before Self Refresh Exit that CK is maintained as a valid clock\nbefore issuing SRX. Specifies the clock stable time before SRX.\nRecommended settings:\n- mDDR: 1\n- LPDDR2: 2\n- LPDDR3: 2\n- LPDDR4: tCKCKEH\n- DDR2: 1\n- DDR3: tCKSRX\n- DDR4: tCKSRX\nWhen the controller is operating in 1:2 frequency ratio mode, program this to recommended\nvalue divided by two and round it up to next integer.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "23:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n248/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "19:16",
                "field": "T_CKSRE[3:0]",
                "description": "This is the time after Self Refresh Down Entry that CK is maintained as a valid\nclock. Specifies the clock disable delay after SRE.\nRecommended settings:\n- mDDR: 0\n- LPDDR2: 2\n- LPDDR3: 2\n- LPDDR4: tCKELCK\n- DDR2: 1\n- DDR3: max (10 ns, 5 tCK)\n- DDR4: max (10 ns, 5 tCK) (+ PL(parity latency)(*))\n(*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by\nPL.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to recommended\nvalue divided by two and round it up to next integer.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "15:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13:8",
                "field": "T_CKESR[5:0]",
                "description": "Minimum CKE low width for Self refresh or Self refresh power down entry to\nexit timing in memory clock cycles.\nRecommended settings:\n- mDDR: tRFC\n- LPDDR2: tCKESR\n- LPDDR3: tCKESR\n- LPDDR4: max(tCKE, tSR)\n- DDR2: tCKE\n- DDR3: tCKE + 1\n- DDR4: tCKE + 1 (+ PL(parity latency)(*))\n(*)Only if CRCPARCTL1.caparity_disable_before_sr=0, this register should be increased by\nPL.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to recommended\nvalue divided by two and round it up to next integer.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "T_CKE[4:0]",
                "description": "Minimum number of cycles of CKE HIGH/LOW during power-down and self\nrefresh.\n- LPDDR2/LPDDR3 mode: Set this to the larger of tCKE or tCKESR\n- LPDDR4 mode: Set this to the larger of tCKE or tSR.\n- Non-LPDDR2/non-LPDDR3/non-LPDDR4 designs: Set this to tCKE value.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to (value described\nabove)/2 and round it up to the next integer value.\nUnit: Clocks.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\nRM0436 Rev 7 249/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG6",
            "offset": "0x118",
            "page": 250,
            "chapter": "5.7.29",
            "resetvalue": "0x02020005",
            "bits": [
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27:24",
                "field": "T_CKDPDE[3:0]",
                "description": "This is the time after Deep Power Down Entry that CK is maintained as a\nvalid clock. Specifies the clock disable delay after DPDE.\nRecommended settings:\n- mDDR: 0\n- LPDDR2: 2\n- LPDDR3: 2\nWhen the controller is operating in 1:2 frequency ratio mode, program this to recommended\nvalue divided by two and round it up to next integer.\nThis is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "23:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:16",
                "field": "T_CKDPDX[3:0]",
                "description": "This is the time before Deep Power Down Exit that CK is maintained as a\nvalid clock before issuing DPDX. Specifies the clock stable time before DPDX.\nRecommended settings:\n- mDDR: 1\n- LPDDR2: 2\n- LPDDR3: 2\nWhen the controller is operating in 1:2 frequency ratio mode, program this to recommended\nvalue divided by two and round it up to next integer.\nThis is only present for designs supporting mDDR or LPDDR2 devices.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "15:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "T_CKCSX[3:0]",
                "description": "This is the time before Clock Stop Exit that CK is maintained as a valid clock\nbefore issuing Clock Stop Exit. Specifies the clock stable time before next command after Clock\nStop Exit.\nRecommended settings:\n- mDDR: 1\n- LPDDR2: tXP + 2\n- LPDDR3: tXP + 2\n- LPDDR4: tXP + 2\nWhen the controller is operating in 1:2 frequency ratio mode, program this to recommended\nvalue divided by two and round it up to next integer.\nThis is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n250/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG7",
            "offset": "0x11C",
            "page": 251,
            "chapter": "5.7.30",
            "resetvalue": "0x00000202",
            "bits": [
              {
                "range": "31:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "T_CKPDE[3:0]",
                "description": "This is the time after Power Down Entry that CK is maintained as a valid clock.\nSpecifies the clock disable delay after PDE.\nRecommended settings:\n- mDDR: 0\n- LPDDR2: 2\n- LPDDR3: 2\n- LPDDR4: tCKELCK\nWhen using DDR2/3/4 SDRAM, this register should be set to the same value as\nDRAMTMG5.t_cksre.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to recommended\nvalue divided by two and round it up to next integer.\nThis is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "T_CKPDX[3:0]",
                "description": "This is the time before Power Down Exit that CK is maintained as a valid clock\nbefore issuing PDX. Specifies the clock stable time before PDX.\nRecommended settings:\n- mDDR: 0\n- LPDDR2: 2\n- LPDDR3: 2\n- LPDDR4: 2\nWhen using DDR2/3/4 SDRAM, this register should be set to the same value as\nDRAMTMG5.t_cksrx.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to recommended\nvalue divided by two and round it up to next integer.\nThis is only present for designs supporting mDDR or LPDDR2/LPDDR3/LPDDR4 devices.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\nRM0436 Rev 7 251/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG8",
            "offset": "0x120",
            "page": 252,
            "chapter": "5.7.31",
            "resetvalue": "0x00004405",
            "bits": [
              {
                "range": "31:15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14:8",
                "field": "T_XS_DLL_X32[6:0]",
                "description": "tXSDLL: Exit Self Refresh to the commands requiring a locked DLL.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to the above value\ndivided by 2 and round up to next integer value.\nUnit: Multiples of 32 clocks.\nNote: Used only for DDR2, DDR3 and DDR4 SDRAMs.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              },
              {
                "range": "7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6:0",
                "field": "T_XS_X32[6:0]",
                "description": "tXS: Exit Self Refresh to commands not requiring a locked DLL.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to the above value\ndivided by 2 and round up to next integer value.\nUnit: Multiples of 32 clocks.\nNote: Used only for DDR2, DDR3 and DDR4 SDRAMs.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG14",
            "offset": "0x138",
            "page": 252,
            "chapter": "5.7.32",
            "resetvalue": "0x000000a0",
            "bits": [
              {
                "range": "31:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:0",
                "field": "T_XSR[11:0]",
                "description": "tXSR: Exit Self Refresh to any command.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to the above value\ndivided by 2 and round up to next integer value.\nNote: Used only for mDDR/LPDDR2/LPDDR3/LPDDR4 mode.\nProgramming mode: Quasi-dynamic Group 2 and Group 4\n252/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DRAMTMG15",
            "offset": "0x13C",
            "page": 253,
            "chapter": "5.7.33",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "EN_DFI_LP_T_STAB",
                "description": "\n- 1 - Enable using tSTAB when exiting DFI LP. Needs to be set when the PHY is stopping the\nclock during DFI LP to save maximum power.\n- 0 - Disable using tSTAB when exiting DFI LP\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\n"
              },
              {
                "range": "30:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:0",
                "field": "T_STAB_X32[7:0]",
                "description": "tSTAB: Stabilization time.\nIt is required in the following two cases for DDR3/DDR4 RDIMM:\n- When exiting power saving mode, if the clock was stopped, after re-enabling it the clock\nmust be stable for a time specified by tSTAB\n- In the case of input clock frequency change (DDR4)\n- After issuing control words that refers to clock timing (Specification: 6us for DDR3, 5us for\nDDR4).\nWhen the controller is operating in 1:2 frequency ratio mode, program this to recommended\nvalue divided by two and round it up to next integer.\nUnit: Multiples of 32 clock cycles.\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ZQCTL0",
            "offset": "0x180",
            "page": 254,
            "chapter": "5.7.34",
            "resetvalue": "0x02000040",
            "bits": [
              {
                "range": "31",
                "field": "DIS_AUTO_ZQ",
                "description": "\n- 1 - Disable DDRCTRL generation of ZQCS/MPC(ZQ calibration) command. Register\nDBGCMD.zq_calib_short can be used instead to issue ZQ calibration request from APB\nmodule.\n- 0 - Internally generate ZQCS/MPC(ZQ calibration) commands based on\nZQCTL1.t_zq_short_interval_x1024.\nThis is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4\ndevices.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "30",
                "field": "DIS_SRX_ZQCL",
                "description": "\n- 1 - Disable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown\nexit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 or LPDDR4 mode.\n- 0 - Enable issuing of ZQCL/MPC(ZQ calibration) command at Self-Refresh/SR-Powerdown\nexit. Only applicable when run in DDR3 or DDR4 or LPDDR2 or LPDDR3 or LPDDR4 mode.\nThis is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4\ndevices.\nProgramming mode: Quasi-dynamic Group 2 and Group 4.\n"
              },
              {
                "range": "29",
                "field": "ZQ_RESISTOR_SHARED",
                "description": "\n- 1 - Denotes that ZQ resistor is shared between ranks. Means ZQinit/ZQCL/ZQCS/MPC(ZQ\ncalibration) commands are sent to one rank at a time with\ntZQinit/tZQCL/tZQCS/tZQCAL/tZQLAT timing met between commands so that commands to\ndifferent ranks do not overlap.\n- 0 - ZQ resistor is not shared.\nThis is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4\ndevices.\nProgramming mode: Static.\n"
              },
              {
                "range": "28:27",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "26:16",
                "field": "T_ZQ_LONG_NOP[10:0]",
                "description": "tZQoper for DDR3/DDR4, tZQCL for LPDDR2/LPDDR3, tZQCAL for\nLPDDR4: Number of DFI clock cycles of NOP required after a ZQCL (ZQ calibration\nlong)/MPC(ZQ Start) command is issued to SDRAM.\nWhen the controller is operating in 1:2 frequency ratio mode:\nDDR3/DDR4: program this to tZQoper/2 and round it up to the next integer value.\nLPDDR2/LPDDR3: program this to tZQCL/2 and round it up to the next integer value.\nLPDDR4: program this to tZQCAL/2 and round it up to the next integer value.\nThis is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4\ndevices.\nProgramming mode: Static.\n"
              },
              {
                "range": "15:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9:0",
                "field": "T_ZQ_SHORT_NOP[9:0]",
                "description": "tZQCS for DDR3/DD4/LPDDR2/LPDDR3, tZQLAT for LPDDR4:\nNumber of DFI clock cycles of NOP required after a ZQCS (ZQ calibration short)/MPC(ZQ\nLatch) command is issued to SDRAM.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to tZQCS/2 and\nround it up to the next integer value.\nThis is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4\ndevices.\nProgramming mode: Static.\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ZQCTL1",
            "offset": "0x184",
            "page": 255,
            "chapter": "5.7.35",
            "resetvalue": "0x02000100",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:20",
                "field": "T_ZQ_RESET_NOP[9:0]",
                "description": "tZQReset: Number of DFI clock cycles of NOP required after a\nZQReset (ZQ calibration Reset) command is issued to SDRAM.\nWhen the controller is operating in 1:2 frequency ratio mode, program this to tZQReset/2 and\nround it up to the next integer value.\nThis is only present for designs supporting LPDDR2/LPDDR3/LPDDR4 devices.\nProgramming mode: Static.\n"
              },
              {
                "range": "19:0",
                "field": "T_ZQ_SHORT_INTERVAL_X1024[19:0]",
                "description": "Average interval to wait between automatically\nissuing ZQCS (ZQ calibration short)/MPC(ZQ calibration) commands to\nDDR3/DDR4/LPDDR2/LPDDR3/LPDDR4 devices.\nMeaningless, if ZQCTL0.dis_auto_zq=1.\nUnit: 1024 DFI clock cycles.\nThis is only present for designs supporting DDR3/DDR4 or LPDDR2/LPDDR3/LPDDR4\ndevices.\nProgramming mode: Static.\nRM0436 Rev 7 255/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ZQCTL2",
            "offset": "0x188",
            "page": 256,
            "chapter": "5.7.36",
            "resetvalue": "0x00000000",
            "bits": []
          },
          {
            "registername": "DDRCTRL_ZQSTAT",
            "offset": "0x18C",
            "page": 256,
            "chapter": "5.7.37",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "ZQ_RESET",
                "description": "\nSetting this register bit to 1 triggers a ZQ Reset operation. When the ZQ Reset operation is\ncomplete, the DDRCTRL automatically clears this bit. It is recommended NOT to set this\nregister bit if in Init, in Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) or Deep\npower-down operating modes.\nFor Self-Refresh(except LPDDR4) or SR-Powerdown(LPDDR4) it is scheduled after SR(except\nLPDDR4) or SPRD(LPDDR4) has been exited.\nFor Deep power down, it is not scheduled, although ZQSTAT.zq_reset_busy is de-asserted.\nThis is only present for designs supporting LPDDR2/LPDDR3/LPDDR4 devices.\nProgramming mode: Dynamic\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\nYSUB_TESER_QZ\nr\n"
              },
              {
                "range": "31:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "0",
                "field": "ZQ_RESET_BUSY",
                "description": "SoC core may initiate a ZQ Reset operation only if this signal is low. This\nsignal goes high in the clock after the DDRCTRL accepts the ZQ Reset request. It goes low\nwhen the ZQ Reset command is issued to the SDRAM and the associated NOP period is over.\nIt is recommended not to perform ZQ Reset commands when this signal is high.\n- 0 - Indicates that the SoC core can initiate a ZQ Reset operation\n- 1 - Indicates that ZQ Reset operation is in progress\nProgramming mode: Dynamic\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DFITMG0",
            "offset": "0x190",
            "page": 257,
            "chapter": "5.7.38",
            "resetvalue": "0x07020002",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:24",
                "field": "DFI_T_CTRL_DELAY[4:0]",
                "description": "Specifies the number of DFI clock cycles after an assertion or de-\nassertion of the DFI control signals that the control signals at the PHY-DRAM interface reflect\nthe assertion or de-assertion. If the DFI clock and the memory clock are not phase-aligned, this\ntiming parameter should be rounded up to the next integer value. Note that if using\nRDIMM/LRDIMM, it is necessary to increment this parameter by RDIMM's/LRDIMM's extra\ncycle of latency in terms of DFI clock.\nProgramming mode: Quasi-dynamic Group 4\n"
              },
              {
                "range": "23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22:16",
                "field": "DFI_T_RDDATA_EN[6:0]",
                "description": "Time from the assertion of a read command on the DFI interface to\nthe assertion of the dfi_rddata_en signal.\nRefer to PHY specification for correct value.\nThis corresponds to the DFI parameter trddata_en. Note that, depending on the PHY, if using\nRDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of\ntrddata_en. This is to compensate for the extra cycle(s) of latency through the\nRDIMM/LRDIMM.\nUnit: DFI clock cycles or DFI PHY clock cycles, depending on\nDFITMG0.dfi_rddata_use_dfi_phy_clk.\nProgramming mode: Quasi-dynamic Group 1 and Group 4\n"
              },
              {
                "range": "15:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13:8",
                "field": "DFI_TPHY_WRDATA[5:0]",
                "description": "Specifies the number of clock cycles between when dfi_wrdata_en\nis asserted to when the associated write data is driven on the dfi_wrdata signal. This\ncorresponds to the DFI timing parameter tphy_wrdata. Refer to PHY specification for correct\nvalue. Note, max supported value is 8.\nUnit: DFI clock cycles or DFI PHY clock cycles, depending on\nDFITMG0.dfi_wrdata_use_dfi_phy_clk.\nProgramming mode: Quasi-dynamic Group 4\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 257/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "5:0",
                "field": "DFI_TPHY_WRLAT[5:0]",
                "description": "Write latency\nNumber of clocks from the write command to write data enable (dfi_wrdata_en). This\ncorresponds to the DFI timing parameter tphy_wrlat.\nRefer to PHY specification for correct value.Note that, depending on the PHY, if using\nRDIMM/LRDIMM, it may be necessary to use the adjusted value of CL in the calculation of\ntphy_wrlat. This is to compensate for the extra cycle(s) of latency through the\nRDIMM/LRDIMM.\nFor LPDDR4, dfi_tphy_wrlat>60 is not supported.\nUnit: DFI clock cycles or DFI PHY clock cycles, depending on\nDFITMG0.dfi_wrdata_use_dfi_phy_clk.\nProgramming mode: Quasi-dynamic Group 1 and Group 4\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DFITMG1",
            "offset": "0x194",
            "page": 258,
            "chapter": "5.7.39",
            "resetvalue": "0x00000404",
            "bits": [
              {
                "range": "31:21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20:16",
                "field": "DFI_T_WRDATA_DELAY[4:0]",
                "description": "Specifies the number of DFI clock cycles between when the\ndfi_wrdata_en\nsignal is asserted and when the corresponding write data transfer is completed on the DRAM\nbus.\nThis corresponds to the DFI timing parameter twrdata_delay. Refer to PHY specification for\ncorrect value.\nFor DFI 3.0 PHY, set to twrdata_delay, a new timing parameter introduced in DFI 3.0.\nFor DFI 2.1 PHY, set to tphy_wrdata + (delay of DFI write data to the DRAM).\nValue to be programmed is in terms of DFI clocks, not PHY clocks.\nIn FREQ_RATIO=2, divide PHY's value by 2 and round up to next integer.\nIf using DFITMG0.dfi_wrdata_use_dfi_phy_clk=1, add 1 to the value.\nUnit: Clocks\nProgramming mode: Quasi-dynamic Group 4\n"
              },
              {
                "range": "15:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "12:8",
                "field": "DFI_T_DRAM_CLK_DISABLE[4:0]",
                "description": "Specifies the number of DFI clock cycles from the\nassertion of the dfi_dram_clk_disable signal on the DFI until the clock to the DRAM memory\ndevices, at the PHY-DRAM boundary, maintains a low value. If the DFI clock and the memory\nclock are not phase aligned, this timing parameter should be rounded up to the next integer\nvalue.\nProgramming mode: Quasi-dynamic Group 4\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "DFI_T_DRAM_CLK_ENABLE[4:0]",
                "description": "Specifies the number of DFI clock cycles from the de-\nassertion of the dfi_dram_clk_disable signal on the DFI until the first valid rising edge of the\nclock to the DRAM memory devices, at the PHY-DRAM boundary. If the DFI clock and the\nmemory clock are not phase aligned, this timing parameter should be rounded up to the next\ninteger value.\nProgramming mode: Quasi-dynamic Group 4\n5.7.40 DDRCTRL low power configuration register 0\n(DDRCTRL_DFILPCFG0)\nAddress offset: 0x198\nReset value: 0x0700 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. DFI_TLP_RESP[4:0]\nRM0436 Rev 7 259/4054\n318\n]0:3[DPD_PUEKAW_PL_IFD\nRes. Res. Res.\nDPD_NE_PL_IFD\nrw rw rw rw rw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nDFI_LP_WAKEUP_SR[3:0] Res. Res. Res.\nRS_NE_PL_IFD\nDFI_LP_WAKEUP_PD[3:0] Res. Res. Res.\nDP_NE_PL_IFD\nrw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:24",
                "field": "DFI_TLP_RESP[4:0]",
                "description": "Setting in DFI clock cycles for DFI's tlp_resp time.\nSame value is used for both Power Down, Self Refresh, Deep Power Down and Maximum\nPower Saving modes.\nDFI 2.1 specification onwards, recommends using a fixed value of 7 always.\nProgramming mode: Static\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "23:20",
                "field": "DFI_LP_WAKEUP_DPD[3:0]",
                "description": "Value in DFI clock cycles to drive on dfi_lp_wakeup signal when\nDeep Power Down mode is entered.\nDetermines the DFI's tlp_wakeup time:\n- 0x0 - 16 cycles\n- 0x1 - 32 cycles\n- 0x2 - 64 cycles\n- 0x3 - 128 cycles\n- 0x4 - 256 cycles\n- 0x5 - 512 cycles\n- 0x6 - 1024 cycles\n- 0x7 - 2048 cycles\n- 0x8 - 4096 cycles\n- 0x9 - 8192 cycles\n- 0xA - 16384 cycles\n- 0xB - 32768 cycles\n- 0xC - 65536 cycles\n- 0xD - 131072 cycles\n- 0xE - 262144 cycles\n- 0xF - Unlimited\nThis is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.\nProgramming mode: Static.\n"
              },
              {
                "range": "19:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "DFI_LP_EN_DPD",
                "description": "Enables DFI Low-power interface handshaking during Deep Power Down\nEntry/Exit.\n- 0 - Disabled\n- 1 - Enabled\nThis is only present for designs supporting mDDR or LPDDR2/LPDDR3 devices.\nProgramming mode: Static.\n260/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "15:12",
                "field": "DFI_LP_WAKEUP_SR[3:0]",
                "description": "Value in DFI clpck cycles to drive on dfi_lp_wakeup signal when\nSelf Refresh mode is entered.\nDetermines the DFI's tlp_wakeup time:\n- 0x0 - 16 cycles\n- 0x1 - 32 cycles\n- 0x2 - 64 cycles\n- 0x3 - 128 cycles\n- 0x4 - 256 cycles\n- 0x5 - 512 cycles\n- 0x6 - 1024 cycles\n- 0x7 - 2048 cycles\n- 0x8 - 4096 cycles\n- 0x9 - 8192 cycles\n- 0xA - 16384 cycles\n- 0xB - 32768 cycles\n- 0xC - 65536 cycles\n- 0xD - 131072 cycles\n- 0xE - 262144 cycles\n- 0xF - Unlimited\nProgramming mode: Static\n"
              },
              {
                "range": "11:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8",
                "field": "DFI_LP_EN_SR",
                "description": "Enables DFI Low Power interface handshaking during Self Refresh\nEntry/Exit.\n- 0 - Disabled\n- 1 - Enabled\nProgramming mode: Static\n"
              },
              {
                "range": "7:4",
                "field": "DFI_LP_WAKEUP_PD[3:0]",
                "description": "Value in DFI clock cycles to drive on dfi_lp_wakeup signal when\nPower Down mode is entered.\nDetermines the DFI's tlp_wakeup time:\n- 0x0 - 16 cycles\n- 0x1 - 32 cycles\n- 0x2 - 64 cycles\n- 0x3 - 128 cycles\n- 0x4 - 256 cycles\n- 0x5 - 512 cycles\n- 0x6 - 1024 cycles\n- 0x7 - 2048 cycles\n- 0x8 - 4096 cycles\n- 0x9 - 8192 cycles\n- 0xA - 16384 cycles\n- 0xB - 32768 cycles\n- 0xC - 65536 cycles\n- 0xD - 131072 cycles\n- 0xE - 262144 cycles\n- 0xF - Unlimited\nProgramming mode: Static\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 261/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "0",
                "field": "DFI_LP_EN_PD",
                "description": "Enables DFI Low Power interface handshaking during Power Down\nEntry/Exit.\n- 0 - Disabled\n- 1 - Enabled\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DFIUPD0",
            "offset": "0x1A0",
            "page": 262,
            "chapter": "5.7.41",
            "resetvalue": "0x00400003",
            "bits": [
              {
                "range": "31",
                "field": "DIS_AUTO_CTRLUPD",
                "description": "When '1', disable the automatic dfi_ctrlupd_req generation by the\nDDRCTRL. The core must issue the dfi_ctrlupd_req signal using register DBGCMD.ctrlupd.\nWhen '0', DDRCTRL issues dfi_ctrlupd_req periodically.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "30",
                "field": "DIS_AUTO_CTRLUPD_SRX",
                "description": "When '1', disable the automatic dfi_ctrlupd_req generation by\nthe DDRCTRL at self-refresh exit.\nWhen '0', DDRCTRL issues a dfi_ctrlupd_req before or after exiting self-refresh, depending on\nDFIUPD0.ctrlupd_pre_srx.\nProgramming mode: Static\n"
              },
              {
                "range": "29",
                "field": "CTRLUPD_PRE_SRX",
                "description": "Selects dfi_ctrlupd_req requirements at SRX:\n- 0 : send ctrlupd after SRX\n- 1 : send ctrlupd before SRX\nIf DFIUPD0.dis_auto_ctrlupd_srx=1, this register has no impact, because no dfi_ctrlupd_req is\nissued when SRX.\nProgramming mode: Static\n"
              },
              {
                "range": "28:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:16",
                "field": "DFI_T_CTRLUP_MAX[9:0]",
                "description": "Specifies the maximum number of DFI clock cycles that the\ndfi_ctrlupd_req signal can assert. Lowest value to assign to this variable is 0x40.\nProgramming mode: Static\n"
              },
              {
                "range": "15:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "9:0",
                "field": "DFI_T_CTRLUP_MIN[9:0]",
                "description": "Specifies the minimum number of DFI clock cycles that the\ndfi_ctrlupd_req signal must be asserted. The DDRCTRL expects the PHY to respond within this\ntime. If the PHY does not respond, the DDRCTRL de-asserts dfi_ctrlupd_req after\ndfi_t_ctrlup_min + 2 cycles. Lowest value to assign to this variable is 0x3.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DFIUPD1",
            "offset": "0x1A4",
            "page": 263,
            "chapter": "5.7.42",
            "resetvalue": "0x00010001",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:16",
                "field": "DFI_T_CTRLUPD_INTERVAL_MIN_X1024[7:0]",
                "description": "This is the minimum amount of time between\nDDRCTRL initiated DFI update requests (which is executed whenever the DDRCTRL is idle).\nSet this number higher to reduce the frequency of update requests, which can have a small\nimpact on the latency of the first read request when the DDRCTRL is idle. Minimum allowed\nvalue for this field is 1.\nUnit: 1024 DFI clock cycles.\nProgramming mode: Static.\n"
              },
              {
                "range": "15:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:0",
                "field": "DFI_T_CTRLUPD_INTERVAL_MAX_X1024[7:0]",
                "description": "This is the maximum amount of time\nbetween DDRCTRL initiated DFI update requests. This timer resets with each update request;\nwhen the timer expires dfi_ctrlupd_req is sent and traffic is blocked until the dfi_ctrlupd_ackx is\nreceived. PHY can use this idle time to recalibrate the delay lines to the DLLs. The DFI\ncontroller update is also used to reset PHY FIFO pointers in case of data capture errors.\nUpdates are required to maintain calibration over PVT, but frequent updates may impact\nperformance. Minimum allowed value for this field is 1.\nNote: Value programmed for DFIUPD1.dfi_t_ctrlupd_interval_max_x1024 must be greater than\nDFIUPD1.dfi_t_ctrlupd_interval_min_x1024.\nUnit: 1024 DFI clock cycles.\nProgramming mode: Static.\nRM0436 Rev 7 263/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DFIUPD2",
            "offset": "0x1A8",
            "page": 264,
            "chapter": "5.7.43",
            "resetvalue": "0x80000000",
            "bits": []
          },
          {
            "registername": "DDRCTRL_DFIMISC",
            "offset": "0x1B0",
            "page": 264,
            "chapter": "5.7.44",
            "resetvalue": "0x00000001",
            "bits": [
              {
                "range": "31",
                "field": "DFI_PHYUPD_EN",
                "description": "Enables the support for acknowledging PHY-initiated updates:\n- 0 - Disabled\n- 1 - Enabled\nProgramming mode: Static\n"
              },
              {
                "range": "30:0",
                "field": "Reserved",
                "description": "must be kept at reset value.\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. DFI_FREQUENCY[4:0] Res. Res.\nTRATS_TINI_IFD\nNE_ELDI_LTC\nRes. Res. Res.\nNE_ETELPMOC_TINI_IFD\nrw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12:8",
                "field": "DFI_FREQUENCY[4:0]",
                "description": "Indicates the operating frequency of the system. The number of\nsupported frequencies and the mapping of signal values to clock frequencies are defined by the\nPHY.\nProgramming mode: Quasi-dynamic Group 1\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "5",
                "field": "DFI_INIT_START",
                "description": "PHY init start request signal.When asserted it triggers the PHY init start\nrequest\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "4",
                "field": "CTL_IDLE_EN",
                "description": "Enables support of ctl_idle signal\nProgramming mode: Static\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "DFI_INIT_COMPLETE_EN",
                "description": "PHY initialization complete enable signal.\nWhen asserted the dfi_init_complete signal can be used to trigger SDRAM initialisation\nProgramming mode: Quasi-dynamic Group 3\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DFISTAT",
            "offset": "0x1BC",
            "page": 265,
            "chapter": "5.7.45",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "DFI_LP_ACK",
                "description": "Stores the value of the dfi_lp_ack input to the controller.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "0",
                "field": "DFI_INIT_COMPLETE",
                "description": "The status flag register which announces when the DFI initialization\nhas been completed. The DFI INIT triggered by dfi_init_start signal and then the\ndfi_init_complete flag is polled to know when the initialization is done.\nProgramming mode: Dynamic\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DFIPHYMSTR",
            "offset": "0x1C4",
            "page": 266,
            "chapter": "5.7.46",
            "resetvalue": "0x00000001",
            "bits": []
          },
          {
            "registername": "DDRCTRL_ADDRMAP1",
            "offset": "0x204",
            "page": 266,
            "chapter": "5.7.47",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "DFI_PHYMSTR_EN",
                "description": "Enables the PHY Master Interface:\n- 0 - Disabled\n- 1 - Enabled\nProgramming mode: Dynamic\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. ADDRMAP_BANK_B2[5:0]\nrw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. ADDRMAP_BANK_B1[5:0] Res. Res. ADDRMAP_BANK_B0[5:0]\nrw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:22",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "21:16",
                "field": "ADDRMAP_BANK_B2[5:0]",
                "description": "Selects the HIF address bit used as bank address bit 2.\nValid Range: 0 to 31, and 63\nInternal Base: 4\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIf unused, set to 63 and then bank address bit 2 is set to 0.\nProgramming mode: Static.\n"
              },
              {
                "range": "15:14",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "13:8",
                "field": "ADDRMAP_BANK_B1[5:0]",
                "description": "Selects the HIF address bits used as bank address bit 1.\nValid Range: 0 to 32, and 63\nInternal Base: 3\nThe selected HIF address bit for each of the bank address bits is determined by adding the\ninternal base to the value of this field.\nIf unused, set to 63 and then bank address bit 1 is set to 0.\nProgramming mode: Static.\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5:0",
                "field": "ADDRMAP_BANK_B0[5:0]",
                "description": "Selects the HIF address bits used as bank address bit 0.\nValid Range: 0 to 32, and 63\nInternal Base: 2\nThe selected HIF address bit for each of the bank address bits is determined by adding the\ninternal base to the value of this field.\nIf unused, set to 63 and then bank address bit 0 is set to 0.\nProgramming mode: Static.\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ADDRMAP2",
            "offset": "0x208",
            "page": 267,
            "chapter": "5.7.48",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27:24",
                "field": "ADDRMAP_COL_B5[3:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 5.\n- Half bus width mode: Selects the HIF address bit used as column address bit 6.\n- Quarter bus width mode: Selects the HIF address bit used as column address bit 7 .\nValid Range: 0 to 7, and 15\nInternal Base: 5\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIf unused, set to 15 and then this column address bit is set to 0.\nProgramming mode: Static\n"
              },
              {
                "range": "23:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 267/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "19:16",
                "field": "ADDRMAP_COL_B4[3:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 4.\n- Half bus width mode: Selects the HIF address bit used as column address bit 5.\n- Quarter bus width mode: Selects the HIF address bit used as column address bit 6.\nValid Range: 0 to 7, and 15\nInternal Base: 4\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIf unused, set to 15 and then this column address bit is set to 0.\nProgramming mode: Static\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "ADDRMAP_COL_B3[3:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 3.\n- Half bus width mode: Selects the HIF address bit used as column address bit 4.\n- Quarter bus width mode: Selects the HIF address bit used as column address bit 5.\nValid Range: 0 to 7\nInternal Base: 3\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nNote, if UMCTL2_INCL_ARB=1, MEMC_BURST_LENGTH=16, Full bus width\n(MSTR.data_bus_width=00) and BL16 (MSTR.burst_rdwr=1000), it is recommended to\nprogram this to 0.\nProgramming mode: Static\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n268/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "3:0",
                "field": "ADDRMAP_COL_B2[3:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 2.\n- Half bus width mode: Selects the HIF address bit used as column address bit 3.\n- Quarter bus width mode: Selects the HIF address bit used as column address bit 4.\nValid Range: 0 to 7\nInternal Base: 2\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nNote, if UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=8, it is required to program this\nto 0 unless:\n- in Half or Quarter bus width (MSTR.data_bus_width!=00) and\n- PCCFG.bl_exp_mode==1 and either\n- In DDR4 and ADDRMAP8.addrmap_bg_b0==0 or\n- In LPDDR4 and ADDRMAP1.addrmap_bank_b0==0\nIf UMCTL2_INCL_ARB=1 and MEMC_BURST_LENGTH=16, it is required to program this to 0\nunless:\n- in Half or Quarter bus width (MSTR.data_bus_width!=00) and\n- PCCFG.bl_exp_mode==1 and\n- In DDR4 and ADDRMAP8.addrmap_bg_b0==0\nOtherwise, if MEMC_BURST_LENGTH=8 and Full Bus Width (MSTR.data_bus_width==00), it\nis recommended to program this to 0 so that HIF[2] maps to column address bit 2.\nIf MEMC_BURST_LENGTH=16 and Full Bus Width (MSTR.data_bus_width==00), it is\nrecommended to program this to 0 so that HIF[2] maps to column address bit 2.\nIf MEMC_BURST_LENGTH=16 and Half Bus Width (MSTR.data_bus_width==01), it is\nrecommended to program this to 0 so that HIF[2] maps to column address bit 3.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ADDRMAP3",
            "offset": "0x20C",
            "page": 269,
            "chapter": "5.7.49",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 269/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "28:24",
                "field": "ADDRMAP_COL_B9[4:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 9.\n- Half bus width mode: Selects the HIF address bit used as column address bit 11 (10 in\nLPDDR2/LPDDR3 mode).\n- Quarter bus width mode: Selects the HIF address bit used as column address bit 13 (11 in\nLPDDR2/LPDDR3 mode).\nValid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.\nInternal Base: 9\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nNote: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating\nauto-precharge, and hence no source address bit can be mapped to column address bit 10.\nIn LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence\ncolumn bit 10 is used.\nIn Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled\n(ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid\nHIF address bits.\nIf column bit 9 is the highest column address bit, it must map to the highest valid HIF address\nbit. (x = the highest valid HIF address bit - internal base)\nIf column bit 9 is the second highest column address bit, it must map to the second highest\nvalid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)\nIf column bit 9 is the third highest column address bit, it must map to the third highest valid HIF\naddress bit. (x = the highest valid HIF address bit - 2 - internal base)\nIf unused, set to 31 and then this column address bit is set to 0.\nProgramming mode: Static.\n"
              },
              {
                "range": "23:21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20:16",
                "field": "ADDRMAP_COL_B8[4:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 8.\n- Half bus width mode: Selects the HIF address bit used as column address bit 9.\n- Quarter bus width mode: Selects the HIF address bit used as column address bit 11 (10 in\nLPDDR2/LPDDR3 mode).\nValid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.\nInternal Base: 8\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nNote: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating\nauto-precharge, and hence no source address bit can be mapped to column address bit 10.\nIn LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence\ncolumn bit 10 is used.\nIn Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled\n(ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid\nHIF address bits.\nIf column bit 8 is the second highest column address bit, it must map to the second highest\nvalid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base).\nIf column bit 8 is the third highest column address bit, it must map to the third highest valid HIF\naddress bit. (x = the highest valid HIF address bit - 2 - internal base).\nIf unused, set to 31 and then this column address bit is set to 0.\nProgramming mode: Static.\n"
              },
              {
                "range": "15:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n270/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "12:8",
                "field": "ADDRMAP_COL_B7[4:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 7.\n- Half bus width mode: Selects the HIF address bit used as column address bit 8.\n- Quarter bus width mode: Selects the HIF address bit used as column address bit 9.\nValid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.\nInternal Base: 7\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIn Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled\n(ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid\nHIF address bits.\nIf column bit 7 is the third highest column address bit, it must map to the third highest valid HIF\naddress bit. (x = the highest valid HIF address bit - 2 - internal base).\nIf unused, set to 31 and then this column address bit is set to 0.\nProgramming mode: Static.\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "ADDRMAP_COL_B6[3:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 6.\n- Half bus width mode: Selects the HIF address bit used as column address bit 7.\n- Quarter bus width mode: Selects the HIF address bit used as column address bit 8.\nValid Range: 0 to 7, and 15\nInternal Base: 6\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIf unused, set to 15 and then this column address bit is set to 0.\nProgramming mode: Static\nRM0436 Rev 7 271/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ADDRMAP4",
            "offset": "0x210",
            "page": 272,
            "chapter": "5.7.50",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12:8",
                "field": "ADDRMAP_COL_B11[4:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 13 (11 in\nLPDDR2/LPDDR3 mode).\n- Half bus width mode: UNUSED. See later in this description for value you need to set to\nmake it unused.\n- Quarter bus width mode: UNUSED. See later in this description for value you need to set to\nmake it unused.\nValid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.\nInternal Base: 11\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nNote: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating\nauto-precharge, and hence no source address bit can be mapped to column address bit 10.\nIn LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence\ncolumn bit 10 is used.\nIn Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled\n(ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid\nHIF address bits.\nIf column bit 11 is the highest column address bit, it must map to the highest valid HIF address\nbit. (x = the highest valid HIF address bit - internal base)\nIf column bit 11 is the second highest column address bit, it must map to the second highest\nvalid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)\nIf column bit 11 is the third highest column address bit, it must map to the third highest valid\nHIF address bit. (x = the highest valid HIF address bit - 2 - internal base)\nIf unused, set to 31 and then this column address bit is set to 0.\nProgramming mode: Static\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n272/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "4:0",
                "field": "ADDRMAP_COL_B10[4:0]",
                "description": "\n- Full bus width mode: Selects the HIF address bit used as column address bit 11 (10 in\nLPDDR2/LPDDR3 mode).\n- Half bus width mode: Selects the HIF address bit used as column address bit 13 (11 in\nLPDDR2/LPDDR3 mode).\n- Quarter bus width mode: UNUSED. See later in this description for value you need to set to\nmake it unused.\nValid Range: 0 to 7, x, and 31. x indicate a valid value in inline ECC configuration.\nInternal Base: 10\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nNote: Per JEDEC DDR2/3/mDDR specification, column address bit 10 is reserved for indicating\nauto-precharge, and hence no source address bit can be mapped to column address bit 10.\nIn LPDDR2/LPDDR3, there is a dedicated bit for auto-precharge in the CA bus and hence\ncolumn bit 10 is used.\nIn Inline ECC configuration (MEMC_INLINE_ECC=1) and ECC is enabled\n(ECCCFG0.ecc_mode>0), the highest 3 column address bits must map to the highest 3 valid\nHIF address bits.\nIf column bit 10 is the highest column address bit, it must map to the highest valid HIF address\nbit. (x = the highest valid HIF address bit - internal base)\nIf column bit 10 is the second highest column address bit, it must map to the second highest\nvalid HIF address bit. (x = the highest valid HIF address bit - 1 - internal base)\nIf column bit 10 is the third highest column address bit, it must map to the third highest valid\nHIF address bit. (x = the highest valid HIF address bit - 2 - internal base)\nIf unused, set to 31 and then this column address bit is set to 0.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ADDRMAP5",
            "offset": "0x214",
            "page": 273,
            "chapter": "5.7.51",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "27:24",
                "field": "ADDRMAP_ROW_B11[3:0]",
                "description": "Selects the HIF address bit used as row address bit 11.\nValid Range: 0 to 11, and 15\nInternal Base: 17\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIf unused, set to 15 and then row address bit 11 is set to 0.\nProgramming mode: Static\n"
              },
              {
                "range": "23:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:16",
                "field": "ADDRMAP_ROW_B2_10[3:0]",
                "description": "Selects the HIF address bits used as row address bits 2 to 10.\nValid Range: 0 to 11, and 15\nInternal Base: 8 (for row address bit 2), 9 (for row address bit 3), 10 (for row address bit 4) etc\nincreasing to 16 (for row address bit 10)\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field.\nWhen set to 15, the values of row address bits 2 to 10 are defined by registers ADDRMAP9,\nADDRMAP10, ADDRMAP11.\nProgramming mode: Static\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "ADDRMAP_ROW_B1[3:0]",
                "description": "Selects the HIF address bits used as row address bit 1.\nValid Range: 0 to 11\nInternal Base: 7\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field.\nProgramming mode: Static\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "ADDRMAP_ROW_B0[3:0]",
                "description": "Selects the HIF address bits used as row address bit 0.\nValid Range: 0 to 11\nInternal Base: 6\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ADDRMAP6",
            "offset": "0x218",
            "page": 274,
            "chapter": "5.7.52",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "LPDDR3_6GB_12GB",
                "description": "\nSet this to 1 if there is an LPDDR3 SDRAM 6Gb or 12Gb device in use.\n- 1 - LPDDR3 SDRAM 6Gb/12Gb device in use. Every address having row[14:13]==2'b11 is\nconsidered as invalid\n- 0 - non-LPDDR3 6Gb/12Gb device in use. All addresses are valid\nPresent only in designs configured to support LPDDR3.\nProgramming mode: Static\n"
              },
              {
                "range": "30:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27:24",
                "field": "ADDRMAP_ROW_B15[3:0]",
                "description": "Selects the HIF address bit used as row address bit 15.\nValid Range: 0 to 11, and 15\nInternal Base: 21\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIf unused, set to 15 and then row address bit 15 is set to 0.\nProgramming mode: Static\n"
              },
              {
                "range": "23:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:16",
                "field": "ADDRMAP_ROW_B14[3:0]",
                "description": "Selects the HIF address bit used as row address bit 14.\nValid Range: 0 to 11, and 15\nInternal Base: 20\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIf unused, set to 15 and then row address bit 14 is set to 0.\nProgramming mode: Static\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "ADDRMAP_ROW_B13[3:0]",
                "description": "Selects the HIF address bit used as row address bit 13.\nValid Range: 0 to 11, and 15\nInternal Base: 19\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIf unused, set to 15 and then row address bit 13 is set to 0.\nProgramming mode: Static\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "ADDRMAP_ROW_B12[3:0]",
                "description": "Selects the HIF address bit used as row address bit 12.\nValid Range: 0 to 11, and 15\nInternal Base: 18\nThe selected HIF address bit is determined by adding the internal base to the value of this field.\nIf unused, set to 15 and then row address bit 12 is set to 0.\nProgramming mode: Static\nRM0436 Rev 7 275/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ADDRMAP9",
            "offset": "0x224",
            "page": 276,
            "chapter": "5.7.53",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27:24",
                "field": "ADDRMAP_ROW_B5[3:0]",
                "description": "Selects the HIF address bits used as row address bit 5.\nValid Range: 0 to 11\nInternal Base: 11\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field. This register field is used only when\nADDRMAP5.addrmap_row_b2_10 is set to value 15.\nProgramming mode: Static\n"
              },
              {
                "range": "23:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:16",
                "field": "ADDRMAP_ROW_B4[3:0]",
                "description": "Selects the HIF address bits used as row address bit 4.\nValid Range: 0 to 11\nInternal Base: 10\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field. This register field is used only when\nADDRMAP5.addrmap_row_b2_10 is set to value 15.\nProgramming mode: Static\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "ADDRMAP_ROW_B3[3:0]",
                "description": "Selects the HIF address bits used as row address bit 3.\nValid Range: 0 to 11\nInternal Base: 9\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field. This register field is used only when\nADDRMAP5.addrmap_row_b2_10 is set to value 15.\nProgramming mode: Static\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "ADDRMAP_ROW_B2[3:0]",
                "description": "Selects the HIF address bits used as row address bit 2.\nValid Range: 0 to 11\nInternal Base: 8\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field. This register field is used only when\nADDRMAP5.addrmap_row_b2_10 is set to value 15.\nProgramming mode: Static\n276/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ADDRMAP10",
            "offset": "0x228",
            "page": 277,
            "chapter": "5.7.54",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "27:24",
                "field": "ADDRMAP_ROW_B9[3:0]",
                "description": "Selects the HIF address bits used as row address bit 9.\nValid Range: 0 to 11\nInternal Base: 15\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field. This register field is used only when\nADDRMAP5.addrmap_row_b2_10 is set to value 15.\nProgramming mode: Static\n"
              },
              {
                "range": "23:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:16",
                "field": "ADDRMAP_ROW_B8[3:0]",
                "description": "Selects the HIF address bits used as row address bit 8.\nValid Range: 0 to 11\nInternal Base: 14\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field. This register field is used only when\nADDRMAP5.addrmap_row_b2_10 is set to value 15.\nProgramming mode: Static\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "ADDRMAP_ROW_B7[3:0]",
                "description": "Selects the HIF address bits used as row address bit 7.\nValid Range: 0 to 11\nInternal Base: 13\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field. This register field is used only when\nADDRMAP5.addrmap_row_b2_10 is set to value 15.\nProgramming mode: Static\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "ADDRMAP_ROW_B6[3:0]",
                "description": "Selects the HIF address bits used as row address bit 6.\nValid Range: 0 to 11\nInternal Base: 12\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field. This register field is used only when\nADDRMAP5.addrmap_row_b2_10 is set to value 15.\nProgramming mode: Static\nRM0436 Rev 7 277/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ADDRMAP11",
            "offset": "0x22C",
            "page": 278,
            "chapter": "5.7.55",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "ADDRMAP_ROW_B10[3:0]",
                "description": "Selects the HIF address bits used as row address bit 10.\nValid Range: 0 to 11\nInternal Base: 16\nThe selected HIF address bit for each of the row address bits is determined by adding the\ninternal base to the value of this field. This register field is used only when\nADDRMAP5.addrmap_row_b2_10 is set to value 15.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ODTCFG",
            "offset": "0x240",
            "page": 278,
            "chapter": "5.7.56",
            "resetvalue": "0x04000400",
            "bits": [
              {
                "range": "31:28",
                "field": "Reserved",
                "description": "must be kept at reset value.\n278/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "27:24",
                "field": "WR_ODT_HOLD[3:0]",
                "description": "\nDFI PHY clock cycles to hold ODT for a write command. The minimum supported value is 2.\nRecommended values:\nDDR2:\n- BL8: 0x5 (DDR2-400/533/667), 0x6 (DDR2-800), 0x7 (DDR2-1066)\n- BL4: 0x3 (DDR2-400/533/667), 0x4 (DDR2-800), 0x5 (DDR2-1066)\nDDR3:\n- BL8: 0x6\nDDR4:\n- BL8: 5 + WR_PREAMBLE + CRC_MODE\nWR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble)\nCRC_MODE = 0 (not CRC mode), 1 (CRC mode)\nLPDDR3:\n- BL8: 7 + RU(tODTon(max)/tCK)\nProgramming mode: Quasi-dynamic Group 1 and Group 4\n"
              },
              {
                "range": "23:21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20:16",
                "field": "WR_ODT_DELAY[4:0]",
                "description": "\nThe delay, in DFI PHY clock cycles, from issuing a write command to setting ODT values\nassociated with that command. ODT setting must remain constant for the entire time that DQS\nis driven by the DDRCTRL.\nRecommended values:\nDDR2:\n- CWL + AL - 3 (DDR2-400/533/667), CWL + AL - 4 (DDR2-800), CWL + AL - 5 (DDR2-1066)\nIf (CWL + AL - 3 < 0), DDRCTRL does not support ODT for write operation.\nDDR3:\n- 0x0\nDDR4:\n- DFITMG1.dfi_t_cmd_lat (to adjust for CAL mode)\nLPDDR3:\n- WL - 1 - RU(tODTon(max)/tCK))\nProgramming mode: Quasi-dynamic Group 1 and Group 4\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "RD_ODT_HOLD[3:0]",
                "description": "\nDFI PHY clock cycles to hold ODT for a read command. The minimum supported value is 2.\nRecommended values:\nDDR2:\n- BL8: 0x6 (not DDR2-1066), 0x7 (DDR2-1066)\n- BL4: 0x4 (not DDR2-1066), 0x5 (DDR2-1066)\nDDR3:\n- BL8 - 0x6\nDDR4:\n- BL8: 5 + RD_PREAMBLE\nRD_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble)\nLPDDR3:\n- BL8: 5 + RU(tDQSCK(max)/tCK) - RD(tDQSCK(min)/tCK) + RU(tODTon(max)/tCK)\nProgramming mode: Quasi-dynamic Group 1 and Group 4\nRM0436 Rev 7 279/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6:2",
                "field": "RD_ODT_DELAY[4:0]",
                "description": "\nThe delay, in DFI PHY clock cycles, from issuing a read command to setting ODT values\nassociated with that command. ODT setting must remain constant for the entire time that DQS\nis driven by the DDRCTRL.\nRecommended values:\nDDR2:\n- CL + AL - 4 (not DDR2-1066), CL + AL - 5 (DDR2-1066)\nIf (CL + AL - 4 < 0), DDRCTRL does not support ODT for read operation.\nDDR3:\n- CL - CWL\nDDR4:\n- CL - CWL - RD_PREAMBLE + WR_PREAMBLE + DFITMG1.dfi_t_cmd_lat (to adjust for CAL\nmode)\nWR_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble)\nRD_PREAMBLE = 1 (1tCK write preamble), 2 (2tCK write preamble)\nIf (CL - CWL - RD_PREAMBLE + WR_PREAMBLE) < 0, DDRCTRL does not support ODT\nfor read operation.\nLPDDR3:\n- RL + RD(tDQSCK(min)/tCK) - 1 - RU(tODTon(max)/tCK)\nProgramming mode: Quasi-dynamic Group 1 and Group 4.\n"
              },
              {
                "range": "1:0",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_ODTMAP",
            "offset": "0x244",
            "page": 280,
            "chapter": "5.7.57",
            "resetvalue": "0x00000011",
            "bits": [
              {
                "range": "31:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "RANK0_RD_ODT",
                "description": "Indicates which remote ODTs must be turned on during a read from rank 0.\nEach rank has a remote ODT (in the SDRAM) which can be turned on by setting the\nappropriate bit here.\nRank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.\nFor each rank, set its bit to 1 to enable its ODT.\nProgramming mode: Static\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "0",
                "field": "RANK0_WR_ODT",
                "description": "Indicates which remote ODTs must be turned on during a write to rank 0.\nEach rank has a remote ODT (in the SDRAM) which can be turned on by setting the\nappropriate bit here.\nRank 0 is controlled by the LSB; rank 1 is controlled by bit next to the LSB, etc.\nFor each rank, set its bit to 1 to enable its ODT.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_SCHED",
            "offset": "0x250",
            "page": 281,
            "chapter": "5.7.58",
            "resetvalue": "0x00000805",
            "bits": [
              {
                "range": "31",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "30:24",
                "field": "RDWR_IDLE_GAP[6:0]",
                "description": "When the preferred transaction store is empty for these many clock\ncycles, switch to the alternate transaction store if it is non-empty.\nThe read transaction store (both high and low priority) is the default preferred transaction store\nand the write transaction store is the alternative store.\nWhen prefer write over read is set this is reversed.\n0x0 is a legal value for this register. When set to 0x0, the transaction store switching happens\nimmediately when the switching conditions become true.\nFOR PERFORMANCE ONLY\nProgramming mode: Static\n"
              },
              {
                "range": "23:16",
                "field": "GO2CRITICAL_HYSTERESIS[7:0]",
                "description": "UNUSED\nProgramming mode: Static\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "LPR_NUM_ENTRIES[3:0]",
                "description": "Number of entries in the low priority transaction store is this value +\n1.\n(MEMC_NO_OF_ENTRY - (SCHED.lpr_num_entries + 1)) is the number of entries available\nfor the high priority transaction store.\nSetting this to maximum value allocates all entries to low priority transaction store.\nSetting this to 0 allocates 1 entry to low priority transaction store and the rest to high priority\ntransaction store.\nNote: In ECC configurations, the numbers of write and low priority read credits issued is one\nless than in the non-ECC case. One entry each is reserved in the write and low-priority read\nCAMs for storing the RMW requests arising out of single bit error correction RMW operation.\nProgramming mode: Static\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "7:3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "PAGECLOSE",
                "description": "If true, bank is kept open only while there are page hit transactions available in\nthe CAM to that bank. The last read or write command in the CAM with a bank and page hit is\nexecuted with auto-precharge if SCHED1.pageclose_timer=0. Even if this register set to 1 and\nSCHED1.pageclose_timer is set to 0, explicit precharge (and not auto-precharge) may be\nissued in some cases where there is a mode switch between write and read or between LPR\nand HPR. The Read and Write commands that are executed as part of the ECC scrub requests\nare also executed without auto-precharge.\nIf false, the bank remains open until there is a need to close it (to open a different page, or for\npage timeout or refresh timeout) - also known as open page policy. The open page policy can\nbe overridden by setting the per-command-autopre bit on the HIF interface (hif_cmd_autopre).\nThe pageclose feature provids a midway between Open and Close page policies.\nFor performance only.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "1",
                "field": "PREFER_WRITE",
                "description": "If set then the bank selector prefers writes over reads.\nFOR DEBUG ONLY.\nProgramming mode: Static\n"
              },
              {
                "range": "0",
                "field": "FORCE_LOW_PRI_N",
                "description": "Active low signal. When asserted ('0'), all incoming transactions are\nforced to low priority. This implies that all high priority read (HPR) and variable priority read\ncommands (VPR) are treated as low priority read (LPR) commands. On the write side, all\nvariable priority write (VPW) commands are treated as normal priority write (NPW) commands.\nForcing the incoming transactions to low priority implicitly turns off bypass path for read\ncommands.\nFor performance only.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_SCHED1",
            "offset": "0x254",
            "page": 282,
            "chapter": "5.7.59",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n282/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "7:0",
                "field": "PAGECLOSE_TIMER[7:0]",
                "description": "This field works in conjunction with SCHED.pageclose.\nIt only has meaning if SCHED.pageclose==1.\nIf SCHED.pageclose==1 and pageclose_timer==0, then an auto-precharge may be scheduled\nfor last read\nor write command in the CAM with a bank and page hit.\nNote, sometimes an explicit precharge is scheduled instead of the auto-precharge. See\nSCHED.pageclose for details of when this may happen.\nIf SCHED.pageclose==1 and pageclose_timer>0, then an auto-precharge is not scheduled for\nlast read\nor write command in the CAM with a bank and page hit.\nInstead, a timer is started, with pageclose_timer as the initial value.\nThere is a timer on a per bank basis.\nThe timer decrements unless the next read or write in the CAM to a bank is a page hit.\nIt gets reset to pageclose_timer value if the next read or write in the CAM to a bank is a page\nhit.\nOnce the timer has reached zero, an explicit precharge is attempted to be scheduled.\nProgramming mode: Static.\n5.7.60 DDRCTRL high priority read CAM register 1\n(DDRCTRL_PERFHPR1)\nAddress offset: 0x25C\nReset value: 0x0F00 0001\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nHPR_XACT_RUN_LENGTH[7:0] Res. Res. Res. Res. Res. Res. Res. Res.\nrw rw rw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nHPR_MAX_STARVE[15:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:24",
                "field": "HPR_XACT_RUN_LENGTH[7:0]",
                "description": "\nNumber of transactions that are serviced once the HPR queue goes critical is the smaller of:\n- (a) This number\n- (b) Number of transactions available.\nUnit: Transaction.\nFor performance only.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "23:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "HPR_MAX_STARVE[15:0]",
                "description": "Number of DFI clocks that the HPR queue can be starved before it\ngoes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0\ndisables the starvation functionality; during normal operation, this function must not be disabled\nas it causes excessive latencies.\nFor performance only.\nProgramming mode: Quasi-dynamic Group 3\nRM0436 Rev 7 283/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_PERFLPR1",
            "offset": "0x264",
            "page": 284,
            "chapter": "5.7.61",
            "resetvalue": "0x0f00007f",
            "bits": [
              {
                "range": "31:24",
                "field": "LPR_XACT_RUN_LENGTH[7:0]",
                "description": "\nNumber of transactions that are serviced once the LPR queue goes critical is the smaller of:\n- (a) This number\n- (b) Number of transactions available.\nUnit: Transaction.\nFor performance only\nProgramming mode: Quasi-dynamic group 3\n"
              },
              {
                "range": "23:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "LPR_MAX_STARVE[15:0]",
                "description": "Number of DFI clocks that the LPR queue can be starved before it\ngoes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0\ndisables the starvation functionality; during normal operation, this function must be disabled as\nit causes excessive latencies.\nFor performance only\nProgramming mode: Quasi-dynamic Group 3\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_PERFWR1",
            "offset": "0x26C",
            "page": 284,
            "chapter": "5.7.62",
            "resetvalue": "0x0f00007f",
            "bits": [
              {
                "range": "31:24",
                "field": "W_XACT_RUN_LENGTH[7:0]",
                "description": "\nNumber of transactions that are serviced once the WR queue goes critical is the smaller of:\n- (a) This number\n- (b) Number of transactions available.\nUnit: Transaction.\nFor performance only.\nProgramming mode: Quasi-dynamic Group 3.\n"
              },
              {
                "range": "23:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n284/4054 RM0436 Rev 7\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "15:0",
                "field": "W_MAX_STARVE[15:0]",
                "description": "Number of DFI clocks that the WR queue can be starved before it\ngoes critical. The minimum valid functional value for this register is 0x1. Programming it to 0x0\ndisables the starvation functionality; during normal operation, this function must not be disabled\nas it causes excessive latencies.\nFor performance only.\nProgramming mode: Quasi-dynamic Group 3.\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DBG0",
            "offset": "0x300",
            "page": 285,
            "chapter": "5.7.63",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "DIS_COLLISION_PAGE_OPT",
                "description": "When this is set to '0', auto-precharge is disabled for the\nflushed command in a collision case. Collision cases are write followed by read to same\naddress, read followed by write to same address, or write followed by write to same address\nwith DBG0.dis_wc bit = 1 (where same address comparisons exclude the two address bits\nrepresenting critical word).\nFOR DEBUG ONLY.\nProgramming mode: Static\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "DIS_WC",
                "description": "When 1, disable write combine.\nFOR DEBUG ONLY\nProgramming mode: Static\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DBG1",
            "offset": "0x304",
            "page": 286,
            "chapter": "5.7.64",
            "resetvalue": "0x00000000",
            "bits": []
          },
          {
            "registername": "DDRCTRL_DBGCAM",
            "offset": "0x308",
            "page": 286,
            "chapter": "5.7.65",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "DIS_HIF",
                "description": "When 1, DDRCTRL asserts the HIF command signal hif_cmd_stall. DDRCTRL\nignores the hif_cmd_valid and all other associated request signals.\nThis bit is intended to be switched on-the-fly.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "0",
                "field": "DIS_DQ",
                "description": "When 1, DDRCTRL does not de-queue any transactions from the CAM. Bypass is\nalso disabled. All transactions are queued in the CAM. No reads or writes are issued to SDRAM\nas long as this is asserted.\nThis bit may be used to prevent reads or writes being issued by the DDRCTRL, which makes it\nsafe to modify certain register fields associated with reads and writes (see User Guide for\ndetails). After setting this bit, it is strongly recommended to poll\nDBGCAM.wr_data_pipeline_empty and DBGCAM.rd_data_pipeline_empty, before making\nchanges to any registers which affect reads and writes. This ensures that the relevant logic in\nthe DDRC is idle.\nThis bit is intended to be switched on-the-fly.\nProgramming mode: Dynamic\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res.\nYTPME_ENILEPIP_ATAD_RW YTPME_ENILEPIP_ATAD_DR\nRes.\nYTPME_Q_RW_GBD YTPME_Q_DR_GBD\nLLATS_GBD\nRes. Res. Res. DBG_W_Q_DEPTH[4:0]\nr r r r r r r r r r\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. DBG_LPR_Q_DEPTH[4:0] Res. Res. Res. DBG_HPR_Q_DEPTH[4:0]\nr r r r r r r r r r\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29",
                "field": "WR_DATA_PIPELINE_EMPTY",
                "description": "This bit indicates that the write data pipeline on the DFI\ninterface is empty. This register is intended to be polled at least twice after setting\nDBG1.dis_dq, to ensure that all remaining commands/data have completed.\nProgramming mode: Dynamic.\n"
              },
              {
                "range": "28",
                "field": "RD_DATA_PIPELINE_EMPTY",
                "description": "This bit indicates that the read data pipeline on the DFI\ninterface is empty. This register is intended to be polled at least twice after setting\nDBG1.dis_dq, to ensure that all remaining commands/data have completed.\nProgramming mode: Dynamic.\n"
              },
              {
                "range": "27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26",
                "field": "DBG_WR_Q_EMPTY",
                "description": "When 1, all the Write command queues and Write data buffers inside\nDDRC are empty. This register is to be used for debug purpose.\nAn example use-case scenario: When Controller enters Self-Refresh using the Low-Power\nentry sequence, Controller is expected to have executed all the commands in its queues and\nthe write and read data drained. Hence this register should be 1 at that time.\nFor debug only.\nProgramming mode: Dynamic.\n"
              },
              {
                "range": "25",
                "field": "DBG_RD_Q_EMPTY",
                "description": "When 1, all the Read command queues and Read data buffers inside\nDDRC are empty. This register is to be used for debug purpose.\nAn example use-case scenario: When Controller enters Self-Refresh using the Low-Power\nentry sequence, Controller is expected to have executed all the commands in its queues and\nthe write and read data drained. Hence this register should be 1 at that time.\nFor debug only.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "24",
                "field": "DBG_STALL",
                "description": "Stall\nFor debug only.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "23:21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20:16",
                "field": "DBG_W_Q_DEPTH[4:0]",
                "description": "Write queue depth\nThe last entry of WR queue is reserved for ECC SCRUB operation. This entry is not included in\nthe calculation of the queue depth.\nFor debug only.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "15:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12:8",
                "field": "DBG_LPR_Q_DEPTH[4:0]",
                "description": "Low priority read queue depth\nThe last entry of Lpr queue is reserved for ECC SCRUB operation. This entry is not included in\nthe calculation of the queue depth.\nFor debug only.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "DBG_HPR_Q_DEPTH[4:0]",
                "description": "High priority read queue depth\nFor debug only.\nProgramming mode: Dynamic\nRM0436 Rev 7 287/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DBGCMD",
            "offset": "0x30C",
            "page": 288,
            "chapter": "5.7.66",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "CTRLUPD",
                "description": "\nSetting this register bit to 1 indicates to the DDRCTRL to issue a dfi_ctrlupd_req to the PHY.\nWhen this request is stored in the DDRCTRL, the bit is automatically cleared. This operation\nmust only be performed when DFIUPD0.dis_auto_ctrlupd=1.\nProgramming mode: Dynamic.\n"
              },
              {
                "range": "4",
                "field": "ZQ_CALIB_SHORT",
                "description": "\nSetting this register bit to 1 indicates to the DDRCTRL to issue a ZQCS (ZQ calibration\nshort)/MPC(ZQ calibration) command to the SDRAM. When this request is stored in the\nDDRCTRL, the bit is automatically cleared. This operation can be performed only when\nZQCTL0.dis_auto_zq=1. It is recommended NOT to set this register bit if in Init, in Self-\nRefresh(except LPDDR4) or SR-Powerdown(LPDDR4) or Deep power-down operating modes\nor maximum power saving mode.\nFor self-refresh(except LPDDR4) or SR-powerdown(LPDDR4) it is scheduled after SR(except\nLPDDR4) or SPRD(LPDDR4) has been exited.\nFor Deep power down and maximum power saving mode, it is not scheduled, although\nDBGSTAT.zq_calib_short_busy is de-asserted.\nProgramming mode: Dynamic.\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "RANK0_REFRESH",
                "description": "\nSetting this register bit to 1 indicates to the DDRCTRL to issue a refresh to rank 0. Writing to\nthis bit causes DBGSTAT.rank0_refresh_busy to be set. When DBGSTAT.rank0_refresh_busy\nis cleared, the command has been stored in DDRCTRL.\nFor 3DS configuration, refresh is sent to rank index 0.\nThis operation can be performed only when RFSHCTL3.dis_auto_refresh=1. It is\nrecommended NOT to set this register bit if in Init or Deep power-down operating modes or\nMaximum Power Saving Mode.\nProgramming mode: Dynamic.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_DBGSTAT",
            "offset": "0x310",
            "page": 289,
            "chapter": "5.7.67",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "CTRLUPD_BUSY",
                "description": "SoC core may initiate a ctrlupd operation only if this signal is low. This\nsignal goes high in the clock after the DDRCTRL accepts the ctrlupd request. It goes low when\nthe ctrlupd operation is initiated in the DDRCTRL. It is recommended not to perform ctrlupd\noperations when this signal is high.\n- 0 - Indicates that the SoC core can initiate a ctrlupd operation\n- 1 - Indicates that ctrlupd operation has not been initiated yet in the DDRCTRL\nProgramming mode: Dynamic\n"
              },
              {
                "range": "4",
                "field": "ZQ_CALIB_SHORT_BUSY",
                "description": "SoC core may initiate a ZQCS (ZQ calibration short) operation\nonly if this signal is low. This signal goes high in the clock after the DDRCTRL accepts the\nZQCS request. It goes low when the ZQCS operation is initiated in the DDRCTRL. It is\nrecommended not to perform ZQCS operations when this signal is high.\n- 0 - Indicates that the SoC core can initiate a ZQCS operation\n- 1 - Indicates that ZQCS operation has not been initiated yet in the DDRCTRL\nProgramming mode: Dynamic\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "RANK0_REFRESH_BUSY",
                "description": "SoC core may initiate a rank0_refresh operation (refresh operation\nto rank 0) only if this signal is low. This signal goes high in the clock after\nDBGCMD.rank0_refresh is set to one. It goes low when the rank0_refresh operation is stored in\nthe DDRCTRL. It is recommended not to perform rank0_refresh operations when this signal is\nhigh.\n- 0 - Indicates that the SoC core can initiate a rank0_refresh operation\n- 1 - Indicates that rank0_refresh operation has not been stored yet in the DDRCTRL\nProgramming mode: Dynamic\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n5.7.68 DDRCTRL software register programming control enable\n(DDRCTRL_SWCTL)\nAddress offset: 0x320\nReset value: 0x0000 0001\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n5.7.69 DDRCTRL software register programming control status\n(DDRCTRL_SWSTAT)\nAddress offset: 0x324\nReset value: 0x0000 0001\n290/4054 RM0436 Rev 7\nENOD_WS\nrw\n"
              },
              {
                "range": "31:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "SW_DONE",
                "description": "Enable quasi-dynamic register programming outside reset. Program register to 0\nto enable quasi-dynamic programming. Set back register to 1 once programming is done.\nProgramming mode: Dynamic\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\nKCA_ENOD_WS\nr\n"
              },
              {
                "range": "31:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "SW_DONE_ACK",
                "description": "Register programming done. This register is the echo of SWCTL.sw_done.\nWait for sw_done value 1 to propagate to sw_done_ack at the end of the programming\nsequence to ensure that the correct registers values are propagated to the destination clock\ndomains.\nProgramming mode: Static\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n5.7.70 DDRCTRL AXI Poison configuration register\n(DDRCTRL_POISONCFG)\nAddress offset: 0x36C\nReset value: 0x0011 0011\nAXI Poison configuration register common for all AXI ports.\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res.\nRM0436 Rev 7 291/4054\n318\nRLC_RTNI_NOSIOP_DR\nRes. Res. Res.\nNE_RTNI_NOSIOP_DR\nRes. Res. Res.\nNE_RREVLS_NOSIOP_DR\nrc_w1 rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. Res. Res.\nRLC_RTNI_NOSIOP_RW\nRes. Res. Res.\nNE_RTNI_NOSIOP_RW\nRes. Res. Res.\nNE_RREVLS_NOSIOP_RW\nrc_w1 rw rw\n"
              },
              {
                "range": "31:25",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "24",
                "field": "RD_POISON_INTR_CLR",
                "description": "Interrupt clear for read transaction poisoning. Allow 2/3 clock cycles\nfor correct value to propagate to core logic and clear the interrupts.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "23:21",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "20",
                "field": "RD_POISON_INTR_EN",
                "description": "If set to 1, enables interrupts for read transaction poisoning\nProgramming mode: Dynamic\n"
              },
              {
                "range": "19:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "RD_POISON_SLVERR_EN",
                "description": "If set to 1, enables SLVERR response for read transaction\npoisoning\nProgramming mode: Dynamic\n"
              },
              {
                "range": "15:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8",
                "field": "WR_POISON_INTR_CLR",
                "description": "Interrupt clear for write transaction poisoning. Allow 2/3 clock cycles\nfor correct value to propagate to core logic and clear the interrupts.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "WR_POISON_INTR_EN",
                "description": "If set to 1, enables interrupts for write transaction poisoning\nProgramming mode: Dynamic\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "0",
                "field": "WR_POISON_SLVERR_EN",
                "description": "If set to 1, enables SLVERR response for write transaction\npoisoning\nProgramming mode: Dynamic\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_POISONSTAT",
            "offset": "0x370",
            "page": 292,
            "chapter": "5.7.71",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17",
                "field": "RD_POISON_INTR_1",
                "description": "Read transaction poisoning error interrupt for port 1. This register is a\nAPB clock copy (double register synchronizer) of the interrupt asserted when a transaction is\npoisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0,\nand so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB\nclock.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "16",
                "field": "RD_POISON_INTR_0",
                "description": "Read transaction poisoning error interrupt for port 0. This register is a\nAPB clock copy (double register synchronizer) of the interrupt asserted when a transaction is\npoisoned on the corresponding AXI port's read address channel. Bit 0 corresponds to Port 0,\nand so on. Interrupt is cleared by register rd_poison_intr_clr, then value propagated to APB\nclock.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "15:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "WR_POISON_INTR_1",
                "description": "Write transaction poisoning error interrupt for port 1. This register is a\nAPB clock copy (double register synchronizer) of the interrupt asserted when a transaction is\npoisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0,\nand so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB\nclock.\nProgramming mode: Dynamic\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "0",
                "field": "WR_POISON_INTR_0",
                "description": "Write transaction poisoning error interrupt for port 0. This register is a\nAPB clock copy (double register synchronizer) of the interrupt asserted when a transaction is\npoisoned on the corresponding AXI port's write address channel. Bit 0 corresponds to Port 0,\nand so on. Interrupt is cleared by register wr_poison_intr_clr, then value propagated to APB\nclock.\nProgramming mode: Dynamic\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_PSTAT",
            "offset": "0x3FC",
            "page": 293,
            "chapter": "5.7.72",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17",
                "field": "WR_PORT_BUSY_1",
                "description": "Indicates if there are outstanding writes for AXI port 1.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "16",
                "field": "WR_PORT_BUSY_0",
                "description": "Indicates if there are outstanding writes for AXI port 0.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "15:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "RD_PORT_BUSY_1",
                "description": "Indicates if there are outstanding reads for AXI port 1.\nProgramming mode: Dynamic\n"
              },
              {
                "range": "0",
                "field": "RD_PORT_BUSY_0",
                "description": "Indicates if there are outstanding reads for AXI port 0.\nProgramming mode: Dynamic\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_PCCFG",
            "offset": "0x400",
            "page": 294,
            "chapter": "5.7.73",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8",
                "field": "BL_EXP_MODE",
                "description": "Burst length expansion mode. By default (i.e. bl_exp_mode==0) XPI\nexpands every AXI burst into multiple HIF commands, using the memory burst length as a unit.\nIf set to 1, then XPI uses half of the memory burst length as a unit.\nThis applies to both reads and writes. When MSTR.data_bus_width==00, setting\nbl_exp_mode to 1 has no effect.\nThis can be used in cases where Partial Writes is enabled (UMCTL2_PARTIAL_WR=1), in\norder to avoid or minimize t_ccd_l penalty in DDR4 and t_ccd_mw penalty in LPDDR4. Hence,\nbl_exp_mode=1 is only recommended if DDR4 or LPDDR4.\nNote that if DBICTL.dm_en=0, functionality is not supported in the following cases:\n- UMCTL2_PARTIAL_WR=0\n- UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=8 and\nMSTR.burst_rdwr=1000 (LPDDR4 only)\n- UMCTL2_PARTIAL_WR=1, MSTR.data_bus_width=01, MEMC_BURST_LENGTH=4 and\nMSTR.burst_rdwr=0100 (DDR4 only), with either MSTR.burstchop=0 or\nCRCPARCTL1.crc_enable=1\nFunctionality is also not supported if Data Channel Interleave is enabled.\nProgramming mode: Static.\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "PAGEMATCH_LIMIT",
                "description": "Page match four limit. If set to 1, limits the number of consecutive same\npage DDRC transactions that can be granted by the Port Arbiter to four when Page Match\nfeature is enabled. If set to 0, there is no limit imposed on number of consecutive same\npage DDRC transactions.\nProgramming mode: Static.\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "0",
                "field": "GO2CRITICAL_EN",
                "description": "If set to 1 (enabled), sets co_gs_go2critical_wr and\nco_gs_go2critical_lpr/co_gs_go2critical_hpr signals going to DDRC based on urgent input\n(awurgent, arurgent) coming from AXI master. If set to 0 (disabled), co_gs_go2critical_wr and\nco_gs_go2critical_lpr/co_gs_go2critical_hpr signals at DDRC are driven to 1b'0.\nProgramming mode: Static.\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_PCFGR_x",
            "offset": "0x404",
            "page": 295,
            "chapter": "5.7.74",
            "resetvalue": "0x00004000",
            "bits": [
              {
                "range": "31:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "RDWR_ORDERED_EN",
                "description": "Enables ordered read/writes. If set to 1, preserves the ordering\nbetween read transaction and write transaction issued to the same address, on a given port. In\nother words, the controller ensures that all same address read and write commands from the\napplication port interface are transported to the DFI interface in the order of acceptance. This\nfeature is useful in cases where software coherency is desired for masters issuing back-to-back\nread/write transactions without waiting for write/read responses. Note that this register has an\neffect only if necessary logic is instantiated via the UMCTL2_RDWR_ORDERED_n parameter.\nProgramming mode: Static.\n"
              },
              {
                "range": "15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14",
                "field": "RD_PORT_PAGEMATCH_EN",
                "description": "If set to 1, enables the Page Match feature. If enabled, once a\nrequesting port is granted, the port is continued to be granted if the following immediate\ncommands are to the same memory page (same bank and same row). See also related\nPCCFG.pagematch_limit register.\nProgramming mode: Static\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "13",
                "field": "RD_PORT_URGENT_EN",
                "description": "If set to 1, enables the AXI urgent sideband signal (arurgent). When\nenabled and arurgent is asserted by the master, that port becomes the highest priority and\nco_gs_go2critical_lpr/co_gs_go2critical_hpr signal to DDRC is asserted if enabled in\nPCCFG.go2critical_en register. Note that arurgent signal can be asserted anytime and as long\nas required which is independent of address handshaking (it is not associated with any\nparticular command).\nProgramming mode: Static\n"
              },
              {
                "range": "12",
                "field": "RD_PORT_AGING_EN",
                "description": "If set to 1, enables aging function for the read channel of the port.\nProgramming mode: Static\n"
              },
              {
                "range": "11:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9:0",
                "field": "RD_PORT_PRIORITY[9:0]",
                "description": "Determines the initial load value of read aging counters. These\ncounters are parallel loaded after reset, or after each grant to the corresponding port. The\naging counters down-count every clock cycle where the port is requesting but not granted. The\nhigher significant 5-bits of the read aging counter sets the priority of the read channel of a given\nport. Port's priority increases as the higher significant 5-bits of the counter starts to decrease.\nWhen the aging counter becomes 0, the corresponding port channel has the highest priority\nlevel (timeout condition - Priority0). For multi-port configurations, the aging counters cannot be\nused to set port priorities when external dynamic priority inputs (arqos) are enabled (timeout is\nstill applicable). For single port configurations, the aging counters are only used when they\ntimeout (become 0) to force read-write direction switching. In this case, external dynamic\npriority input, arqos (for reads only) can still be used to set the DDRC read priority (2 priority\nlevels: low priority read - LPR, high priority read - HPR) on a command by command basis.\nNote: The two LSBs of this register field are tied internally to 2'b00.\nProgramming mode: Static\n5.7.75 DDRCTRL port x configuration write register\n(DDRCTRL_PCFGW_x)\nAddress offset: 0x408 + 0xB0 * x, (x = 0 to 1)\nReset value: 0x0000 4000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res.\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes.\n296/4054 RM0436 Rev 7\nNE_HCTAMEGAP_TROP_RW\nNE_TNEGRU_TROP_RW\nNE_GNIGA_TROP_RW\nRes. Res. WR_PORT_PRIORITY[9:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:15",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "14",
                "field": "WR_PORT_PAGEMATCH_EN",
                "description": "If set to 1, enables the Page Match feature. If enabled, once a\nrequesting port is granted, the port is continued to be granted if the following immediate\ncommands are to the same memory page (same bank and same row). See also related\nPCCFG.pagematch_limit register.\nProgramming mode: Static\n"
              },
              {
                "range": "13",
                "field": "WR_PORT_URGENT_EN",
                "description": "If set to 1, enables the AXI urgent sideband signal (awurgent).\nWhen enabled and awurgent is asserted by the master, that port becomes the highest priority\nand co_gs_go2critical_wr signal to DDRC is asserted if enabled in PCCFG.go2critical_en\nregister.\nNote that awurgent signal can be asserted anytime and as long as required which is\nindependent of address handshaking (it is not associated with any particular command).\nProgramming mode: Static\n"
              },
              {
                "range": "12",
                "field": "WR_PORT_AGING_EN",
                "description": "If set to 1, enables aging function for the write channel of the port.\nProgramming mode: Static\n"
              },
              {
                "range": "11:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9:0",
                "field": "WR_PORT_PRIORITY[9:0]",
                "description": "Determines the initial load value of write aging counters. These\ncounters are parallel loaded after reset, or after each grant to the corresponding port. The\naging counters down-count every clock cycle where the port is requesting but not granted. The\nhigher significant 5-bits of the write aging counter sets the initial priority of the write\nchannel of a given port. Port's priority increases as the higher significant 5-bits of the counter\nstarts to decrease. When the aging counter becomes 0, the corresponding port channel has the\nhighest priority level.\nFor multi-port configurations, the aging counters cannot be used to set port priorities when\nexternal dynamic priority inputs (awqos) are enabled (timeout is still applicable).\nFor single port configurations, the aging counters are only used when they timeout (become 0)\nto force read-write direction switching.\nNote: The two LSBs of this register field are tied internally to 2'b00.\nProgramming mode: Static\n"
              }
            ]
          },
          {
            "registername": "DDRCTRL_PCTRL_x",
            "offset": "0x490",
            "page": 297,
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "PORT_EN",
                "description": "Enables AXI port n.\nProgramming mode: Dynamic\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n5.7.77 DDRCTRL port x read Q0S configuration register 0\n(DDRCTRL_PCFGQOS0_x)\nAddress offset: 0x494 + 0xB0 * x, (x = 0 to 1)\nReset value: 0x0200 0E00\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res.\n298/4054 RM0436 Rev 7\n]0:1[2NOIGER_PAM_SOQR\nRes. Res.\n]0:1[1NOIGER_PAM_SOQR\nRes. Res.\n]0:1[0NOIGER_PAM_SOQR\nrw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. RQOS_MAP_LEVEL2[3:0] Res. Res. Res. Res. RQOS_MAP_LEVEL1[3:0]\nrw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:24",
                "field": "RQOS_MAP_REGION2[1:0]",
                "description": "This bitfield indicates the traffic class of region2.\nFor dual address queue configurations, region2 maps to the red address queue.\nValid values are 1: VPR and 2: HPR only.\nWhen VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region2 is set to 1\n(VPR), VPR traffic is aliased to LPR traffic.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "23:22",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "21:20",
                "field": "RQOS_MAP_REGION1[1:0]",
                "description": "This bitfield indicates the traffic class of region 1.\nValid values are:\n- 0 : LPR,\n- 1: VPR,\n- 2: HPR.\nFor dual address queue configurations, region1 maps to the blue address queue.\nIn this case, valid values are\n- 0: LPR and\n- 1: VPR only.\nWhen VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region 1 is set to 1\n(VPR), VPR traffic is aliased to LPR traffic.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "19:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "17:16",
                "field": "RQOS_MAP_REGION0[1:0]",
                "description": "This bitfield indicates the traffic class of region 0.\nValid values are:\n- 0: LPR, 1: VPR, 2: HPR.\nFor dual address queue configurations, region 0 maps to the blue address queue.\nIn this case, valid values are:\n- 0: LPR and 1: VPR only.\nWhen VPR support is disabled (UMCTL2_VPR_EN = 0) and traffic class of region0 is set to 1\n(VPR), VPR traffic is aliased to LPR traffic.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "RQOS_MAP_LEVEL2[3:0]",
                "description": "Separation level2 indicating the end of region1 mapping; start of\nregion1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to\narqos.\nRegion2 starts from (level2 + 1) up to 15.\nNote that for PA, arqos values are used directly as port priorities, where the higher the value\ncorresponds to higher port priority.\nAll of the map_level* registers must be set to distinct values.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "RQOS_MAP_LEVEL1[3:0]",
                "description": "Separation level1 indicating the end of region0 mapping; start of\nregion0 is 0. Possible values for level1 are 0 to 13 (for dual RAQ) or 0 to 14 (for single RAQ)\nwhich corresponds to arqos.\nNote that for PA, arqos values are used directly as port priorities, where the higher the value\ncorresponds to higher port priority.\nAll of the map_level* registers must be set to distinct values.\nProgramming mode: Quasi-dynamic Group 3\n5.7.78 DDRCTRL port x read Q0S configuration register 1\n(DDRCTRL_PCFGQOS1_x)\nAddress offset: 0x498 + 0xB0 * x, (x = 0 to 1)\nReset value: 0x00000000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. RQOS_MAP_TIMEOUTR[10:0]\nrw rw rw rw rw rw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. RQOS_MAP_TIMEOUTB[10:0]\nrw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26:16",
                "field": "RQOS_MAP_TIMEOUTR[10:0]",
                "description": "Specifies the timeout value for transactions mapped to the red\naddress queue. With single read address queue, there is no red queue and this value has no\neffect.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "15:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 299/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              },
              {
                "range": "10:0",
                "field": "RQOS_MAP_TIMEOUTB[10:0]",
                "description": "Specifies the timeout value for transactions mapped to the\nblue address queue.\nProgramming mode: Quasi-dynamic Group 3.\n5.7.79 DDRCTRL port x write Q0S configuration register 0\n(DDRCTRL_PCFGWQOS0_x)\nAddress offset: 0x49C + 0xB0 * x, (x = 0 to 1)\nReset value: 0x0000 0E00\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res.\n300/4054 RM0436 Rev 7\n]0:1[2NOIGER_PAM_SOQW\nRes. Res.\n]0:1[1NOIGER_PAM_SOQW\nRes. Res.\n]0:1[0NOIGER_PAM_SOQW\nrw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. WQOS_MAP_LEVEL2[3:0] Res. Res. Res. Res. WQOS_MAP_LEVEL1[3:0]\nrw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:24",
                "field": "WQOS_MAP_REGION2[1:0]",
                "description": "This bitfield indicates the traffic class of region 2.\nValid values are:\n0: NPW, 1: VPW.\nWhen VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 2 is set to 1\n(VPW), VPW traffic is aliased to NPW traffic.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "23:22",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "21:20",
                "field": "WQOS_MAP_REGION1[1:0]",
                "description": "This bitfield indicates the traffic class of region 1.\nValid values are:\n0: NPW, 1: VPW.\nWhen VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 1 is set to 1\n(VPW), VPW traffic is aliased to NPW traffic.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "19:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17:16",
                "field": "WQOS_MAP_REGION0[1:0]",
                "description": "This bitfield indicates the traffic class of region 0.\nValid values are:\n0: NPW, 1: VPW.\nWhen VPW support is disabled (UMCTL2_VPW_EN = 0) and traffic class of region 0 is set\nto 1 (VPW), VPW traffic is aliased to NPW traffic.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 DDR3/LPDDR2/LPDDR3 controller (DDRCTRL)\n"
              },
              {
                "range": "11:8",
                "field": "WQOS_MAP_LEVEL2[3:0]",
                "description": "Separation level2 indicating the end of region1 mapping; start of\nregion1 is (level1 + 1). Possible values for level2 are (level1 + 1) to 14 which corresponds to\nawqos.\nRegion2 starts from (level2 + 1) up to 15.\nNote that for PA, awqos values are used directly as port priorities, where the higher the value\ncorresponds to higher port priority.\nAll of the map_level* registers must be set to distinct values.\nProgramming mode: Quasi-dynamic Group 3\n"
              },
              {
                "range": "7:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "WQOS_MAP_LEVEL1[3:0]",
                "description": "Separation level indicating the end of region0 mapping; start of\nregion0 is 0. Possible values for level1 are 0 to 13 which corresponds to awqos.\nNote that for PA, awqos values are used directly as port priorities, where the higher the value\ncorresponds to higher port priority.\nAll of the map_level* registers must be set to distinct values.\nProgramming mode: Quasi-dynamic Group 3\n5.7.80 DDRCTRL port x write Q0S configuration register 1\n(DDRCTRL_PCFGWQOS1_x)\nAddress offset: 0x4A0 + 0xB0 * x, (x = 0 to 1)\nReset value: 0x0000 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. WQOS_MAP_TIMEOUT2[10:0]\nrw rw rw rw rw rw rw rw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nRes. Res. Res. Res. Res. WQOS_MAP_TIMEOUT1[10:0]\nrw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26:16",
                "field": "WQOS_MAP_TIMEOUT2[10:0]",
                "description": "Specifies the timeout value for write transactions in region 2.\nProgramming mode: Quasi-dynamic Group 3.\n"
              },
              {
                "range": "15:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:0",
                "field": "WQOS_MAP_TIMEOUT1[10:0]",
                "description": "Specifies the timeout value for write transactions in region 0\nand 1.\nProgramming mode: Quasi-dynamic Group 3.\nRM0436 Rev 7 301/4054\n318\nDDR3/LPDDR2/LPDDR3 controller (DDRCTRL) RM0436\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "GPIO registers",
        "registers": [
          {
            "registername": "GPIOx_MODER",
            "offset": "0x00",
            "page": 1078,
            "chapter": "13.4.1",
            "resetvalue": "0xffffffff",
            "bits": [
              {
                "range": "31:0",
                "field": "MODER[15:0][1:0]",
                "description": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O mode.\n00: Input mode\n01: General purpose output mode\n10: Alternate function mode\n11: Analog mode\n"
              }
            ]
          },
          {
            "registername": "GPIOx_OTYPER",
            "offset": "0x04",
            "page": 1078,
            "chapter": "13.4.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "OT[15:0]",
                "description": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output type.\n0: Output push-pull (reset state)\n1: Output open-drain\n1078/4054 RM0436 Rev 7\nRM0436 General-purpose I/Os (GPIO)\n"
              }
            ]
          },
          {
            "registername": "GPIOx_OSPEEDR",
            "offset": "0x08",
            "page": 1079,
            "chapter": "13.4.3",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "OSPEEDR[15:0][1:0]",
                "description": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O output speed.\n00: Low speed\n01: Medium speed\n10: High speed\n11: Very high speed\nNote: Refer to the product datasheets for the values of OSPEEDRy bits versus V range\nDD\nand external load.\n"
              }
            ]
          },
          {
            "registername": "GPIOx_PUPDR",
            "offset": "0x0C",
            "page": 1079,
            "chapter": "13.4.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "PUPDR[15:0][1:0]",
                "description": "Port x configuration I/O pin y (y = 15 to 0)\nThese bits are written by software to configure the I/O pull-up or pull-down\n00: No pull-up, pull-down\n01: Pull-up\n10: Pull-down\n11: Reserved\n"
              }
            ]
          },
          {
            "registername": "GPIOx_IDR",
            "offset": "0x10",
            "page": 1079,
            "chapter": "13.4.5",
            "resetvalue": "0x0000xxxx",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "IDR[15:0]",
                "description": "Port x input data I/O pin y (y = 15 to 0)\nThese bits are read-only. They contain the input value of the corresponding I/O port.\n"
              }
            ]
          },
          {
            "registername": "GPIOx_ODR",
            "offset": "0x14",
            "page": 1080,
            "chapter": "13.4.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "ODR[15:0]",
                "description": "Port output data I/O pin y (y = 15 to 0)\nThese bits can be read and written by software.\nNote: For atomic bit set/reset, the ODR bits can be individually set and/or reset by writing to\nthe GPIOx_BSRR register (x = A..F).\n"
              }
            ]
          },
          {
            "registername": "GPIOx_BSRR",
            "offset": "0x18",
            "page": 1080,
            "chapter": "13.4.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "BR[15:0]",
                "description": "Port x reset I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\n0: No action on the corresponding ODRx bit\n1: Resets the corresponding ODRx bit\nNote: If both BSx and BRx are set, BSx has priority.\n"
              },
              {
                "range": "15:0",
                "field": "BS[15:0]",
                "description": "Port x set I/O pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\n0: No action on the corresponding ODRx bit\n1: Sets the corresponding ODRx bit\n"
              }
            ]
          },
          {
            "registername": "GPIOx_LCKR",
            "offset": "0x1C",
            "page": 1081,
            "chapter": "13.4.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16",
                "field": "LCKK",
                "description": "Lock key\nThis bit can be read any time. It can only be modified using the lock key write sequence.\n0: Port configuration lock key not active\n1: Port configuration lock key active. The GPIOx_LCKR register is locked until the next MCU\nreset or peripheral reset.\nLOCK key write sequence:\nWR LCKR[16] = â€˜1â€™ + LCKR[15:0]\nWR LCKR[16] = â€˜0â€™ + LCKR[15:0]\nWR LCKR[16] = â€˜1â€™ + LCKR[15:0]\nRD LCKR\nRD LCKR[16] = â€˜1â€™ (this read operation is optional but it confirms that the lock is active)\nNote: During the LOCK key write sequence, the value of LCK[15:0] must not change.\nAny error in the lock sequence aborts the lock.\nAfter the first lock sequence on any bit of the port, any read access on the LCKK bit\nreturns â€˜1â€™ until the next MCU reset or peripheral reset.\n"
              },
              {
                "range": "15:0",
                "field": "LCK[15:0]",
                "description": "Port x lock I/O pin y (y = 15 to 0)\nThese bits are read/write but can only be written when the LCKK bit is â€˜0.\n0: Port configuration not locked\n1: Port configuration locked\n"
              }
            ]
          },
          {
            "registername": "GPIOx_AFRL",
            "offset": "0x20",
            "page": 1082,
            "chapter": "13.4.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "AFR[7:0][3:0]",
                "description": "Alternate function selection for port x I/O pin y (y = 7 to 0)\nThese bits are written by software to configure alternate function I/Os.\n0000: AF0\n0001: AF1\n0010: AF2\n0011: AF3\n0100: AF4\n0101: AF5\n0110: AF6\n0111: AF7\n1000: AF8\n1001: AF9\n1010: AF10\n1011: AF11\n1100: AF12\n1101: AF13\n1110: AF14\n1111: AF15\n"
              }
            ]
          },
          {
            "registername": "GPIOx_AFRH",
            "offset": "0x24",
            "page": 1083,
            "chapter": "13.4.10",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "AFR[15:8][3:0]",
                "description": "Alternate function selection for port x I/O pin y (y = 15 to 8)\nThese bits are written by software to configure alternate function I/Os.\n0000: AF0\n0001: AF1\n0010: AF2\n0011: AF3\n0100: AF4\n0101: AF5\n0110: AF6\n0111: AF7\n1000: AF8\n1001: AF9\n1010: AF10\n1011: AF11\n1100: AF12\n1101: AF13\n1110: AF14\n1111: AF15\n"
              }
            ]
          },
          {
            "registername": "GPIOx_BRR",
            "offset": "0x28",
            "page": 1084,
            "chapter": "13.4.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "BR[15:0]",
                "description": "Port x reset IO pin y (y = 15 to 0)\nThese bits are write-only. A read to these bits returns the value 0x0000.\n0: No action on the corresponding ODx bit\n1: Reset the corresponding ODx bit\n"
              }
            ]
          },
          {
            "registername": "GPIOZ_SECCFGR",
            "offset": "0x30",
            "page": 1084,
            "chapter": "13.4.12",
            "resetvalue": "0x000000ff",
            "bits": [
              {
                "range": "7:0",
                "field": "SEC[7:0]",
                "description": "I/O pin of Port Z secure bit enable y (y= 0..7)\nThese bits control the security I/O port pin.\n0: The I/O pin is non-secure\n1: The I/O pin is secure. Refer to Table83: GPIO secured bits for all corresponding secured\nbits.\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR10",
            "offset": "0x3C8",
            "page": 1085,
            "chapter": "13.4.13",
            "resetvalue": "0x00001240",
            "bits": [
              {
                "range": "31:24",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "23:20",
                "field": "OR_CFG[3:0]",
                "description": "Option register configuration\n0: Non-active\n1: Active\n"
              },
              {
                "range": "19:16",
                "field": "SEC_CFG[3:0]",
                "description": "Security mechanism activation\n0: Non-active\n1: Active\n"
              },
              {
                "range": "15:12",
                "field": "LOCK_CFG[3:0]",
                "description": "Lock mechanism activation\n0: Non-active\n1: Active\nRM0436 Rev 7 1085/4054\n1093\nGeneral-purpose I/Os (GPIO) RM0436\n"
              },
              {
                "range": "11:8",
                "field": "SPEED_CFG[3:0]",
                "description": "Number of speed lines for each I/O\n1: One line\n2: Two lines\n"
              },
              {
                "range": "7:4",
                "field": "AF_SIZE[3:0]",
                "description": "Number of AF available for each I/O\nAccepted value: 1 to 4\n1: One AF/IO\n2: Four AF/IO\n3: Eight AF/IO\n4: 16 AF/IO\n"
              },
              {
                "range": "3:0",
                "field": "AHB_IOP[3:0]",
                "description": "Bus interface configuration\n0: AHB\n1: IOP\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR9",
            "offset": "0x3CC",
            "page": 1086,
            "chapter": "13.4.14",
            "resetvalue": "0x0000ffff",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "EN_IO[15:0]",
                "description": "Presence granularity, each bit indicate the presence of the IO\n0: IO not present\n1: IO present\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR8",
            "offset": "0x3D0",
            "page": 1086,
            "chapter": "13.4.15",
            "resetvalue": "0xffffffff",
            "bits": [
              {
                "range": "31:28",
                "field": "AF_PRIO15[3:0]",
                "description": "Indicate the priority AF for I/O15 (0 to F)\n"
              },
              {
                "range": "27:24",
                "field": "AF_PRIO14[3:0]",
                "description": "Indicate the priority AF for I/O14 (0 to F)\n"
              },
              {
                "range": "23:20",
                "field": "AF_PRIO13[3:0]",
                "description": "Indicate the priority AF for I/O13 (0 to F)\n"
              },
              {
                "range": "19:16",
                "field": "AF_PRIO12[3:0]",
                "description": "Indicate the priority AF for I/O12 (0 to F)\n"
              },
              {
                "range": "15:12",
                "field": "AF_PRIO11[3:0]",
                "description": "Indicate the priority AF for I/O11 (0 to F)\n"
              },
              {
                "range": "11:8",
                "field": "AF_PRIO10[3:0]",
                "description": "Indicate the priority AF for I/O10 (0 to F)\n"
              },
              {
                "range": "7:4",
                "field": "AF_PRIO9[3:0]",
                "description": "Indicate the priority AF for I/O9 (0 to F)\n"
              },
              {
                "range": "3:0",
                "field": "AF_PRIO8[3:0]",
                "description": "Indicate the priority AF for I/O8 (0 to F)\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR7",
            "offset": "0x3D4",
            "page": 1087,
            "chapter": "13.4.16",
            "resetvalue": "0xffffffff",
            "bits": [
              {
                "range": "31:28",
                "field": "AF_PRIO7[3:0]",
                "description": "Indicate the priority AF for I/O7 (0 to F)\n"
              },
              {
                "range": "27:24",
                "field": "AF_PRIO6[3:0]",
                "description": "Indicate the priority AF for I/O6 (0 to F)\n"
              },
              {
                "range": "23:20",
                "field": "AF_PRIO5[3:0]",
                "description": "Indicate the priority AF for I/O5 (0 to F)\n"
              },
              {
                "range": "19:16",
                "field": "AF_PRIO4[3:0]",
                "description": "Indicate the priority AF for I/O4 (0 to F)\n"
              },
              {
                "range": "15:12",
                "field": "AF_PRIO3[3:0]",
                "description": "Indicate the priority AF for I/O3 (0 to F)\n"
              },
              {
                "range": "11:8",
                "field": "AF_PRIO2[3:0]",
                "description": "Indicate the priority AF for I/O2 (0 to F)\n"
              },
              {
                "range": "7:4",
                "field": "AF_PRIO1[3:0]",
                "description": "Indicate the priority AF for I/O1 (0 to F)\n"
              },
              {
                "range": "3:0",
                "field": "AF_PRIO0[3:0]",
                "description": "Indicate the priority AF for I/O0 (0 to F)\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR6",
            "offset": "0x3D8",
            "page": 1087,
            "chapter": "13.4.17",
            "resetvalue": "0xffffffff",
            "bits": [
              {
                "range": "31:0",
                "field": "MODER_RES[31:0]",
                "description": "MODER register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR5",
            "offset": "0x3DC",
            "page": 1088,
            "chapter": "13.4.18",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "PUPDR_RES[31:0]",
                "description": "Pull-up / pull-down register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR4",
            "offset": "0x3E0",
            "page": 1088,
            "chapter": "13.4.19",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "OSPEED_RES[31:0]",
                "description": "OSPEED register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR3",
            "offset": "0x3E4",
            "page": 1088,
            "chapter": "13.4.20",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "OTYPER_RES[31:0]",
                "description": "Output type register reset value\n"
              },
              {
                "range": "15:0",
                "field": "ODR_RES[31:0]",
                "description": "Output data register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR2",
            "offset": "0x3E8",
            "page": 1089,
            "chapter": "13.4.21",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "AFRL_RES[31:0]",
                "description": "AF register low reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR1",
            "offset": "0x3EC",
            "page": 1089,
            "chapter": "13.4.22",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "AFRH_RES[31:0]",
                "description": "AF register high reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_HWCFGR0",
            "offset": "0x3F0",
            "page": 1089,
            "chapter": "13.4.23",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "OR_RES[15:0]",
                "description": "Option register reset value\n"
              }
            ]
          },
          {
            "registername": "GPIOx_VERR",
            "offset": "0x3F4",
            "page": 1090,
            "chapter": "13.4.24",
            "resetvalue": "0x00000040",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "Major revision\nThese bits return the GPIO major revision.\nMajor revision is 4.\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "Minor revision\nThese bits return the GPIO minor revision.\nMinor revision is 0.\n"
              }
            ]
          },
          {
            "registername": "GPIOx_IPIDR",
            "offset": "0x3F8",
            "page": 1090,
            "chapter": "13.4.25",
            "resetvalue": "0x000f0003",
            "bits": [
              {
                "range": "31:0",
                "field": "IPIDR[31:0]",
                "description": "GPIO identifier\nThese bits return the GPIO identifier value.\n1090/4054 RM0436 Rev 7\nRM0436 General-purpose I/Os (GPIO)\n"
              }
            ]
          },
          {
            "registername": "GPIOx_SIDR",
            "offset": "0x3FC",
            "page": 1091,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SIDR[31:0]",
                "description": "Size identifier register\nThese bits return the size of the memory region allocated to GPIO registers.\nRM0436 Rev 7 1091/4054\n1093\nGeneral-purpose I/Os (GPIO) RM0436\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "DTS registers",
        "registers": [
          {
            "registername": "DTS_CFGR1",
            "offset": "0x00",
            "page": 1631,
            "chapter": "30.6.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "30:24",
                "field": "HSREF_CLK_DIV[6:0]",
                "description": "High speed clock division ratio\nThese bits are set and cleared by software. They can be used to define the division ratio for\nthe main clock in order to obtain the internal frequency lower than 1MHz required for the\ncalibration. They are applicable only for calibration when PCLK is selected as reference\nclock (REFCLK_SEL=0).\n0000000: No divider\n0000001: No divider\n0000010: 1/2 division ratio\n...\n1111111: 1/127 division ratio\n"
              },
              {
                "range": "23:22",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "21",
                "field": "Q_MEAS_OPT",
                "description": "Quick measurement option bit\nThis bit is set and cleared by software. It is used to increase the measurement speed by\nsuppressing the calibration step. It is effective only when the LSE clock is used as reference\nclock (REFCLK_SEL=1).\n0: Measurement with calibration\n1: Measurement without calibration\n"
              },
              {
                "range": "20",
                "field": "REFCLK_SEL",
                "description": "Reference clock selection bit\nThis bit is set and cleared by software. It indicates whether the reference clock is the high\nspeed clock (PCLK) or the low speed clock (LSE).\n0: High speed reference clock (PCLK)\n1: Low speed reference clock (LSE)\n"
              },
              {
                "range": "19:16",
                "field": "TS1_SMP_TIME[3:0]",
                "description": "Sampling time for temperature sensor 1\nThese bits allow increasing the sampling time to improve measurement precision.\nWhen the PCLK clock is selected as reference clock (REFCLK_SEL=0), the measurement\nis performed at TS1_SMP_TIME period of CLK_PTAT.\nWhen the LSE is selected as reference clock (REFCLK_SEL=1), the measurement is\nperformed at TS1_SMP_TIME period of LSE.\n"
              },
              {
                "range": "15:12",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "11:8",
                "field": "TS1_INTRIG_SEL[3:0]",
                "description": "Input trigger selection bit for temperature sensor 1\nThese bits are set and cleared by software. They select which input triggers a temperature\nmeasurement. Refer to Section30.3.10: Trigger input.\n"
              },
              {
                "range": "7:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "TS1_START",
                "description": "Start frequency measurement on temperature sensor 1\nThis bit is set and cleared by software.\n0: No software trigger.\n1: Software trigger for a frequency measurement. (only if TS1 is ready).\n"
              },
              {
                "range": "3:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "TS1_EN",
                "description": "Temperature sensor 1 enable bit\nThis bit is set and cleared by software.\n0: Temperature sensor 1 disabled\n1: Temperature sensor 1 enabled\nNote: Once enabled, the temperature sensor is active after a specific delay time. The\nTS1_RDY flag is set when the sensor is ready.\n1632/4054 RM0436 Rev 7\nRM0436 Digital temperature sensor (DTS)\n"
              }
            ]
          },
          {
            "registername": "DTS_T0VALR1",
            "offset": "0x08",
            "page": 1633,
            "chapter": "30.6.2",
            "resetvalue": "0x000xxxxx",
            "bits": [
              {
                "range": "31:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17:16",
                "field": "TS1_T0[1:0]",
                "description": "Engineering value of the T0 temperature for temperature sensor 1.\n00: 30Â°C\n01: 130Â°C\nOthers: Reserved, must not be used.\n"
              },
              {
                "range": "15:0",
                "field": "TS1_FMT0[15:0]",
                "description": "Engineering value of the frequency measured at T0 for\ntemperature sensor 1\nThis value is expressed in 0.1kHz.\n"
              }
            ]
          },
          {
            "registername": "DTS_RAMPVALR",
            "offset": "0x10",
            "page": 1633,
            "chapter": "30.6.3",
            "resetvalue": "0xxxxxxxxx",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "TS1_RAMP_COEFF[15:0]",
                "description": "Engineering value of the ramp coefficient for the temperature\nsensor 1.\nThis value is expressed in Hz/Â°C.\nRM0436 Rev 7 1633/4054\n1639\nDigital temperature sensor (DTS) RM0436\n"
              }
            ]
          },
          {
            "registername": "DTS_ITR1",
            "offset": "0x14",
            "page": 1634,
            "chapter": "30.6.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "TS1_HITTHD[15:0]",
                "description": "High interrupt threshold for temperature sensor 1\nThese bits are set and cleared by software. They indicate the highest value than can be\nreached before raising an interrupt signal.\n"
              },
              {
                "range": "15:0",
                "field": "TS1_LITTHD[15:0]",
                "description": "Low interrupt threshold for temperature sensor 1\nThese bits are set and cleared by software. They indicate the lowest value than can be\nreached before raising an interrupt signal.\n"
              }
            ]
          },
          {
            "registername": "DTS_DR",
            "offset": "0x1C",
            "page": 1634,
            "chapter": "30.6.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15:0",
                "field": "TS1_MFREQ[15:0]",
                "description": "Value of the counter output value for temperature sensor 1\n1634/4054 RM0436 Rev 7\nRM0436 Digital temperature sensor (DTS)\n"
              }
            ]
          },
          {
            "registername": "DTS_SR",
            "offset": "0x20",
            "page": 1635,
            "chapter": "30.6.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:16",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "15",
                "field": "TS1_RDY",
                "description": "Temperature sensor 1 ready flag\nThis bit is set and reset by hardware.\nIt indicates that a measurement is ongoing.\n0: Temperature sensor 1 busy\n1: Temperature sensor 1 ready\n"
              },
              {
                "range": "14:7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "TS1_AITHF",
                "description": "Asynchronous interrupt flag for high threshold on temperature sensor 1\nThis bit is set by hardware when the high threshold is reached.\nIt is cleared by software by writing 1 to the TS1_CAITHF bit in the DTS_ICIFR register.\n0: High threshold not reached on temperature sensor 1\n1: High threshold reached on temperature sensor 1\nNote: This bit is active only when the TS1_AITHFEN bit is set\n"
              },
              {
                "range": "5",
                "field": "TS1_AITLF",
                "description": "Asynchronous interrupt flag for low threshold on temperature sensor 1\nThis bit is set by hardware when the low threshold is reached.\nIt is cleared by software by writing 1 to the TS1_CAITLF bit in the DTS_ICIFR register.\n0: Low threshold not reached on temperature sensor 1\n1: Low threshold reached on temperature sensor 1\nNote: This bit is active only when the TS1_AITLFEN bit is set\n"
              },
              {
                "range": "4",
                "field": "TS1_AITEF",
                "description": "Asynchronous interrupt flag for end of measure on temperature sensor 1\nThis bit is set by hardware when a temperature measure is done.\nIt is cleared by software by writing 1 to the TS1_CAITEF bit in the DTS_ICIFR register.\n0: End of measure not detected on temperature sensor 1\n1: End of measure detected on temperature sensor 1\nNote: This bit is active only when the TS1_AITEFEN bit is set\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 1635/4054\n1639\nDigital temperature sensor (DTS) RM0436\n"
              },
              {
                "range": "2",
                "field": "TS1_ITHF",
                "description": "Interrupt flag for high threshold on temperature sensor 1, synchronized on PCLK\nThis bit is set by hardware when the high threshold is set and reached.\nIt is cleared by software by writing 1 to the TS1_CITHF bit in the DTS_ICIFR register.\n0: High threshold not reached on temperature sensor 1\n1: High threshold reached on temperature sensor 1\nNote: This bit is active only when the TS1_ITHFEN bit is set\n"
              },
              {
                "range": "1",
                "field": "TS1_ITLF",
                "description": "Interrupt flag for low threshold on temperature sensor 1, synchronized on PCLK.\nThis bit is set by hardware when the low threshold is set and reached.\nIt is cleared by software by writing 1 to the TS1_CITLF bit in the DTS_ICIFR register.\n0: Low threshold not reached on temperature sensor 1\n1: Low threshold reached on temperature sensor 1\nNote: This bit is active only when the TS1_ITLFEN bit is set\n"
              },
              {
                "range": "0",
                "field": "TS1_ITEF",
                "description": "Interrupt flag for end of measurement on temperature sensor 1, synchronized on\nPCLK.\nThis bit is set by hardware when a temperature measure is done.\nIt is cleared by software by writing 1 to the TS2_CITEF bit in the DTS_ICIFR register.\n0: No end of measurement detected on temperature sensor 1\n1: End of measure detected on temperature sensor 1\nNote: This bit is active only when the TS1_ITEFEN bit is set\n"
              }
            ]
          },
          {
            "registername": "DTS_ITENR",
            "offset": "0x24",
            "page": 1636,
            "chapter": "30.6.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "TS1_AITHEN",
                "description": "Asynchronous interrupt enable flag on high threshold for temperature sensor\n1.\nThis bit are set and cleared by software.\nIt enables the asynchronous interrupt when the temperature is above the high threshold\n(only when REFCLK_SEL= 1â€™â€™)\n0: Asynchronous interrupt on high threshold disabled for temperature sensor 1\n1: Asynchronous interrupt on high threshold enabled for temperature sensor 1\n"
              },
              {
                "range": "5",
                "field": "TS1_AITLEN",
                "description": "Asynchronous interrupt enable flag for low threshold on temperature sensor 1.\nThis bit are set and cleared by software.\nIt enables the asynchronous interrupt when the temperature is below the low threshold (only\nwhen REFCLK_SEL= 1)\n0: Asynchronous interrupt on low threshold disabled for temperature sensor 1\n1: Asynchronous interrupt on low threshold enabled for temperature sensor 1\n1636/4054 RM0436 Rev 7\nRM0436 Digital temperature sensor (DTS)\n"
              },
              {
                "range": "4",
                "field": "TS1_AITEEN",
                "description": "Asynchronous interrupt enable flag for end of measurement on temperature\nsensor 1\nThis bit are set and cleared by software.\nIt enables the asynchronous interrupt for end of measurement (only when\nREFCLK_SEL=1).\n0: Asynchronous interrupt for end of measurement disabled on temperature sensor 1\n1: Asynchronous interrupt for end of measurement enabled on temperature sensor 1\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "TS1_ITHEN",
                "description": "Interrupt enable flag for high threshold on temperature sensor 1, synchronized\non PCLK.\nThis bit are set and cleared by software.\nIt enables the interrupt when the measure reaches or is above the high threshold.\n0: Synchronous interrupt for high threshold disabled on temperature sensor 1\n1: Synchronous interrupt for high threshold enabled on temperature sensor 1\n"
              },
              {
                "range": "1",
                "field": "TS1_ITLEN",
                "description": "Interrupt enable flag for low threshold on temperature sensor 1, synchronized on\nPCLK.\nThis bit are set and cleared by software.\nIt enables the synchronous interrupt when the measure reaches or is below the low\nthreshold.\n0: Synchronous interrupt for low threshold disabled on temperature sensor 1\n1: Synchronous interrupt for low threshold enabled on temperature sensor 1\n"
              },
              {
                "range": "0",
                "field": "TS1_ITEEN",
                "description": "Interrupt enable flag for end of measurement on temperature sensor 1,\nsynchronized on PCLK.\nThis bit are set and cleared by software.\nIt enables the synchronous interrupt for end of measurement.\n0: Synchronous interrupt for end of measurement disabled on temperature sensor 1\n1: Synchronous interrupt for end of measurement enabled on temperature sensor 1\n"
              }
            ]
          },
          {
            "registername": "DTS_ICIFR",
            "offset": "0x28",
            "page": 1637,
            "chapter": "30.6.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "TS1_CAITHF",
                "description": "Asynchronous interrupt clear flag for high threshold on temperature sensor 1\nWriting 1 to this bit clears the TS1_AITHF flag in the DTS_SR register.\n"
              },
              {
                "range": "5",
                "field": "TS1_CAITLF",
                "description": "Asynchronous interrupt clear flag for low threshold on temperature sensor 1\nWriting 1 to this bit clears the TS1_AITLF flag in the DTS_SR register.\nRM0436 Rev 7 1637/4054\n1639\nDigital temperature sensor (DTS) RM0436\n"
              },
              {
                "range": "4",
                "field": "TS1_CAITEF",
                "description": "Write once bit. Clear the asynchronous IT flag for End Of Measure for thermal\nsensor 1.\nWriting 1 clears the TS1_AITEF flag of the DTS_SR register.\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "TS1_CITHF",
                "description": "Interrupt clear flag for high threshold on temperature sensor 1\nWriting this bit to 1 clears the TS1_ITHF flag in the DTS_SR register.\n"
              },
              {
                "range": "1",
                "field": "TS1_CITLF",
                "description": "Interrupt clear flag for low threshold on temperature sensor 1\nWriting 1 to this bit clears the TS1_ITLF flag in the DTS_SR register.\n"
              },
              {
                "range": "0",
                "field": "TS1_CITEF",
                "description": "Interrupt clear flag for end of measurement on temperature sensor 1\nWriting 1 to this bit clears the TS1_ITEF flag in the DTS_SR register.\n"
              }
            ]
          },
          {
            "registername": "DTS_OR",
            "offset": "0x2C",
            "page": 1638,
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "TS_OP[31:0]",
                "description": "general purpose option bits\n1638/4054 RM0436 Rev 7\nRM0436 Digital temperature sensor (DTS)\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "SYSCFG registers",
        "registers": [
          {
            "registername": "SYSCFG_BOOTR",
            "offset": "0x000",
            "page": 1097,
            "chapter": "14.3.1",
            "resetvalue": "0x0000000x",
            "bits": [
              {
                "range": "31:7",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "6",
                "field": "BOOT2_PD",
                "description": "BOOT2 pin pull-down disable. This is used to save power in case the BOOT2 pin\nis connected to VDD.\n0: (enabled) pull-down enabled. The BOOT2 pin can be left open and will take a value of 0 if\nopen.\n1: (disabled) pull-down disabled. The BOOT2 pin must not be left open.\n"
              },
              {
                "range": "5",
                "field": "BOOT1_PD",
                "description": "BOOT1 pin pull-down disable. This is used to save power in case the BOOT1 pin\nis connected to VDD\n0: (enabled) pull-down enabled. The BOOT1 pin can be left open and will take a value of 0 if\nopen.\n1: (disabled) pull-down disabled. The BOOT1 pin must not be left open.\n"
              },
              {
                "range": "4",
                "field": "BOOT0_PD",
                "description": "BOOT0 pin pull-down disable. This is used to save power in case the BOOT0 pin\nis connected to VDD\n0: (enabled) pull-down enabled. The BOOT0 pin can be left open and will take a value of 0 if\nopen.\n1: (disabled) pull-down disabled. The BOOT0 pin must not be left open.\n"
              },
              {
                "range": "3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "BOOT2",
                "description": "BOOT2 pin value\n0: (low) BOOT2 pin connected to VSS (or left open if BOOT2_PD=0)\n1: (high) BOOT2 pin connected to VDD\n"
              },
              {
                "range": "1",
                "field": "BOOT1",
                "description": "BOOT1 pin value\n0: (low) BOOT1 pin connected to VSS (or left open if BOOT1_PD=0)\n1: (high) BOOT1 pin connected to VDD\n"
              },
              {
                "range": "0",
                "field": "BOOT0",
                "description": "BOOT0 pin value\n0: (low) BOOT0 pin connected to VSS (or left open if BOOT0_PD=0)\n1: (high) BOOT0 pin connected to VDD\nRM0436 Rev 7 1097/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n14.3.2 SYSCFG peripheral mode configuration set register\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_PMCSETR",
            "offset": "0x004",
            "page": 1098,
            "chapter": "14.3.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25",
                "field": "ANA1_SEL",
                "description": "controls analog connection between the ANA1 and PA1 pin.\nSet by software.\n0: Writing '0' has no effect, reading '0' means no connection. For best ADC performance the\nANA1 input must be used for package having ANA1 pin present.\n1: Writing '1' set this bit, reading '1' means ANA1 internally connected to PA1. Must only be\nused on package not having ANA1 pin.\n"
              },
              {
                "range": "24",
                "field": "ANA0_SEL",
                "description": "controls analog connection between ANA0 and PA0 pin.\nSet by software.\n0: Writing '0' has no effect, reading '0' means no connection. For best ADC performance\nANA0 input must be used for package having ANA0 pin present.\n1: Writing '1' set this bit, reading '1' means ANA0 internally connected to PA0. Must only be\nused on package not having ANA0 pin.\n"
              },
              {
                "range": "23:21",
                "field": "ETH_SEL[2:0]",
                "description": "Ethernet PHY interface selection.\nSet by software. Writing bit as '0' has no effect, set individual bits by writing â€˜1â€™, reading means\n000: GMII or MII\n001: RGMII\n010: Reserved\n011: Reserved\n100: RMII\n101: Reserved\n110: Reserved\n111: Reserved\nNote: Configuration must be done while the ETH is under reset and before enabling the ETH\nclocks\n"
              },
              {
                "range": "20",
                "field": "ETH_SELMII",
                "description": "controls MII or GMII when ETH_SEL[2:0] = 0b000.\nSet by software.\n0: (GMII) Writing '0' has no effect, reading '0' means MII/GMII clock mux controlled by ETH\nGMAC (GMII PHY use case)\n1: (MII) Writing '1' set this bit, reading '1' means MII/GMII clock mux forced in MII mode (MII\nPHY use case)\n"
              },
              {
                "range": "19:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n1098/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              },
              {
                "range": "17",
                "field": "ETH_REF_CLK_SEL",
                "description": "Ethernet 50MHz RMII clock selection.\nSet by software.\n0: Writing '0' has no effect, reading '0' means External clock is used. Need selection of\nAFMux. Could be used with all PHY\n1: Writing '1' set this bit, reading '1' means Internal clock ETH_CLK1 from RCC is used\nregardless AFMux. Could be used only with RMII PHY.\n"
              },
              {
                "range": "16",
                "field": "ETH_CLK_SEL",
                "description": "Gigabit Ethernet 125MHz clock selection. Only useful for GMII or RGMII PHY\nSet by software.\n0: Writing '0' has no effect, reading '0' means External clock is used. Need selection of AFMux\n1: Writing '1' set this bit, reading '1' means Internal clock ETH_CLK1 from RCC is used\nregardless AFMux\n"
              },
              {
                "range": "15:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "9",
                "field": "ANASWVDD",
                "description": "GPIO analog switches control voltage selection\nSet by software.\n0: Writing '0' has no effect, reading '0' means IOs analog switches supplied by VDDA\n(EN_BOOSTER=0) or Booster output (EN_BOOSTER=1)\n1: Writing '1' set this bit, reading '1' means IOs analog switches supplied by VDD (regardless\nEN_BOOSTER bit, which should be cleared to avoid unwanted power consumption). Useful\nto avoid using Booster (add current consumption) when VDDA < 2.7V, but VDD > 2.7V. When\nboth VDD < 2.7V and VDDA < 2.7V, the Booster is still needed to get full AC performances\nfrom IOs analog switches.\n"
              },
              {
                "range": "8",
                "field": "EN_BOOSTER",
                "description": "Pad Booster enable.\nSet by software.\nused to reduce the Total Harmonic Distortion of the IOs analog switches when VDDA and VDD\nsupplies are below 2.7V. Activating the booster allows to guaranty the AC performance on IOs\nanalog switches. When activated the performance of the analog switch is the same on the full\nvoltage range. This bit is only useful when ANASWVDD=0\n0: Writing '0' has no effect, reading '0' means Booster is disabled\n1: Writing '1' set this bit, reading '1' means Booster is enabled. Note that this will add a current\nconsumption on VDD\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "I2C6_FMP",
                "description": "Fast Mode Plus (FM+) enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C6 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C6 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "4",
                "field": "I2C5_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C5 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C5 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\nRM0436 Rev 7 1099/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              },
              {
                "range": "3",
                "field": "I2C4_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C4 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C4 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1MHz.\n"
              },
              {
                "range": "2",
                "field": "I2C3_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C3 usage is possible up to 400kHz\n1: Writing '1' set this bit, reading '1' means the I2C3 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "1",
                "field": "I2C2_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C2 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C2 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "0",
                "field": "I2C1_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nSet by software.\n0: Writing '0' has no effect, reading '0' means I2C1 usage is possible up to 400 kHz\n1: Writing '1' set this bit, reading '1' means the I2C1 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n14.3.3 SYSCFG peripheral mode configuration clear register\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_PMCCLRR",
            "offset": "0x044",
            "page": 1100,
            "chapter": "14.3.3",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25",
                "field": "ANA1_SEL",
                "description": "controls analog connection between the ANA1 and PA1 pin.\nCleared by software.\n0: Writing '0' has no effect, reading '0' means no connection. For best ADC performance the\nANA1 input must be used for package having ANA1 pin present.\n1: Writing '1' clear this bit, reading '1' means ANA1 internally connected to PA1. Must only be\nused on package not having ANA1 pin.\n"
              },
              {
                "range": "24",
                "field": "ANA0_SEL",
                "description": "controls analog connection between ANA0 and PA0 pin.\nCleared by software.\n0: Writing '0' has no effect, reading '0' means no connection. For best ADC performance\nANA0 input must be used for package having ANA0 pin present.\n1: Writing '1' clear this bit, reading '1' means ANA0 internally connected to PA0. Must only be\nused on package not having ANA0 pin.\n"
              },
              {
                "range": "23:21",
                "field": "ETH_SEL[2:0]",
                "description": "Ethernet PHY interface selection.\nCleared by software. Writing bit as '0' has no effect, clear individual bits by writing â€˜1â€™, reading\nmeans\n000: GMII or MII\n001: RGMII\n010: Reserved\n011: Reserved\n100: RMII\n101: Reserved\n110: Reserved\n111: Reserved\nNote: Configuration must be done while the ETH is under reset and before enabling the ETH\nclocks\n"
              },
              {
                "range": "20",
                "field": "ETH_SELMII",
                "description": "controls MII or GMII when ETH_SEL[2:0] = 0b000.\nCleared by software.\n0: (GMII) Writing '0' has no effect, reading '0' means MII/GMII clock mux controlled by ETH\nGMAC (GMII PHY use case)\n1: (MII) Writing '1' clear this bit, reading '1' means MII/GMII clock mux forced in MII mode (MII\nPHY use case)\n"
              },
              {
                "range": "19:18",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "17",
                "field": "ETH_REF_CLK_SEL",
                "description": "Ethernet 50MHz RMII clock selection.\nCleared by software.\n0: Writing '0' has no effect, reading '0' means External clock is used. Need selection of\nAFMux. Could be used with all PHY\n1: Writing '1' clear this bit, reading '1' means Internal clock ETH_CLK1 from RCC is used\nregardless AFMux. Could be used only with RMII PHY.\n"
              },
              {
                "range": "16",
                "field": "ETH_CLK_SEL",
                "description": "Gigabit Ethernet 125MHz clock selection. Only useful for GMII or RGMII PHY\nCleared by software.\n0: Writing '0' has no effect, reading '0' means External clock is used. Need selection of AFMux\n1: Writing '1' clear this bit, reading '1' means Internal clock ETH_CLK1 from RCC is used\nregardless AFMux\n"
              },
              {
                "range": "15:10",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 1101/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              },
              {
                "range": "9",
                "field": "ANASWVDD",
                "description": "GPIO analog switches control voltage selection\nCleared by software.\n0: Writing '0' has no effect, reading '0' means IOs analog switches supplied by VDDA\n(EN_BOOSTER=0) or Booster output (EN_BOOSTER=1)\n1: Writing '1' clear this bit, reading '1' means IOs analog switches supplied by VDD (regardless\nEN_BOOSTER bit, which should be cleared to avoid unwanted power consumption). Useful\nto avoid using Booster (add current consumption) when VDDA < 2.7V, but VDD > 2.7V.\n"
              },
              {
                "range": "8",
                "field": "EN_BOOSTER",
                "description": "Pad Booster enable.\nCleared by software.\nused to reduce the Total Harmonic Distortion of the IOs analog switches when VDDA and VDD\nsupplies are below 2.7V. Activating the booster allows to guaranty the AC performance on IOs\nanalog switches. When activated the performance of the analog switch is the same on the full\nvoltage range. This bit is only useful when ANASWVDD=0\n0: Writing '0' has no effect, reading '0' means Booster is disabled\n1: Writing '1' clear this bit, reading '1' means Booster is enabled. Note that this will add a\ncurrent consumption on VDD.\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "I2C6_FMP",
                "description": "Fast Mode Plus (FM+) enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C6 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C6 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "4",
                "field": "I2C5_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C5 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C5 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "3",
                "field": "I2C4_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C4 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C4 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1MHz.\n1102/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              },
              {
                "range": "2",
                "field": "I2C3_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C3 usage is possible up to 400kHz\n1: Writing '1' clear this bit, reading '1' means the I2C3 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "1",
                "field": "I2C2_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C2 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C2 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              },
              {
                "range": "0",
                "field": "I2C1_FMP",
                "description": "Fast Mode Plus (FM+) Enable\nCleared by software.\n0: Writing '0' has no effect, reading '0' means I2C1 usage is possible up to 400 kHz\n1: Writing '1' clear this bit, reading '1' means the I2C1 SCL & SDA pads in Fast Mode Plus\n(FM+), as soon as the correspondent alternate function is selected. The pad low drive is\nenhanced to allow usage up to 1 MHz.\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_IOCTRLSETR",
            "offset": "0x018",
            "page": 1103,
            "chapter": "14.3.4",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "HSLVEN_SPI",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a SPIy_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "3",
                "field": "HSLVEN_SDMMC",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a SDMMCy_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\nRM0436 Rev 7 1103/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              },
              {
                "range": "2",
                "field": "HSLVEN_ETH",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a ETH_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "1",
                "field": "HSLVEN_QUADSPI",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a QUADSPI_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "0",
                "field": "HSLVEN_TRACE",
                "description": "High Speed Low Voltage Pad mode Enable.\nSet by software.\nControls the speed of _h and _e pads when a TRACEx signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' enables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n1. This bit is not taken into account if the OTP bit (product_below_2V5) is 0 (default)\n2. Enabling High Speed mode while VDD > 2.7V can damage the IC. See pad characteristics for details.\nDanger: Enabling High Speed mode while VDD > 2.7V can damage the\nIC.\nSee pad characteristics for details\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_IOCTRLCLRR",
            "offset": "0x058",
            "page": 1104,
            "chapter": "14.3.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4",
                "field": "HSLVEN_SPI",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a SPIy_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "3",
                "field": "HSLVEN_SDMMC",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a SDMMCy_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "2",
                "field": "HSLVEN_ETH",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a ETH_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "1",
                "field": "HSLVEN_QUADSPI",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a QUADSPI_x signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n"
              },
              {
                "range": "0",
                "field": "HSLVEN_TRACE",
                "description": "High Speed Low Voltage Pad mode Enable.\nCleared by software.\nControls the speed of _h and _e pads when a TRACEx signal is selected in AFMUX.\n0: Writing '0' has no effect, reading '0' means High Speed mode disabled\n1: Writing '1' disables High Speed mode, reading '1' means High Speed mode enabled(1)(2)\n1. This bit is not taken into account if the OTP bit (product_below_2V5) is 0 (default)\n2. Enabling High Speed mode while VDD > 2.7V can damage the IC. See pad characteristics for details.\nDanger: Enabling High Speed mode while VDD > 2.7V can damage the\nIC.\nSee pad characteristics for details\nRM0436 Rev 7 1105/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_ICNR",
            "offset": "0x01C",
            "page": 1106,
            "chapter": "14.3.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10",
                "field": "AXI_M10",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "9",
                "field": "AXI_M9",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "8",
                "field": "AXI_M8",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "7",
                "field": "AXI_M7",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "6",
                "field": "AXI_M6",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "5",
                "field": "AXI_M5",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3",
                "field": "AXI_M3",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n1106/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              },
              {
                "range": "2",
                "field": "AXI_M2",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "1",
                "field": "AXI_M1",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\n"
              },
              {
                "range": "0",
                "field": "AXI_M0",
                "description": "controls which slave port is used by the master to access the DDR. Allows the\nperformance/latency tuning\n0: (S0) Master access DDR through Slave S0\n1: (S1) Master access DDR through Slave S1\nRM0436 Rev 7 1107/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_CMPCR",
            "offset": "0x020",
            "page": 1108,
            "chapter": "14.3.7",
            "resetvalue": "0xxx870000",
            "bits": [
              {
                "range": "31:28",
                "field": "APSRC[3:0]",
                "description": "PMOS I/O Compensation value provided by compensation cell.\nValue sent to IOs compensation when SW_CTRL = 0 and READY = 1\n"
              },
              {
                "range": "27:24",
                "field": "ANSRC[3:0]",
                "description": "NMOS I/O Compensation value provided by compensation cell.\nValue sent to IOs when SW_CTRL = 0 and READY = 1\n"
              },
              {
                "range": "23:20",
                "field": "RAPSRC[3:0]",
                "description": "PMOS I/O Compensation value sent to IOs when SW_CTRL = 1\n0000: reserved\n0001: maximum compensation of fast conditions\n....\n1000: compensation for typical conditions\n....\n1110: maximum compensation of slow conditions\n1111: reserved\nNote: If compensation is needed, it is recommended to use automatic compensation\n"
              },
              {
                "range": "19:16",
                "field": "RANSRC[3:0]",
                "description": "NMOS I/O Compensation value sent to IOs when SW_CTRL = 1\n0000: reserved\n0001: maximum compensation of slow conditions\n....\n0111: compensation for typical conditions\n....\n1110: maximum compensation of fast conditions\n1111: reserved\nNote: If compensation is needed, it is recommended to use automatic compensation\n"
              },
              {
                "range": "15:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8",
                "field": "READY",
                "description": "Compensation cell ready flag\n0: I/O compensation cell not ready.\n1: I/O compensation cell ready, the values of APSRC[3:0] and ANSRC[3:0] are valid\n"
              },
              {
                "range": "7:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "SW_CTRL",
                "description": "Compensation Software Control\n0: IO compensation values come from compensation values in ANSRC[3:0] and APSRC[3:0]\n1: IO compensation values come from RANSRC[3:0] and RAPSRC[3:0] register values\nNote: SW_CTRL = 0 is not taken into account until READY = 1.\nThis means that whenever SW_CTRL, the RANSRC[3:0] and RAPSRC[3:0] are used for\nIO compensation when the compensation cell is in power down (MCU_EN=0 and\nMPU_EN=0, which is the case after a reset).\n"
              },
              {
                "range": "0",
                "field": "Reserved",
                "description": "must be kept at reset value.\n1108/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n14.3.8 SYSCFG compensation cell enable set register\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_CMPENSETR",
            "offset": "0x024",
            "page": 1109,
            "chapter": "14.3.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "MCU_EN",
                "description": "Compensation cell enable\nSet by software.\n0: (power_down) Writing '0' has no effect, reading â€˜0â€™ mean I/O compensation cell in power-\ndown mode if MPU_EN=0\n1: (enabled) Writing '1' enable I/O compensation cell, reading â€˜1â€™ mean /O compensation cell\nis enabled\nNote: The CSI oscillator must be enabled and ready (controlled in RCC) before MPU_EN could\nbe set to 1. Similarly, the CSI oscillator could be disabled only if MPU_EN and MCU_EN\nare set to 0.\n"
              },
              {
                "range": "0",
                "field": "MPU_EN",
                "description": "Compensation cell enable\nSet by software.\n0: (power_down) Writing '0' has no effect, reading â€˜0â€™ mean I/O compensation cell in power-\ndown mode if MCU_EN=0\n1: (enabled) Writing '1' enable I/O compensation cell, reading â€˜1â€™ mean /O compensation cell\nis enabled\nNote: The CSI oscillator must be enabled and ready (controlled in RCC) before MPU_EN could\nbe set to 1. Similarly, the CSI oscillator could be disabled only if MPU_EN and MCU_EN\nare set to 0.\nRM0436 Rev 7 1109/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n14.3.9 SYSCFG compensation cell enable clear register\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_CMPENCLRR",
            "offset": "0x028",
            "page": 1110,
            "chapter": "14.3.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "MCU_EN",
                "description": "Compensation cell enable\nCleared by software.\n0: (power_down) Writing '0' has no effect, reading â€˜0â€™ mean I/O compensation cell in power-\ndown mode if MPU_EN=0\n1: (enabled) Writing '1' clear MCU_EN bit, reading â€˜1â€™ mean /O compensation cell is enabled\nNote: The CSI oscillator must be enabled and ready (controlled in RCC) before MPU_EN could\nbe set to 1. Similarly, the CSI oscillator could be disabled only if MPU_EN and MCU_EN\nare set to 0.\n"
              },
              {
                "range": "0",
                "field": "MPU_EN",
                "description": "Compensation cell enable\nCleared by software.\n0: (power_down) Writing '0' has no effect, reading â€˜0â€™ mean I/O compensation cell in\npowerdown mode if MCU_EN=0\n1: (enabled) Writing '1' clear MPU_EN bit, reading â€˜1â€™ mean /O compensation cell is enabled\nNote: The CSI oscillator must be enabled and ready (controlled in RCC) before MPU_EN could\nbe set to 1. Similarly, the CSI oscillator could be disabled only if MPU_EN and MCU_EN\nare set to 0.\n1110/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_CBR",
            "offset": "0x02C",
            "page": 1111,
            "chapter": "14.3.10",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:3",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "2",
                "field": "PVDL",
                "description": "PVD lock enable bit\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock\nthe PVD connection to TIM1/8/15/16/17 Break input, as well as the PVDE and PLS[2:0] in the\nPWR_CR1 register.\n0: PVD interrupt disconnected from TIM1/8/15/16/17 Break input. PVDE and PLS[2:0] bits can\nbe programmed by the application.\n1: PVD interrupt connected to TIM1/8/15/16/17 Break input. PVDE and PLS[2:0] bits are read\nonly.\n"
              },
              {
                "range": "1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "CLL",
                "description": "Cortex-M4 LOCKUP (Hardfault) output enable bit\nThis bit is set by software and cleared only by a system reset. It can be used to enable and lock\nthe connection of Cortex-M4 LOCKUP (Hardfault) output to TIM1/8/15/16/17 Break input\n0: Cortex-M4 LOCKUP output disconnected from TIM1/8/15/16/17 Break inputs\n1: Cortex-M4 LOCKUP output connected to TIM1/8/15/16/17 Break inputs\nRM0436 Rev 7 1111/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_VERR",
            "offset": "0x03F4",
            "page": 1112,
            "chapter": "14.3.11",
            "resetvalue": "0x00000020",
            "bits": [
              {
                "range": "31:8",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "7:4",
                "field": "MAJREV[3:0]",
                "description": "Major revision\nThese bits return the SYSCFG major revision.\nMajor revision is 2.\n"
              },
              {
                "range": "3:0",
                "field": "MINREV[3:0]",
                "description": "Minor revision\nThese bits return the SYSCFG minor revision.\nMinor revision is 0.\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_IPIDR",
            "offset": "0x03F8",
            "page": 1112,
            "chapter": "14.3.12",
            "resetvalue": "0x00030001",
            "bits": [
              {
                "range": "31:0",
                "field": "ID[31:0]",
                "description": "SYSCFG identifier\nThese bits return the SYSCFG identifier value.\n1112/4054 RM0436 Rev 7\nRM0436 System configuration controller (SYSCFG)\n"
              }
            ]
          },
          {
            "registername": "SYSCFG_SIDR",
            "offset": "0x03FC",
            "page": 1113,
            "resetvalue": "0xa3c5dd01",
            "bits": [
              {
                "range": "31:0",
                "field": "SID[31:0]",
                "description": "Size identification\nThese bits return the size of the memory region allocated to SYSCFG registers.\nRM0436 Rev 7 1113/4054\n1115\nSystem configuration controller (SYSCFG) RM0436\n"
              }
            ]
          }
        ]
      },
      {
        "mapname": "ADC registers (for each ADC)",
        "registers": [
          {
            "registername": "ADC_ISR",
            "offset": "0x00",
            "page": 1577,
            "chapter": "29.6.1",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:13",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "12",
                "field": "LDORDY",
                "description": "ADC LDO output voltage ready bit\nThis bit is set and cleared by hardware. It indicates that the ADC internal LDO output is ready and\nthat the ADC can be enabled or calibrated.\n0: ADC LDO voltage regulator disabled\n1: ADC LDO voltage regulator enabled\nNote: Refer to Section29.3: ADC implementation for the availability of the LDO regulator.\n"
              },
              {
                "range": "11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10",
                "field": "JQOVF",
                "description": "Injected context queue overflow\nThis bit is set by hardware when an Overflow of the Injected Queue of Context occurs. It is cleared\nby software writing 1 to it. Refer to Section29.4.22: Queue of context for injected conversions for\nmore information.\n0: No injected context queue overflow occurred (or the flag event was already acknowledged and\ncleared by software)\n1: Injected context queue overflow has occurred\n"
              },
              {
                "range": "9",
                "field": "AWD3",
                "description": "Analog watchdog 3 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in the fields\nLT3[7:0] and HT3[7:0] of ADC_TR3 register. It is cleared by software writing 1 to it.\n0: No analog watchdog 3 event occurred (or the flag event was already acknowledged and cleared\nby software)\n1: Analog watchdog 3 event occurred\n"
              },
              {
                "range": "8",
                "field": "AWD2",
                "description": "Analog watchdog 2 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in the fields\nLT2[7:0] and HT2[7:0] of ADC_TR2 register. It is cleared by software writing 1 to it.\n0: No analog watchdog 2 event occurred (or the flag event was already acknowledged and cleared\nby software)\n1: Analog watchdog 2 event occurred\nRM0436 Rev 7 1577/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "7",
                "field": "AWD1",
                "description": "Analog watchdog 1 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in the fields\nLT1[11:0] and HT1[11:0] of ADC_TR1 register. It is cleared by software. writing 1 to it.\n0: No analog watchdog 1 event occurred (or the flag event was already acknowledged and cleared\nby software)\n1: Analog watchdog 1 event occurred\n"
              },
              {
                "range": "6",
                "field": "JEOS",
                "description": "Injected channel end of sequence flag\nThis bit is set by hardware at the end of the conversions of all injected channels in the group. It is\ncleared by software writing 1 to it.\n0: Injected conversion sequence not complete (or the flag event was already acknowledged and\ncleared by software)\n1: Injected conversions complete\n"
              },
              {
                "range": "5",
                "field": "JEOC",
                "description": "Injected channel end of conversion flag\nThis bit is set by hardware at the end of each injected conversion of a channel when a new data is\navailable in the corresponding ADC_JDRy register. It is cleared by software writing 1 to it or by\nreading the corresponding ADC_JDRy register\n0: Injected channel conversion not complete (or the flag event was already acknowledged and\ncleared by software)\n1: Injected channel conversion complete\n"
              },
              {
                "range": "4",
                "field": "OVR",
                "description": "ADC overrun\nThis bit is set by hardware when an overrun occurs on a regular channel, meaning that a new\nconversion has completed while the EOC flag was already set. It is cleared by software writing 1 to\nit.\n0: No overrun occurred (or the flag event was already acknowledged and cleared by software)\n1: Overrun has occurred\n"
              },
              {
                "range": "3",
                "field": "EOS",
                "description": "End of regular sequence flag\nThis bit is set by hardware at the end of the conversions of a regular sequence of channels. It is\ncleared by software writing 1 to it.\n0: Regular Conversions sequence not complete (or the flag event was already acknowledged and\ncleared by software)\n1: Regular Conversions sequence complete\n1578/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "2",
                "field": "EOC",
                "description": "End of conversion flag\nThis bit is set by hardware at the end of each regular conversion of a channel when a new data is\navailable in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR\nregister\n0: Regular channel conversion not complete (or the flag event was already acknowledged and\ncleared by software)\n1: Regular channel conversion complete\n"
              },
              {
                "range": "1",
                "field": "EOSMP",
                "description": "End of sampling flag\nThis bit is set by hardware during the conversion of any channel (only for regular channels), at the\nend of the sampling phase.\n0: not at the end of the sampling phase (or the flag event was already acknowledged and cleared by\nsoftware)\n1: End of sampling phase reached\n"
              },
              {
                "range": "0",
                "field": "ADRDY",
                "description": "ADC ready\nThis bit is set by hardware after the ADC has been enabled (bit ADEN=1) and when the ADC\nreaches a state where it is ready to accept conversion requests.\nIt is cleared by software writing 1 to it.\n0: ADC not yet ready to start conversion (or the flag event was already acknowledged and cleared\nby software)\n1: ADC is ready to start conversion\nRM0436 Rev 7 1579/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_IER",
            "offset": "0x04",
            "page": 1580,
            "chapter": "29.6.2",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10",
                "field": "JQOVFIE",
                "description": "Injected context queue overflow interrupt enable\nThis bit is set and cleared by software to enable/disable the Injected Context Queue Overflow\ninterrupt.\n0: Injected Context Queue Overflow interrupt disabled\n1: Injected Context Queue Overflow interrupt enabled. An interrupt is generated when the JQOVF bit\nis set.\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\n"
              },
              {
                "range": "9",
                "field": "AWD3IE",
                "description": "Analog watchdog 3 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt.\n0: Analog watchdog 3 interrupt disabled\n1: Analog watchdog 3 interrupt enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "8",
                "field": "AWD2IE",
                "description": "Analog watchdog 2 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog 2 interrupt.\n0: Analog watchdog 2 interrupt disabled\n1: Analog watchdog 2 interrupt enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "7",
                "field": "AWD1IE",
                "description": "Analog watchdog 1 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog 1 interrupt.\n0: Analog watchdog 1 interrupt disabled\n1: Analog watchdog 1 interrupt enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "6",
                "field": "JEOSIE",
                "description": "End of injected sequence of conversions interrupt enable\nThis bit is set and cleared by software to enable/disable the end of injected sequence of conversions\ninterrupt.\n0: JEOS interrupt disabled\n1: JEOS interrupt enabled. An interrupt is generated when the JEOS bit is set.\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\n1580/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "5",
                "field": "JEOCIE",
                "description": "End of injected conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of an injected conversion interrupt.\n0: JEOC interrupt disabled.\n1: JEOC interrupt enabled. An interrupt is generated when the JEOC bit is set.\nNote: The software is allowed to write this bit only when JADSTART is cleared to 0 (no injected\nconversion is ongoing).\n"
              },
              {
                "range": "4",
                "field": "OVRIE",
                "description": "Overrun interrupt enable\nThis bit is set and cleared by software to enable/disable the Overrun interrupt of a regular\nconversion.\n0: Overrun interrupt disabled\n1: Overrun interrupt enabled. An interrupt is generated when the OVR bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "3",
                "field": "EOSIE",
                "description": "End of regular sequence of conversions interrupt enable\nThis bit is set and cleared by software to enable/disable the end of regular sequence of conversions\ninterrupt.\n0: EOS interrupt disabled\n1: EOS interrupt enabled. An interrupt is generated when the EOS bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "2",
                "field": "EOCIE",
                "description": "End of regular conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of a regular conversion interrupt.\n0: EOC interrupt disabled.\n1: EOC interrupt enabled. An interrupt is generated when the EOC bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "1",
                "field": "EOSMPIE",
                "description": "End of sampling flag interrupt enable for regular conversions\nThis bit is set and cleared by software to enable/disable the end of the sampling phase interrupt for\nregular conversions.\n0: EOSMP interrupt disabled.\n1: EOSMP interrupt enabled. An interrupt is generated when the EOSMP bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "0",
                "field": "ADRDYIE",
                "description": "ADC ready interrupt enable\nThis bit is set and cleared by software to enable/disable the ADC Ready interrupt.\n0: ADRDY interrupt disabled\n1: ADRDY interrupt enabled. An interrupt is generated when the ADRDY bit is set.\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nRM0436 Rev 7 1581/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_CR",
            "offset": "0x08",
            "page": 1582,
            "chapter": "29.6.3",
            "resetvalue": "0x20000000",
            "bits": [
              {
                "range": "31",
                "field": "ADCAL",
                "description": "ADC calibration\nThis bit is set by software to start the calibration of the ADC. Program first the bit ADCALDIF to\ndetermine if this calibration applies for single-ended or differential inputs mode.\nIt is cleared by hardware after calibration is complete.\n0: Calibration complete\n1: Write 1 to calibrate the ADC. Read at 1 means that a calibration in progress.\nNote: The software is allowed to launch a calibration by setting ADCAL only when ADEN=0.\nThe software is allowed to update the calibration factor by writing ADC_CALFACT only when\nADEN=1 and ADSTART=0 and JADSTART=0 (ADC enabled and no conversion is ongoing)\n"
              },
              {
                "range": "30",
                "field": "ADCALDIF",
                "description": "Differential mode for calibration\nThis bit is set and cleared by software to configure the single-ended or differential inputs mode for\nthe calibration.\n0: Writing ADCAL launches a calibration in single-ended inputs mode.\n1: Writing ADCAL launches a calibration in differential inputs mode.\nNote: The software is allowed to write this bit only when the ADC is disabled and is not calibrating\n(ADCAL=0, JADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n"
              },
              {
                "range": "29",
                "field": "DEEPPWD",
                "description": "Deep-power-down enable\nThis bit is set and cleared by software to put the ADC in deep-power-down mode.\n0: ADC not in deep-power down\n1: ADC in deep-power-down (default reset state)\nNote: The software is allowed to write this bit only when the ADC is disabled (ADCAL=0,\nJADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n"
              },
              {
                "range": "28",
                "field": "ADVREGEN",
                "description": "ADC voltage regulator enable\nThis bits is set by software to enable the ADC voltage regulator.\nBefore performing any operation such as launching a calibration or enabling the ADC, the ADC\nvoltage regulator must first be enabled and the software must wait for the regulator start-up time.\n0: ADC Voltage regulator disabled\n1: ADC Voltage regulator enabled.\nFor more details about the ADC voltage regulator enable and disable sequences, refer to\nSection29.4.6: ADC deep-power-down mode (DEEPPWD) and ADC voltage regulator\n(ADVREGEN).\nThe software can program this bitfield only when the ADC is disabled (ADCAL=0, JADSTART=0,\nADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n1582/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "27",
                "field": "LINCALRDYW6",
                "description": "Linearity calibration ready Word 6\nThis control / status bit allows to read/write the 6th linearity calibration factor.\nWhen the linearity calibration is complete, this bit is set. A bit clear launches the transfer of the\nlinearity factor 6 into the LINCALFACT[29:0] of the ADC_CALFACT2 register. The bit is reset by\nhardware when the ADC_CALFACT2 register can be read (software must poll the bit until it is\ncleared).\nWhen the LINCALRDYW6 bit is reset, a new linearity factor 6 value can be written into the\nLINCALFACT[29:0] of the ADC_CALFACT2 register. A bit set launches the linearity factor 6 update\nand the bit is effectively set by hardware once the update is done (software must poll the bit until it is\nset to indicate the write is effective).\nNote: ADC_CALFACT2[29:10] contains 0. ADC_CALFACT2[9:0] corresponds linearity correction\nfactor bits[159:150].\nThe software is allowed to toggle this bit only if the LINCALRDYW5, LINCALRDYW4,\nLINCALRDYW3, LINCALRDYW2 and LINCALRDYW1 bits are left unchanged, see chapter\n29.4.8: Calibration (ADCAL, ADCALDIF, ADCALLIN, ADC_CALFACT) for details.\nThe software is allowed to update the linearity calibration factor by writing LINCALRDYWx only\nwhen ADEN=1 and ADSTART=0 and JADSTART=0 (ADC enabled and no conversion is\nongoing)\n"
              },
              {
                "range": "26",
                "field": "LINCALRDYW5",
                "description": "Linearity calibration ready Word 5\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] corresponds linearity correction factor bits[149:120].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW3, LINCALRDYW2 and LINCALRDYW1 bits are left unchanged.\n"
              },
              {
                "range": "25",
                "field": "LINCALRDYW4",
                "description": "Linearity calibration ready Word 4\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] correspond linearity correction factor bits[119:90].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW3, LINCALRDYW2 and LINCALRDYW1 bits are left unchanged.\n"
              },
              {
                "range": "24",
                "field": "LINCALRDYW3",
                "description": "Linearity calibration ready Word 3\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] corresponds linearity correction factor bits[89:60].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW4, LINCALRDYW2 and LINCALRDYW1 bits are left unchanged.\n"
              },
              {
                "range": "23",
                "field": "LINCALRDYW2",
                "description": "Linearity calibration ready Word 2\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] corresponds linearity correction factor bits[59:30].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW4, LINCALRDYW3 and LINCALRDYW1 bits are left unchanged.\n"
              },
              {
                "range": "22",
                "field": "LINCALRDYW1",
                "description": "Linearity calibration ready Word 1\nRefer to LINCALRDYW6 description.\nNote: ADC_CALFACT2[29:0] corresponds linearity correction factor bits[29:0].\nThe software is allowed to toggle this bit only if the LINCALRDYW6, LINCALRDYW5,\nLINCALRDYW4, LINCALRDYW3 and LINCALRDYW2 bits are left unchanged.\n"
              },
              {
                "range": "21:17",
                "field": "Reserved",
                "description": "must be kept at reset value.\nRM0436 Rev 7 1583/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "16",
                "field": "ADCALLIN",
                "description": "Linearity calibration\nThis bit is set and cleared by software to enable the Linearity calibration.\n0: Writing ADCAL launches a calibration without the Linearity calibration.\n1: Writing ADCAL launches a calibration with he Linearity calibration.\nNote: The software is allowed to write this bit only when the ADC is disabled and is not calibrating\n(ADCAL=0, JADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n"
              },
              {
                "range": "15:9",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "8",
                "field": "BOOST",
                "description": "Boost mode control\nThis bit is set and cleared by software to enable/disable the boost mode.\n0: Boost mode off. Used when ADC clock < 20MHz to save power at lower clock frequency.\n1: Boost mode on. Must be used when ADC clock > 20MHz.\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nWhen dual mode is enabled (bits DAMDF of ADC_CCR register are not equal to zero), the bit\nBOOST of the slave ADC is no more writable and its content must be equal to the master ADC\nBOOST bit.\n"
              },
              {
                "range": "7:6",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "5",
                "field": "JADSTP",
                "description": "ADC stop of injected conversion command\nThis bit is set by software to stop and discard an ongoing injected conversion (JADSTP Command).\nIt is cleared by hardware when the conversion is effectively discarded and the ADC injected\nsequence and triggers can be re-configured. The ADC is then ready to accept a new start of injected\nconversions (JADSTART command).\n0: No ADC stop injected conversion command ongoing\n1: Write 1 to stop injected conversions ongoing. Read 1 means that an ADSTP command is in\nprogress.\nNote: The software is allowed to set JADSTP only when JADSTART=1 and ADDIS=0 (ADC is\nenabled and eventually converting an injected conversion and there is no pending request to\ndisable the ADC).\nIn auto-injection mode (JAUTO=1), setting ADSTP bit aborts both regular and injected\nconversions (do not use JADSTP)\n"
              },
              {
                "range": "4",
                "field": "ADSTP",
                "description": "ADC stop of regular conversion command\nThis bit is set by software to stop and discard an ongoing regular conversion (ADSTP Command).\nIt is cleared by hardware when the conversion is effectively discarded and the ADC regular\nsequence and triggers can be re-configured. The ADC is then ready to accept a new start of regular\nconversions (ADSTART command).\n0: No ADC stop regular conversion command ongoing\n1: Write 1 to stop regular conversions ongoing. Read 1 means that an ADSTP command is in\nprogress.\nNote: The software is allowed to set ADSTP only when ADSTART=1 and ADDIS=0 (ADC is enabled\nand eventually converting a regular conversion and there is no pending request to disable the\nADC).\nIn auto-injection mode (JAUTO=1), setting ADSTP bit aborts both regular and injected\nconversions (do not use JADSTP).\nIn dual ADC regular simultaneous mode and interleaved mode, the bit ADSTP of the master\nADC must be used to stop regular conversions. The other ADSTP bit is inactive.\n1584/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "3",
                "field": "JADSTART",
                "description": "ADC start of injected conversion\nThis bit is set by software to start ADC conversion of injected channels. Depending on the\nconfiguration bits JEXTEN, a conversion starts immediately (software trigger configuration) or once\nan injected hardware trigger event occurs (hardware trigger configuration).\nIt is cleared by hardware:\nâ€“ in single conversion mode when software trigger is selected (JEXTSEL=0x0): at the\nassertion of the End of Injected Conversion Sequence (JEOS) flag.\nâ€“ in all cases: after the execution of the JADSTP command, at the same time that JADSTP is\ncleared by hardware.\n0: No ADC injected conversion is ongoing.\n1: Write 1 to start injected conversions. Read 1 means that the ADC is operating and eventually\nconverting an injected channel.\nNote: The software is allowed to set JADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled\nand there is no pending request to disable the ADC).\nIn auto-injection mode (JAUTO=1), regular and auto-injected conversions are started by setting\nbit ADSTART (JADSTART must be kept cleared)\nRM0436 Rev 7 1585/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "2",
                "field": "ADSTART",
                "description": "ADC start of regular conversion\nThis bit is set by software to start ADC conversion of regular channels. Depending on the\nconfiguration bits EXTEN, a conversion starts immediately (software trigger configuration) or once a\nregular hardware trigger event occurs (hardware trigger configuration).\nIt is cleared by hardware:\nâ€“ in single conversion mode (CONT=0, DISCEN=0) when software trigger is selected\n(EXTEN=0x0): at the assertion of the End of Regular Conversion Sequence (EOS) flag.\nâ€“ In discontinuous conversion mode (CONT=0, DISCEN=1), when the software trigger is\nselected (EXTEN=0x0): at the end of conversion (EOC) flag.\nâ€“ in all other cases: after the execution of the ADSTP command, at the same time that\nADSTP is cleared by hardware.\n0: No ADC regular conversion is ongoing.\n1: Write 1 to start regular conversions. Read 1 means that the ADC is operating and eventually\nconverting a regular channel.\nNote: The software is allowed to set ADSTART only when ADEN=1 and ADDIS=0 (ADC is enabled\nand there is no pending request to disable the ADC)\nIn auto-injection mode (JAUTO=1), regular and auto-injected conversions are started by setting\nbit ADSTART (JADSTART must be kept cleared)\n"
              },
              {
                "range": "1",
                "field": "ADDIS",
                "description": "ADC disable command\nThis bit is set by software to disable the ADC (ADDIS command) and put it into power-down state\n(OFF state).\nIt is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at\nthis time).\n0: no ADDIS command ongoing\n1: Write 1 to disable the ADC. Read 1 means that an ADDIS command is in progress.\nNote: The software is allowed to set ADDIS only when ADEN=1 and both ADSTART=0 and\nJADSTART=0 (which ensures that no conversion is ongoing)\n"
              },
              {
                "range": "0",
                "field": "ADEN",
                "description": "ADC enable control\nThis bit is set by software to enable the ADC. The ADC is effectively ready to operate once the flag\nADRDY has been set.\nIt is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.\n0: ADC is disabled (OFF state)\n1: Write 1 to enable the ADC.\nNote: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL=0,\nJADSTART=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0) except for bit ADVREGEN\nwhich must be 1 (and the software must have wait for the startup time of the voltage regulator)\n1586/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_CFGR",
            "offset": "0x0C",
            "page": 1587,
            "chapter": "29.6.4",
            "resetvalue": "0x80000000",
            "bits": [
              {
                "range": "31",
                "field": "JQDIS",
                "description": "Injected Queue disable\nThese bits are set and cleared by software to disable the Injected Queue mechanism:\n0: Injected Queue enabled\n1: Injected Queue disabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no regular nor injected conversion is ongoing).\nA set or reset of JQDIS bit causes the injected queue to be flushed and the ADC_JSQR register\nis cleared.\n"
              },
              {
                "range": "30:26",
                "field": "AWD1CH[4:0]",
                "description": "Analog watchdog 1 channel selection\nThese bits are set and cleared by software. They select the input channel to be guarded by the\nanalog watchdog.\n00000: ADC analog input channel-0 monitored by AWD1\n00001: ADC analog input channel-1 monitored by AWD1\n.....\n10010: ADC analog input channel-19 monitored by AWD1\nothers: Reserved, must not be used\nNote: The channel selected by AWD1CH must be also selected into the SQi or JSQi bits.\nThe software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "25",
                "field": "JAUTO",
                "description": "Automatic injected group conversion\nThis bit is set and cleared by software to enable/disable automatic injected group conversion after\nregular group conversion.\n0: Automatic injected group conversion disabled\n1: Automatic injected group conversion enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no regular nor injected conversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nJAUTO of the slave ADC is no more writable and its content is equal to the bit JAUTO of the\nmaster ADC.\n"
              },
              {
                "range": "24",
                "field": "JAWD1EN",
                "description": "Analog watchdog 1 enable on injected channels\nThis bit is set and cleared by software\n0: Analog watchdog 1 disabled on injected channels\n1: Analog watchdog 1 enabled on injected channels\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\nRM0436 Rev 7 1587/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "23",
                "field": "AWD1EN",
                "description": "Analog watchdog 1 enable on regular channels\nThis bit is set and cleared by software\n0: Analog watchdog 1 disabled on regular channels\n1: Analog watchdog 1 enabled on regular channels\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "22",
                "field": "AWD1SGL",
                "description": "Enable the watchdog 1 on a single channel or on all channels\nThis bit is set and cleared by software to enable the analog watchdog on the channel identified by\nthe AWD1CH[4:0] bits or on all the channels\n0: Analog watchdog 1 enabled on all channels\n1: Analog watchdog 1 enabled on a single channel\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "21",
                "field": "JQM",
                "description": "ADC_JSQR queue mode\nThis bit is set and cleared by software.\nIt defines how an empty Queue is managed.\n0: ADC_JSQR Mode 0: The Queue is never empty and maintains the last written configuration into\nADC_JSQR.\n1: ADC_JSQR Mode 1: The Queue can be empty and when this occurs, the software and hardware\ntriggers of the injected sequence are both internally disabled just after the completion of the last valid\ninjected sequence.\nRefer to Section29.4.22: Queue of context for injected conversions for more information.\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nJQM of the slave ADC is no more writable and its content is equal to the bit JQM of the master\nADC.\n"
              },
              {
                "range": "20",
                "field": "JDISCEN",
                "description": "Discontinuous mode on injected channels\nThis bit is set and cleared by software to enable/disable discontinuous mode on the injected\nchannels of a group.\n0: Discontinuous mode on injected channels disabled\n1: Discontinuous mode on injected channels enabled\nNote: The software is allowed to write this bit only when JADSTART=0 (which ensures that no\ninjected conversion is ongoing).\nIt is not possible to use both auto-injected mode and discontinuous mode simultaneously: the\nbits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set.\nWhen dual mode is enabled (bits DAMDF of ADC_CCR register are not equal to zero), the bit\nJDISCEN of the slave ADC is no more writable and its content is equal to the bit JDISCEN of\nthe master ADC.\n1588/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "19:17",
                "field": "DISCNUM[2:0]",
                "description": "Discontinuous mode channel count\nThese bits are written by software to define the number of regular channels to be converted in\ndiscontinuous mode, after receiving an external trigger.\n000: 1 channel\n001: 2 channels\n...\n111: 8 channels\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that no\nregular conversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bits\nDISCNUM[2:0] of the slave ADC are no more writable and their content is equal to the bits\nDISCNUM[2:0] of the master ADC.\n"
              },
              {
                "range": "16",
                "field": "DISCEN",
                "description": "Discontinuous mode for regular channels\nThis bit is set and cleared by software to enable/disable discontinuous mode for regular channels.\n0: Discontinuous mode for regular channels disabled\n1: Discontinuous mode for regular channels enabled\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden\nto set both DISCEN=1 and CONT=1.\nIt is not possible to use both auto-injected mode and discontinuous mode simultaneously: the\nbits DISCEN and JDISCEN must be kept cleared by software when JAUTO is set.\nThe software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nDISCEN of the slave ADC is no more writable and its content is equal to the bit DISCEN of the\nmaster ADC.\n"
              },
              {
                "range": "15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14",
                "field": "AUTDLY",
                "description": "Delayed conversion mode\nThis bit is set and cleared by software to enable/disable the Auto Delayed Conversion mode..\n0: Auto-delayed conversion mode off\n1: Auto-delayed conversion mode on\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nAUTDLY of the slave ADC is no more writable and its content is equal to the bit AUTDLY of the\nmaster ADC.\n"
              },
              {
                "range": "13",
                "field": "CONT",
                "description": "Single / continuous conversion mode for regular conversions\nThis bit is set and cleared by software. If it is set, regular conversion takes place continuously until it\nis cleared.\n0: Single conversion mode\n1: Continuous conversion mode\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden\nto set both DISCEN=1 and CONT=1.\nThe software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\nWhen dual mode is enabled (DAMDF bits in ADC_CCR register are not equal to zero), the bit\nCONT of the slave ADC is no more writable and its content is equal to the bit CONT of the\nmaster ADC.\nRM0436 Rev 7 1589/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "12",
                "field": "OVRMOD",
                "description": "Overrun Mode\nThis bit is set and cleared by software and configure the way data overrun is managed.\n0: ADC_DR register is preserved with the old data when an overrun is detected.\n1: ADC_DR register is overwritten with the last conversion result when an overrun is detected.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no regular\nconversion is ongoing).\n"
              },
              {
                "range": "11:10",
                "field": "EXTEN[1:0]",
                "description": "External trigger enable and polarity selection for regular channels\nThese bits are set and cleared by software to select the external trigger polarity and enable the\ntrigger of a regular group.\n00: Hardware trigger detection disabled (conversions can be launched by software)\n01: Hardware trigger detection on the rising edge\n10: Hardware trigger detection on the falling edge\n11: Hardware trigger detection on both the rising and falling edges\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that no\nregular conversion is ongoing).\n"
              },
              {
                "range": "9:5",
                "field": "EXTSEL[4:0]",
                "description": "External trigger selection for regular group\nThese bits select the external event used to trigger the start of conversion of a regular group:\n00000: Event 0\n00001: Event 1\n00010: Event 2\n00011: Event 3\n00100: Event 4\n00101: Event 5\n00110: Event 6\n00111: Event 7\n...\n11111: Event 31\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that no\nregular conversion is ongoing).\n"
              },
              {
                "range": "4:2",
                "field": "RES[2:0]",
                "description": "Data resolution\nThese bits are written by software to select the resolution of the conversion.\n000: 16 bits\n001: 14 bits\n010: 12 bits\n011: 10 bits\n100: 8 bits\nOthers: Reserved, must not be used.\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              },
              {
                "range": "1:0",
                "field": "DMNGT[1:0]",
                "description": "Data Management configuration\nThis bit is set and cleared by software to select how ADC interface output data are managed.\n00: Regular conversion data stored in DR only\n01: DMA One Shot Mode selected\n10: DFSDM mode selected\n11: DMA Circular Mode selected\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nIn dual-ADC modes, this bit is not relevant and replaced by control bit DAMDF of the\nADC_CCR register.\n1590/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_CFGR2",
            "offset": "0x10",
            "page": 1591,
            "chapter": "29.6.5",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:28",
                "field": "LSHIFT[3:0]",
                "description": "Left shift factor\nThis bitfield is set and cleared by software to define the left shifting applied to the final result with or\nwithout oversampling.\n0000: No left shift\n0001: Shift left 1-bit\n0010: Shift left 2-bits\n0011: Shift left 3-bits\n0100: Shift left 4-bits\n0101: Shift left 5-bits\n0110: Shift left 6-bits\n0111: Shift left 7-bits\n1000: Shift left 8-bits\n1001: Shift left 9-bits\n1010: Shift left 10-bits\n1011: Shift left 11-bits\n1100: Shift left 12-bits\n1101: Shift left 13-bits\n1110: Shift left 14-bits\n1111: Shift left 15-bits\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n"
              },
              {
                "range": "27:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:16",
                "field": "OSVR[9:0]",
                "description": "Oversampling ratio\nThis bitfield is set and cleared by software to define the oversampling ratio.\n0: 1x (no oversampling)\n1: 2x\n2: 3x\n...\n1023: 1024x\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n"
              },
              {
                "range": "15",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "14",
                "field": "RSHIFT4",
                "description": "Right-shift data after Offset 4 correction\nRefer to RSHIFT1 description.\nRM0436 Rev 7 1591/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              },
              {
                "range": "13",
                "field": "RSHIFT3",
                "description": "Right-shift data after Offset 3 correction\nRefer to RSHIFT1 description\n"
              },
              {
                "range": "12",
                "field": "RSHIFT2",
                "description": "Right-shift data after Offset 2 correction\nRefer to RSHIFT1 description\n"
              },
              {
                "range": "11",
                "field": "RSHIFT1",
                "description": "Right-shift data after Offset 1 correction\nThis bitfield is set and cleared by software to right-shift 1-bit data after offset1 correction. This bit can\nonly be used for 8-bit and 16-bit data format (see Section: Data register, data alignment and offset\n(ADC_DR, ADC_JDRy, OFFSETy, OFFSETy_CH, OVSS, LSHIFT, RSHIFT, SSATE) for details).\n0: Right-shifting disabled\n1: Data is right-shifted 1-bit.\n"
              },
              {
                "range": "10",
                "field": "ROVSM",
                "description": "Regular Oversampling mode\nThis bit is set and cleared by software to select the regular oversampling mode.\n0: Continued mode: When injected conversions are triggered, the oversampling is temporary\nstopped and continued after the injection sequence (oversampling buffer is maintained during\ninjected sequence)\n1: Resumed mode: When injected conversions are triggered, the current oversampling is aborted\nand resumed from start after the injection sequence (oversampling buffer is zeroed by injected\nsequence start)\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n"
              },
              {
                "range": "9",
                "field": "TROVS",
                "description": "Triggered Regular Oversampling\nThis bit is set and cleared by software to enable triggered oversampling\n0: All oversampled conversions for a channel are done consecutively following a trigger\n1: Each oversampled conversion for a channel needs a new trigger\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n"
              },
              {
                "range": "8:5",
                "field": "OVSS[3:0]",
                "description": "Oversampling right shift\nThis bitfield is set and cleared by software to define the right shifting applied to the raw oversampling\nresult.\n0000: No right shift\n0001: Shift right 1-bit\n0010: Shift right 2-bits\n0011: Shift right 3-bits\n0100: Shift right 4-bits\n0101: Shift right 5-bits\n0110: Shift right 6-bits\n0111: Shift right 7-bits\n1000: Shift right 8-bits\n1001: Shift right 9-bits\n1010: Shift right 10-bits\n1011: Shift right 11-bits\nOthers: Reserved, must not be used.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that no\nconversion is ongoing).\n1592/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "4:2",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "1",
                "field": "JOVSE",
                "description": "Injected Oversampling Enable\nThis bit is set and cleared by software to enable injected oversampling.\n0: Injected Oversampling disabled\n1: Injected Oversampling enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing)\n"
              },
              {
                "range": "0",
                "field": "ROVSE",
                "description": "Regular Oversampling Enable\nThis bit is set and cleared by software to enable regular oversampling.\n0: Regular Oversampling disabled\n1: Regular Oversampling enabled\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing)\n"
              }
            ]
          },
          {
            "registername": "ADC_SMPR1",
            "offset": "0x14",
            "page": 1593,
            "chapter": "29.6.6",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:0",
                "field": "SMPx[2:0]",
                "description": "Channel x sampling time selection (x = 9 to 0)\nThese bits are written by software to select the sampling time individually for each channel.\nDuring sample cycles, the channel selection bits must remain unchanged.\n000: 1.5 ADC clock cycles\n001: 2.5 ADC clock cycles\n010: 8.5 ADC clock cycles\n011: 16.5 ADC clock cycles\n100: 32.5 ADC clock cycles\n101: 64.5 ADC clock cycles\n110: 387.5 ADC clock cycles\n111: 810.5 ADC clock cycles\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\nRM0436 Rev 7 1593/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_SMPR2",
            "offset": "0x18",
            "page": 1594,
            "chapter": "29.6.7",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:0",
                "field": "SMPx[2:0]",
                "description": "Channel x sampling time selection (x = 19 to 10)\nThese bits are written by software to select the sampling time individually for each channel.\nDuring sampling cycles, the channel selection bits must remain unchanged.\n000: 1.5 ADC clock cycles\n001: 2.5 ADC clock cycles\n010: 8.5 ADC clock cycles\n011: 16.5 ADC clock cycles\n100: 32.5 ADC clock cycles\n101: 64.5 ADC clock cycles\n110: 387.5 ADC clock cycles\n111: 810.5 ADC clock cycles\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\n1594/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_PCSEL",
            "offset": "0x1C",
            "page": 1595,
            "chapter": "29.6.8",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "PCSEL[19:0]",
                "description": "Channel x (V ) pre selection (x = 0 to 19)\nINP[i]\nThese bits are written by software to pre select the input channel at IO instance to be\nconverted.\n0: Input Channel x (Vinp x) is not pre selected for conversion, the ADC conversion result with\nthis channel shows wrong result.\n1: Input Channel x (Vinp x) is pre selected for conversion\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_LTR1",
            "offset": "0x20",
            "page": 1595,
            "chapter": "29.6.9",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "LTR1[25:0]",
                "description": "Analog watchdog 1 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog 1.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy)\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nRM0436 Rev 7 1595/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_HTR1",
            "offset": "0x24",
            "page": 1596,
            "chapter": "29.6.10",
            "resetvalue": "0x03ffffff",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "HTR1[25:0]",
                "description": "Analog watchdog 1 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog 1.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy)\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n1596/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_SQR1",
            "offset": "0x30",
            "page": 1597,
            "chapter": "29.6.11",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:24",
                "field": "SQ4[4:0]",
                "description": "4th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 4th in the\nregular conversion sequence.\n"
              },
              {
                "range": "23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22:18",
                "field": "SQ3[4:0]",
                "description": "3rd conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 3rd in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16:12",
                "field": "SQ2[4:0]",
                "description": "2nd conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 2nd in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:6",
                "field": "SQ1[4:0]",
                "description": "1st conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 1st in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "5:4",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "3:0",
                "field": "L[3:0]",
                "description": "Regular channel sequence length\nThese bits are written by software to define the total number of conversions in the regular\nchannel conversion sequence.\n0000: 1 conversion\n0001: 2 conversions\n...\n1111: 16 conversions\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\nRM0436 Rev 7 1597/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_SQR2",
            "offset": "0x34",
            "page": 1598,
            "chapter": "29.6.12",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:24",
                "field": "SQ9[4:0]",
                "description": "9th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 9th in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22:18",
                "field": "SQ8[4:0]",
                "description": "8th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 8th in the\nregular conversion sequence\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16:12",
                "field": "SQ7[4:0]",
                "description": "7th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 7th in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:6",
                "field": "SQ6[4:0]",
                "description": "6th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 6th in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "SQ5[4:0]",
                "description": "5th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 5th in the\nregular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n1598/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_SQR3",
            "offset": "0x38",
            "page": 1599,
            "chapter": "29.6.13",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:29",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "28:24",
                "field": "SQ14[4:0]",
                "description": "14th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 14th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "23",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "22:18",
                "field": "SQ13[4:0]",
                "description": "13th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 13th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "17",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "16:12",
                "field": "SQ12[4:0]",
                "description": "12th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 12th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:6",
                "field": "SQ11[4:0]",
                "description": "11th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 11th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "SQ10[4:0]",
                "description": "10th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 10th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\nRM0436 Rev 7 1599/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_SQR4",
            "offset": "0x3C",
            "page": 1600,
            "chapter": "29.6.14",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:6",
                "field": "SQ16[4:0]",
                "description": "16th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 16th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n"
              },
              {
                "range": "5",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "4:0",
                "field": "SQ15[4:0]",
                "description": "15th conversion in regular sequence\nThese bits are written by software with the channel number (0..19) assigned as the 15th in\nthe regular conversion sequence.\nNote: The software is allowed to write these bits only when ADSTART=0 (which ensures that\nno regular conversion is ongoing).\n1600/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_DR",
            "offset": "0x40",
            "page": 1601,
            "chapter": "29.6.15",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "RDATA[31:0]",
                "description": "Regular Data converted\nThese bits are read-only. They contain the conversion result from the last converted regular channel.\nThe data are left- or right-aligned as described in Section29.4.27: Data management.\nRM0436 Rev 7 1601/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_JSQR",
            "offset": "0x4C",
            "page": 1602,
            "chapter": "29.6.16",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:27",
                "field": "JSQ4[4:0]",
                "description": "4th conversion in the injected sequence\nThese bits are written by software with the channel number (0..19) assigned as the 4th in the\ninjected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing) unless the context queue is enabled (JQDIS=0 in\nADC_CFGR register).\n"
              },
              {
                "range": "26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:21",
                "field": "JSQ3[4:0]",
                "description": "3rd conversion in the injected sequence\nThese bits are written by software with the channel number (0..19) assigned as the 3rd in the\ninjected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing) unless the context queue is enabled (JQDIS=0 in\nADC_CFGR register).\n"
              },
              {
                "range": "20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:15",
                "field": "JSQ2[4:0]",
                "description": "2nd conversion in the injected sequence\nThese bits are written by software with the channel number (0..19) assigned as the 2nd in\nthe injected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing) unless the context queue is enabled (JQDIS=0 in\nADC_CFGR register).\n"
              },
              {
                "range": "14",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "13:9",
                "field": "JSQ1[4:0]",
                "description": "1st conversion in the injected sequence\nThese bits are written by software with the channel number (0..19) assigned as the 1st in the\ninjected conversion sequence.\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing) unless the context queue is enabled (JQDIS=0 in\nADC_CFGR register).\n1602/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              },
              {
                "range": "8:7",
                "field": "JEXTEN[1:0]",
                "description": "External trigger enable and polarity selection for injected channels\nThese bits are set and cleared by software to select the external trigger polarity and enable\nthe trigger of an injected group.\n00: If JQDIS=0 (queue enabled), Hardware and software trigger detection disabled and\nIf JQDIS=1 (queue disabled), Hardware trigger detection disabled (conversions can be\nlaunched by software\n01: Hardware trigger detection on the rising edge\n10: Hardware trigger detection on the falling edge\n11: Hardware trigger detection on both the rising and falling edges\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing).\nIf JQM=1 and if the Queue of Context becomes empty, the software and hardware\ntriggers of the injected sequence are both internally disabled (refer to Section29.4.22:\nQueue of context for injected conversions)\n"
              },
              {
                "range": "6:2",
                "field": "JEXTSEL[4:0]",
                "description": "External trigger selection for injected group\nThese bits select the external event used to trigger the start of conversion of an injected\ngroup:\n00000: Event 0\n00001: Event 1\n00010: Event 2\n00011: Event 3\n00100: Event 4\n00101: Event 5\n00110: Event 6\n00111: Event 7\n...\n11111: Event 31:\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing).\n"
              },
              {
                "range": "1:0",
                "field": "JL[1:0]",
                "description": "Injected channel sequence length\nThese bits are written by software to define the total number of conversions in the injected\nchannel conversion sequence.\n00: 1 conversion\n01: 2 conversions\n10: 3 conversions\n11: 4 conversions\nNote: The software is allowed to write these bits only when JADSTART is cleared to 0 (no\ninjected conversion is ongoing).\nRM0436 Rev 7 1603/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_OFRy",
            "offset": "0x60",
            "page": 1604,
            "chapter": "29.6.17",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31",
                "field": "SSATE",
                "description": "Signed saturation Enable\nThis bit is written by software to enable or disable the Signed saturation feature.\nThis bit can be enabled only for 8-bit and 16-bit data format (see Section: Data register, data\nalignment and offset (ADC_DR, ADC_JDRy, OFFSETy, OFFSETy_CH, OVSS, LSHIFT,\nRSHIFT, SSATE) for details).\n0: Offset is subtracted maintaining data integrity and extending result size (9-bit and 17-bit\nsigned format).\n1: Offset is subtracted and result is saturated to maintain result size.\nNote: The software is allowed to write this bit only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\n"
              },
              {
                "range": "30:26",
                "field": "OFFSET_CH[4:0]",
                "description": "Channel selection for the Data offset y\nThese bits are written by software to define the channel to which the offset programmed into\nbits OFFSETy[25:0] applies.\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\n"
              },
              {
                "range": "25:0",
                "field": "OFFSET[25:0]",
                "description": "Data offset y for the channel programmed into bits OFFSETy_CH[4:0]\nThese bits are written by software to define the offset y to be subtracted from the raw\nconverted data when converting a channel (can be regular or injected). The channel to which\napplies the data offset y must be programmed in the bits OFFSETy_CH[4:0]. The conversion\nresult can be read from in the ADC_DR (regular conversion) or from in the ADC_JDRyi\nregisters (injected conversion).\nWhen OFFSETy[25:0] bitfield is reset, the offset compensation is disabled.\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0\n(which ensures that no conversion is ongoing).\nIf several offset (OFFSETy) point to the same channel, only the offset with the lowest x\nvalue is considered for the subtraction.\nEx: if OFFSET1_CH[4:0]=4 and OFFSET2_CH[4:0]=4, this is OFFSET1[25:0] which is\nsubtracted when converting channel 4.\n1604/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_JDRy",
            "offset": "0x80",
            "page": 1605,
            "chapter": "29.6.18",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:0",
                "field": "JDATA[31:0]",
                "description": "Injected data\nThese bits are read-only. They contain the conversion result from injected channel y. The\ndata are left -or right-aligned as described in Section29.4.27: Data management.\n29.6.19 ADC analog watchdog 2 configuration register\n(ADC_AWD2CR)\nAddress offset: 0xA0\nReset value: 0x0000 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. AWD2CH[19:16]\nrw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nAWD2CH[15:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "AWD2CH[19:0]",
                "description": "Analog watchdog 2 channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded\nby the analog watchdog 2.\nAWD2CH[i] = 0: ADC analog input channel-i is not monitored by AWD2\nAWD2CH[i] = 1: ADC analog input channel-i is monitored by AWD2\nWhen AWD2CH[19:0] = 000..0, the analog Watchdog 2 is disabled\nNote: The channels selected by AWD2CH must be also selected into the SQi or JSQi bits.\nThe software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nRM0436 Rev 7 1605/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n29.6.20 ADC analog watchdog 3 configuration register\n(ADC_AWD3CR)\nAddress offset: 0xA4\nReset value: 0x0000 0000\n31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16\nRes. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. Res. AWD3CH[19:16]\nrw rw rw rw\n15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0\nAWD3CH[15:0]\nrw rw rw rw rw rw rw rw rw rw rw rw rw rw rw rw\n"
              },
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "AWD3CH[19:0]",
                "description": "Analog watchdog 3 channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded\nby the analog watchdog 3.\nAWD3CH[i] = 0: ADC analog input channel-i is not monitored by AWD3\nAWD3CH[i] = 1: ADC analog input channel-i is monitored by AWD3\nWhen AWD3CH[19:0] = 000..0, the analog Watchdog 3 is disabled\nNote: The channels selected by AWD3CH must be also selected into the SQi or JSQi bits.\nThe software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_LTR2",
            "offset": "0xB0",
            "page": 1606,
            "chapter": "29.6.21",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "LTR2[25:0]",
                "description": "Analog watchdog 2 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog 2.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n1606/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_HTR2",
            "offset": "0xB4",
            "page": 1607,
            "chapter": "29.6.22",
            "resetvalue": "0x03ffffff",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "HTR2[25:0]",
                "description": "Analog watchdog 2 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog 2.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy).\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_LTR3",
            "offset": "0xB8",
            "page": 1607,
            "chapter": "29.6.23",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "LTR3[25:0]",
                "description": "Analog watchdog 3 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog 3.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy)\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\nRM0436 Rev 7 1607/4054\n1622\nAnalog-to-digital converters (ADC) RM0436\n"
              }
            ]
          },
          {
            "registername": "ADC_HTR3",
            "offset": "0xBC",
            "page": 1608,
            "chapter": "29.6.24",
            "resetvalue": "0x03ffffff",
            "bits": [
              {
                "range": "31:26",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "25:0",
                "field": "HTR3[25:0]",
                "description": "Analog watchdog 3 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog 3.\nRefer to Section29.4.30: Analog window watchdog (AWD1EN, JAWD1EN, AWD1SGL, AWD1CH,\nAWD2CH, AWD3CH, AWD_HTRy, AWD_LTRy, AWDy)\nNote: The software is allowed to write these bits only when ADSTART=0 and JADSTART=0 (which\nensures that no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_DIFSEL",
            "offset": "0xC0",
            "page": 1608,
            "chapter": "29.6.25",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:20",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "19:0",
                "field": "DIFSEL[19:0]",
                "description": "Differential mode for channels 19 to 0\nThese bits are set and cleared by software. They allow to select if a channel is configured as single\nended or differential mode.\nDIFSEL[i] = 0: ADC analog input channel-i is configured in single ended mode\nDIFSEL[i] = 1: ADC analog input channel-i is configured in differential mode\nNote: The software is allowed to write these bits only when the ADC is disabled (ADCAL=0,\nJADSTART=0, JADSTP=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).\n1608/4054 RM0436 Rev 7\nRM0436 Analog-to-digital converters (ADC)\n"
              }
            ]
          },
          {
            "registername": "ADC_CALFACT",
            "offset": "0xC4",
            "page": 1609,
            "chapter": "29.6.26",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:27",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "26:16",
                "field": "CALFACT_D[10:0]",
                "description": "Calibration Factors in differential mode\nThese bits are written by hardware or by software.\nOnce a differential inputs calibration is complete,they are updated by hardware with the calibration\nfactors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different\nfrom the current one stored into the analog ADC, it is then applied once a new differential conversion\nis launched.\nNote: The software is allowed to write these bits only when ADEN=1, ADSTART=0 and JADSTART=0\n(ADC is enabled and no calibration is ongoing and no conversion is ongoing).\n"
              },
              {
                "range": "15:11",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "10:0",
                "field": "CALFACT_S[10:0]",
                "description": "Calibration Factors In single-Ended mode\nThese bits are written by hardware or by software.\nOnce a single-ended inputs calibration is complete,they are updated by hardware with the\ncalibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different\nfrom the current one stored into the analog ADC, it is then applied once a new single-ended\nconversion is launched.\nNote: The software is allowed to write these bits only when ADEN=1, ADSTART=0 and JADSTART=0\n(ADC is enabled and no calibration is ongoing and no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC_CALFACT2",
            "offset": "0xC8",
            "page": 1609,
            "chapter": "29.6.27",
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:30",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "29:0",
                "field": "LINCALFACT[29:0]",
                "description": "Linearity Calibration Factor\nThese bits are written by hardware or by software.\nThey hold 30-bit out of the 160-bit linearity calibration factor.\nOnce a single-ended inputs calibration is complete,they are updated by hardware with the\ncalibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is different\nfrom the current one stored into the analog ADC, it is then applied once a new single-ended\ncalibration is launched.\nNote: The software is allowed to write these bits only when ADEN=1, ADSTART=0 and JADSTART=0\n(ADC is enabled and no calibration is ongoing and no conversion is ongoing).\n"
              }
            ]
          },
          {
            "registername": "ADC2_OR",
            "offset": "0xD0",
            "page": 1610,
            "resetvalue": "0x00000000",
            "bits": [
              {
                "range": "31:1",
                "field": "Reserved",
                "description": "must be kept at reset value.\n"
              },
              {
                "range": "0",
                "field": "VDDCOREEN",
                "description": "V enable bit\nDDCORE\nThis bit can be set and cleared by software to control ADC2 channel 14.\n0: V channel disabled\nDDCORE\n1: V channel enabled\nDDCORE\n"
              }
            ]
          }
        ]
      }
    ]
  }
]